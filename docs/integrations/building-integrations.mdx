---
title: Building Integrations
description: Create custom clients using the DorkOS Transport interface
---

# Building Integrations

DorkOS uses a hexagonal (ports & adapters) architecture centered on the **Transport** interface. You can build custom clients by implementing this interface or by using the REST/SSE API directly.

## The Transport Interface

The Transport interface (`packages/shared/src/transport.ts`) defines all client-server communication:

```typescript
interface Transport {
  createSession(opts: CreateSessionRequest): Promise<Session>;
  listSessions(cwd?: string): Promise<Session[]>;
  getSession(id: string, cwd?: string): Promise<Session>;
  updateSession(id: string, opts: UpdateSessionRequest, cwd?: string): Promise<Session>;
  getMessages(sessionId: string, cwd?: string): Promise<{ messages: HistoryMessage[] }>;
  sendMessage(sessionId, content, onEvent, signal?, cwd?): Promise<void>;
  approveTool(sessionId: string, toolCallId: string): Promise<{ ok: boolean }>;
  denyTool(sessionId: string, toolCallId: string): Promise<{ ok: boolean }>;
  submitAnswers(sessionId, toolCallId, answers): Promise<{ ok: boolean }>;
  getTasks(sessionId: string, cwd?: string): Promise<{ tasks: TaskItem[] }>;
  browseDirectory(dirPath?, showHidden?): Promise<BrowseDirectoryResponse>;
  getDefaultCwd(): Promise<{ path: string }>;
  getCommands(refresh?: boolean, cwd?: string): Promise<CommandRegistry>;
  listFiles(cwd: string): Promise<FileListResponse>;
  getGitStatus(cwd?: string): Promise<GitStatusResponse | GitStatusError>;
  health(): Promise<HealthResponse>;
  getConfig(): Promise<ServerConfig>;
}
```

## Built-in Implementations

<Tabs items={["HttpTransport", "DirectTransport"]}>

<Tab value="HttpTransport">
**HttpTransport** is used by the standalone web client and communicates with the Express server over HTTP and SSE:

- Standard `fetch()` for CRUD operations
- Server-Sent Events for streaming in `sendMessage()`
- Parses SSE events into `StreamEvent` objects
- Includes `X-Client-Id` header for session locking
</Tab>

<Tab value="DirectTransport">
**DirectTransport** is used by the Obsidian plugin and calls service instances directly in the same process:

- No HTTP, no port binding, no network serialization
- Iterates `AsyncGenerator<StreamEvent>` from the Agent SDK
- Lower latency, ideal for embedded contexts
</Tab>

</Tabs>

## Building a Custom Client

Choose the approach that best fits your platform and requirements:

<Tabs items={["REST/SSE API", "Custom Transport", "React Integration"]}>

<Tab value="REST/SSE API">
Use the REST API directly for any language or platform:

```bash
# List sessions
GET /api/sessions

# Create a session
POST /api/sessions
Content-Type: application/json
{ "cwd": "/path/to/project" }

# Send a message (returns SSE stream)
POST /api/sessions/:id/messages
Content-Type: application/json
{ "content": "Hello", "cwd": "/path/to/project" }

# Approve a tool call
POST /api/sessions/:id/approve
Content-Type: application/json
{ "toolCallId": "tc_123" }
```

<Callout type="info">
  The full REST API is documented interactively at `/api/docs` (Scalar UI) when the server is running, or see the [API Reference](/docs/api).
</Callout>
</Tab>

<Tab value="Custom Transport">
Implement the Transport interface for deeper integration:

```typescript
import type { Transport } from '@dorkos/shared/transport';

class MyCustomTransport implements Transport {
  async listSessions() {
    // Your implementation
  }

  async sendMessage(sessionId, content, onEvent, signal, cwd) {
    // Connect to your backend
    // Call onEvent() for each StreamEvent
  }

  // ... implement remaining methods
}
```

<Callout type="warn">
  All methods in the Transport interface must be implemented. TypeScript will report compile-time errors for any missing methods.
</Callout>
</Tab>

<Tab value="React Integration">
If building a React app, inject your Transport via context:

```typescript
import { TransportProvider } from '@dorkos/shared';

const transport = new MyCustomTransport();

function App() {
  return (
    <TransportProvider transport={transport}>
      <YourApp />
    </TransportProvider>
  );
}
```

All DorkOS hooks (`useSessions`, `useChatSession`, etc.) consume the Transport from context, so your custom implementation powers the entire UI automatically.
</Tab>

</Tabs>

## StreamEvent Types

Events emitted during message streaming:

<TypeTable type={{
  "text_delta": { type: "StreamEvent", description: "Incremental text chunk for the assistant message" },
  "tool_call_start": { type: "StreamEvent", description: "Tool invocation begins (includes toolCallId, toolName)" },
  "tool_call_delta": { type: "StreamEvent", description: "Incremental tool input/output" },
  "tool_call_end": { type: "StreamEvent", description: "Tool invocation completes" },
  "tool_result": { type: "StreamEvent", description: "Tool execution result" },
  "approval_required": { type: "StreamEvent", description: "Tool needs user approval before executing" },
  "question_prompt": { type: "StreamEvent", description: "Claude is asking the user a question with options" },
  "error": { type: "StreamEvent", description: "Error occurred during execution" },
  "done": { type: "StreamEvent", description: "Message stream complete" },
  "session_status": { type: "StreamEvent", description: "Session state changed" },
  "task_update": { type: "StreamEvent", description: "Task list updated" },
}} />

## Next Steps

<Cards>
  <Card title="SSE Protocol" href="/docs/integrations/sse-protocol">
    Wire format details, event schemas, and connection lifecycle for the streaming protocol.
  </Card>
  <Card title="API Reference" href="/docs/api">
    Full interactive API documentation with request and response schemas.
  </Card>
  <Card title="Architecture" href="/docs/contributing/architecture">
    Deep dive into the hexagonal architecture and Transport interface design.
  </Card>
</Cards>
