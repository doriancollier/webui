{
  "spec": "specs/mesh-server-client-integration/02-specification.md",
  "slug": "mesh-server-client-integration",
  "generatedAt": "2026-02-25T12:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Server Foundation",
      "subject": "[mesh-server-client-integration] [P1] Create mesh feature flag module and update config route",
      "description": "Create the Mesh feature flag state module and wire it into the config route so the client can detect whether Mesh is enabled.\n\n## Files to Create\n\n### `apps/server/src/services/mesh/mesh-state.ts` (NEW)\n\nFollow the exact pattern of `services/relay/relay-state.ts`:\n\n```typescript\n/**\n * Lightweight mesh feature state registry.\n *\n * Holds the runtime enabled/disabled state of the Mesh agent discovery subsystem\n * so that the config route can report it without a circular dependency on index.ts.\n * Set once during server startup by `index.ts` when MeshCore is initialized.\n *\n * @module services/mesh/mesh-state\n */\n\n/** Mutable Mesh runtime state shared across the server process. */\nconst state = {\n  enabled: false,\n};\n\n/**\n * Mark the Mesh subsystem as enabled.\n *\n * Called once from `index.ts` after `MeshCore` is successfully created.\n */\nexport function setMeshEnabled(enabled: boolean): void {\n  state.enabled = enabled;\n}\n\n/**\n * Return whether the Mesh subsystem is currently enabled.\n *\n * Consumed by the config route to populate `mesh.enabled` in the GET response.\n */\nexport function isMeshEnabled(): boolean {\n  return state.enabled;\n}\n```\n\n## Files to Modify\n\n### `apps/server/src/routes/config.ts`\n\n1. Add import: `import { isMeshEnabled } from '../services/mesh/mesh-state.js';`\n2. In the GET handler response JSON, add `mesh` alongside existing `pulse` and `relay` fields:\n\n```typescript\nmesh: {\n  enabled: isMeshEnabled(),\n},\n```\n\nThis goes after the `relay` block in the response object.\n\n### `packages/shared/src/schemas.ts`\n\nAdd `mesh` to `ServerConfigSchema` alongside existing `pulse` and `relay` fields:\n\n```typescript\nmesh: z\n  .object({\n    enabled: z.boolean().openapi({ description: 'Whether the Mesh agent discovery subsystem is enabled' }),\n  })\n  .optional()\n  .openapi({ description: 'Mesh agent discovery feature state' }),\n```\n\nThis goes after the `relay` field definition in `ServerConfigSchema`.\n\n### `turbo.json`\n\nAdd `\"DORKOS_MESH_ENABLED\"` to the `globalPassThroughEnv` array, alongside the existing `DORKOS_RELAY_ENABLED` and `DORKOS_PULSE_ENABLED` entries.\n\n## Acceptance Criteria\n\n- `isMeshEnabled()` returns `false` by default\n- After `setMeshEnabled(true)`, `isMeshEnabled()` returns `true`\n- GET `/api/config` includes `mesh: { enabled: boolean }` in the response\n- `ServerConfig` TypeScript type includes optional `mesh` field\n- `DORKOS_MESH_ENABLED` is in `turbo.json` globalPassThroughEnv\n- `npm run typecheck` passes",
      "activeForm": "Creating mesh feature flag and config route integration",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.2"]
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Server Foundation",
      "subject": "[mesh-server-client-integration] [P1] Add HTTP request/response schemas to mesh-schemas.ts",
      "description": "Add Zod schemas for all Mesh HTTP request and response validation to the existing `mesh-schemas.ts` file. These schemas will be used by route handlers for `safeParse()` validation.\n\n## File to Modify\n\n### `packages/shared/src/mesh-schemas.ts`\n\nAdd the following schemas after the existing `DenialRecordSchema` at the bottom of the file:\n\n```typescript\n// === HTTP Request/Response Schemas ===\n\n/** Request body for POST /api/mesh/discover */\nexport const DiscoverRequestSchema = z\n  .object({\n    roots: z.array(z.string().min(1)).min(1),\n    maxDepth: z.number().int().min(1).optional(),\n  })\n  .openapi('DiscoverRequest');\n\nexport type DiscoverRequest = z.infer<typeof DiscoverRequestSchema>;\n\n/** Request body for POST /api/mesh/agents */\nexport const RegisterAgentRequestSchema = z\n  .object({\n    path: z.string().min(1),\n    overrides: AgentManifestSchema.partial().optional(),\n    approver: z.string().optional(),\n  })\n  .openapi('RegisterAgentRequest');\n\nexport type RegisterAgentRequest = z.infer<typeof RegisterAgentRequestSchema>;\n\n/** Request body for POST /api/mesh/deny */\nexport const DenyRequestSchema = z\n  .object({\n    path: z.string().min(1),\n    reason: z.string().optional(),\n    denier: z.string().optional(),\n  })\n  .openapi('DenyRequest');\n\nexport type DenyRequest = z.infer<typeof DenyRequestSchema>;\n\n/** Request body for PATCH /api/mesh/agents/:id */\nexport const UpdateAgentRequestSchema = z\n  .object({\n    name: z.string().min(1).optional(),\n    description: z.string().optional(),\n    capabilities: z.array(z.string()).optional(),\n  })\n  .openapi('UpdateAgentRequest');\n\nexport type UpdateAgentRequest = z.infer<typeof UpdateAgentRequestSchema>;\n\n/** Query params for GET /api/mesh/agents */\nexport const AgentListQuerySchema = z\n  .object({\n    runtime: AgentRuntimeSchema.optional(),\n    capability: z.string().optional(),\n  })\n  .openapi('AgentListQuery');\n\nexport type AgentListQuery = z.infer<typeof AgentListQuerySchema>;\n```\n\n## Acceptance Criteria\n\n- All 5 schemas parse valid input correctly\n- `DiscoverRequestSchema` rejects empty `roots` arrays and requires at least one root\n- `RegisterAgentRequestSchema` rejects empty path strings\n- `UpdateAgentRequestSchema` allows all fields to be optional (partial update)\n- `AgentListQuerySchema` validates runtime against the `AgentRuntimeSchema` enum\n- All schemas have `.openapi()` metadata\n- All schemas export corresponding TypeScript types\n- `npm run typecheck` passes",
      "activeForm": "Adding HTTP request/response Zod schemas to mesh-schemas.ts",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1"]
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Server Foundation",
      "subject": "[mesh-server-client-integration] [P1] Create mesh route factory with all HTTP endpoints",
      "description": "Create the Express router factory for all Mesh HTTP endpoints. The router accepts a `MeshCore` instance and exposes discovery, registration, denial, and management routes.\n\n## File to Create\n\n### `apps/server/src/routes/mesh.ts` (NEW)\n\n```typescript\n/**\n * Mesh agent discovery and registry routes — discover agents, register, deny,\n * and manage the agent registry.\n *\n * @module routes/mesh\n */\nimport { Router } from 'express';\nimport type { MeshCore } from '@dorkos/mesh';\nimport {\n  DiscoverRequestSchema,\n  RegisterAgentRequestSchema,\n  DenyRequestSchema,\n  UpdateAgentRequestSchema,\n  AgentListQuerySchema,\n} from '@dorkos/shared/mesh-schemas';\nimport { isWithinBoundary } from '../lib/boundary.js';\n\n/**\n * Create the Mesh router with discovery, registration, and management endpoints.\n *\n * @param meshCore - The MeshCore instance for agent discovery and registry operations\n */\nexport function createMeshRouter(meshCore: MeshCore): Router {\n  const router = Router();\n\n  // POST /discover — Trigger discovery scan\n  router.post('/discover', async (req, res) => {\n    const result = DiscoverRequestSchema.safeParse(req.body);\n    if (!result.success) {\n      return res.status(400).json({ error: 'Validation failed', details: result.error.flatten() });\n    }\n\n    // Validate all roots against directory boundary\n    for (const root of result.data.roots) {\n      if (!isWithinBoundary(root)) {\n        return res.status(403).json({ error: `Path outside allowed boundary: ${root}` });\n      }\n    }\n\n    try {\n      const candidates = [];\n      for await (const candidate of meshCore.discover(result.data.roots, {\n        maxDepth: result.data.maxDepth,\n      })) {\n        candidates.push(candidate);\n      }\n      return res.json({ candidates });\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Discovery failed';\n      return res.status(500).json({ error: message });\n    }\n  });\n\n  // POST /agents — Register an agent\n  router.post('/agents', async (req, res) => {\n    const result = RegisterAgentRequestSchema.safeParse(req.body);\n    if (!result.success) {\n      return res.status(400).json({ error: 'Validation failed', details: result.error.flatten() });\n    }\n\n    if (!isWithinBoundary(result.data.path)) {\n      return res.status(403).json({ error: `Path outside allowed boundary: ${result.data.path}` });\n    }\n\n    try {\n      const agent = await meshCore.register(result.data.path, {\n        overrides: result.data.overrides,\n        approver: result.data.approver ?? 'api',\n      });\n      return res.status(201).json(agent);\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Registration failed';\n      return res.status(422).json({ error: message });\n    }\n  });\n\n  // GET /agents — List registered agents\n  router.get('/agents', (req, res) => {\n    const result = AgentListQuerySchema.safeParse(req.query);\n    if (!result.success) {\n      return res.status(400).json({ error: 'Validation failed', details: result.error.flatten() });\n    }\n\n    try {\n      const agents = meshCore.listAgents(result.data);\n      return res.json({ agents });\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'List failed';\n      return res.status(500).json({ error: message });\n    }\n  });\n\n  // GET /agents/:id — Get agent detail\n  router.get('/agents/:id', (req, res) => {\n    try {\n      const agent = meshCore.getAgent(req.params.id);\n      if (!agent) {\n        return res.status(404).json({ error: 'Agent not found' });\n      }\n      return res.json(agent);\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Get agent failed';\n      return res.status(500).json({ error: message });\n    }\n  });\n\n  // PATCH /agents/:id — Update agent fields\n  router.patch('/agents/:id', (req, res) => {\n    const result = UpdateAgentRequestSchema.safeParse(req.body);\n    if (!result.success) {\n      return res.status(400).json({ error: 'Validation failed', details: result.error.flatten() });\n    }\n\n    try {\n      const updated = meshCore.updateAgent(req.params.id, result.data);\n      if (!updated) {\n        return res.status(404).json({ error: 'Agent not found' });\n      }\n      return res.json(updated);\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Update failed';\n      return res.status(422).json({ error: message });\n    }\n  });\n\n  // DELETE /agents/:id — Unregister an agent\n  router.delete('/agents/:id', (req, res) => {\n    try {\n      const removed = meshCore.unregister(req.params.id);\n      if (!removed) {\n        return res.status(404).json({ error: 'Agent not found' });\n      }\n      return res.json({ success: true });\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Unregister failed';\n      return res.status(500).json({ error: message });\n    }\n  });\n\n  // POST /deny — Deny a candidate\n  router.post('/deny', (req, res) => {\n    const result = DenyRequestSchema.safeParse(req.body);\n    if (!result.success) {\n      return res.status(400).json({ error: 'Validation failed', details: result.error.flatten() });\n    }\n\n    try {\n      meshCore.deny(result.data.path, {\n        reason: result.data.reason,\n        denier: result.data.denier ?? 'api',\n      });\n      return res.json({ success: true });\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Deny failed';\n      return res.status(422).json({ error: message });\n    }\n  });\n\n  // GET /denied — List denied paths\n  router.get('/denied', (_req, res) => {\n    try {\n      const denied = meshCore.listDenied();\n      return res.json({ denied });\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'List denied failed';\n      return res.status(500).json({ error: message });\n    }\n  });\n\n  // DELETE /denied/:encodedPath — Clear a denial\n  router.delete('/denied/:encodedPath', (req, res) => {\n    const decodedPath = decodeURIComponent(req.params.encodedPath);\n\n    // Validate decoded path doesn't contain path traversal\n    if (decodedPath.includes('..')) {\n      return res.status(400).json({ error: 'Invalid path: contains traversal sequences' });\n    }\n\n    try {\n      const cleared = meshCore.clearDenial(decodedPath);\n      if (!cleared) {\n        return res.status(404).json({ error: 'Denial not found' });\n      }\n      return res.json({ success: true });\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'Clear denial failed';\n      return res.status(500).json({ error: message });\n    }\n  });\n\n  return router;\n}\n```\n\nKey implementation details:\n- Uses `isWithinBoundary()` from `lib/boundary.ts` to validate discovery roots and registration paths against the server's directory boundary\n- Discovery route collects all candidates from the `AsyncGenerator` into an array before responding\n- Delete denied path uses `decodeURIComponent` for the path parameter and validates against path traversal (`..`)\n- All routes use Zod `safeParse()` for request validation\n- Error responses follow the same patterns as `routes/relay.ts` (400 for validation, 404 for not found, 422 for domain errors)\n\n## Acceptance Criteria\n\n- All 9 route handlers are implemented\n- POST /discover validates roots against directory boundary (403 for violations)\n- POST /agents validates path against directory boundary\n- All routes return appropriate status codes (201 for creation, 400 for validation, 404 for not found)\n- DELETE /denied/:encodedPath decodes the path and rejects `..` sequences\n- `npm run typecheck` passes",
      "activeForm": "Creating mesh route factory with HTTP endpoints",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.2"],
      "parallelWith": []
    },
    {
      "id": "1.4",
      "phase": 1,
      "phaseName": "Server Foundation",
      "subject": "[mesh-server-client-integration] [P1] Integrate MeshCore into server lifecycle in index.ts",
      "description": "Wire MeshCore initialization, route mounting, MCP dep injection, and graceful shutdown into the server's `index.ts` entry point.\n\n## File to Modify\n\n### `apps/server/src/index.ts`\n\n1. **Add imports** at the top of the file:\n\n```typescript\nimport { MeshCore } from '@dorkos/mesh';\nimport { createMeshRouter } from './routes/mesh.js';\nimport { setMeshEnabled } from './services/mesh/mesh-state.js';\n```\n\n2. **Add global reference** for graceful shutdown alongside existing `relayCore`, `adapterManager`, etc.:\n\n```typescript\nlet meshCore: MeshCore | undefined;\n```\n\n3. **Initialize MeshCore** in the `start()` function. Add after the Relay initialization block (after the `if (relayEnabled) { ... }` block):\n\n```typescript\n// Initialize Mesh if enabled\nconst meshEnabled = process.env.DORKOS_MESH_ENABLED === 'true';\n\nif (meshEnabled) {\n  const dorkHome = process.env.DORK_HOME || path.join(os.homedir(), '.dork');\n  meshCore = new MeshCore({\n    dataDir: path.join(dorkHome, 'mesh'),\n    relayCore, // undefined when Relay is disabled — MeshCore handles this gracefully\n  });\n  logger.info('[Mesh] MeshCore initialized');\n}\n```\n\n4. **Add meshCore to MCP deps**. Modify the existing `createDorkOsToolServer` call to include meshCore:\n\n```typescript\nconst mcpToolServer = createDorkOsToolServer({\n  transcriptReader,\n  defaultCwd: process.env.DORKOS_DEFAULT_CWD ?? process.cwd(),\n  ...(pulseStore && { pulseStore }),\n  ...(relayCore && { relayCore }),\n  ...(adapterManager && { adapterManager }),\n  ...(traceStore && { traceStore }),\n  ...(meshCore && { meshCore }),\n});\n```\n\n5. **Mount routes** after the Relay route mounting block:\n\n```typescript\n// Mount Mesh routes if enabled\nif (meshEnabled && meshCore) {\n  app.use('/api/mesh', createMeshRouter(meshCore));\n  setMeshEnabled(true);\n  logger.info('[Mesh] Routes mounted');\n}\n```\n\n6. **Add shutdown handler**. In the `shutdown()` function, add MeshCore cleanup AFTER the relayCore/traceStore cleanup (since Mesh may reference RelayCore for endpoint deregistration):\n\n```typescript\nif (meshCore) {\n  meshCore.close();\n}\n```\n\n## Acceptance Criteria\n\n- Server starts successfully with `DORKOS_MESH_ENABLED=true`\n- Server starts successfully without `DORKOS_MESH_ENABLED` (Mesh disabled, no errors)\n- When enabled, `GET /api/config` shows `mesh: { enabled: true }`\n- When disabled, `GET /api/config` shows `mesh: { enabled: false }`\n- Mesh routes are accessible at `/api/mesh/*` when enabled\n- Mesh routes return 404 when disabled (not mounted)\n- MeshCore data directory is created at `~/.dork/mesh/`\n- Graceful shutdown calls `meshCore.close()` after Relay cleanup\n- `npm run typecheck` passes\n- `npm run build` passes",
      "activeForm": "Integrating MeshCore into server lifecycle",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1", "1.3"],
      "parallelWith": []
    },
    {
      "id": "1.5",
      "phase": 1,
      "phaseName": "Server Foundation",
      "subject": "[mesh-server-client-integration] [P1] Add server route tests for mesh endpoints",
      "description": "Write comprehensive route handler tests for all Mesh endpoints with a mock MeshCore.\n\n## File to Create\n\n### `apps/server/src/routes/__tests__/mesh.test.ts` (NEW)\n\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport express from 'express';\nimport request from 'supertest';\nimport { createMeshRouter } from '../mesh.js';\n\n// Mock boundary to always allow\nvi.mock('../../lib/boundary.js', () => ({\n  isWithinBoundary: vi.fn().mockReturnValue(true),\n}));\n\nfunction createMockMeshCore() {\n  return {\n    discover: vi.fn(),\n    register: vi.fn(),\n    listAgents: vi.fn().mockReturnValue([]),\n    getAgent: vi.fn(),\n    updateAgent: vi.fn(),\n    unregister: vi.fn(),\n    deny: vi.fn(),\n    listDenied: vi.fn().mockReturnValue([]),\n    clearDenial: vi.fn(),\n    close: vi.fn(),\n  };\n}\n\nfunction createApp(meshCore: ReturnType<typeof createMockMeshCore>) {\n  const app = express();\n  app.use(express.json());\n  app.use('/api/mesh', createMeshRouter(meshCore as any));\n  return app;\n}\n\ndescribe('Mesh Routes', () => {\n  let meshCore: ReturnType<typeof createMockMeshCore>;\n  let app: express.Express;\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    meshCore = createMockMeshCore();\n    app = createApp(meshCore);\n  });\n\n  describe('POST /api/mesh/discover', () => {\n    it('returns candidates from discovery scan', async () => {\n      const mockCandidates = [\n        { path: '/projects/bot', strategy: 'claude-code', hints: { suggestedName: 'bot', detectedRuntime: 'claude-code' }, discoveredAt: new Date().toISOString() },\n      ];\n      meshCore.discover.mockImplementation(async function* () {\n        for (const c of mockCandidates) yield c;\n      });\n\n      const res = await request(app)\n        .post('/api/mesh/discover')\n        .send({ roots: ['/projects'] });\n\n      expect(res.status).toBe(200);\n      expect(res.body.candidates).toHaveLength(1);\n      expect(res.body.candidates[0].path).toBe('/projects/bot');\n    });\n\n    it('returns 400 for empty roots array', async () => {\n      const res = await request(app)\n        .post('/api/mesh/discover')\n        .send({ roots: [] });\n\n      expect(res.status).toBe(400);\n      expect(res.body.error).toBe('Validation failed');\n    });\n\n    it('returns 400 for missing roots', async () => {\n      const res = await request(app)\n        .post('/api/mesh/discover')\n        .send({});\n\n      expect(res.status).toBe(400);\n    });\n  });\n\n  describe('POST /api/mesh/agents', () => {\n    it('registers an agent and returns 201', async () => {\n      const mockAgent = { id: 'agent-1', name: 'Bot', runtime: 'claude-code', registeredAt: new Date().toISOString(), registeredBy: 'api' };\n      meshCore.register.mockResolvedValue(mockAgent);\n\n      const res = await request(app)\n        .post('/api/mesh/agents')\n        .send({ path: '/projects/bot' });\n\n      expect(res.status).toBe(201);\n      expect(res.body.id).toBe('agent-1');\n    });\n\n    it('returns 400 for empty path', async () => {\n      const res = await request(app)\n        .post('/api/mesh/agents')\n        .send({ path: '' });\n\n      expect(res.status).toBe(400);\n    });\n  });\n\n  describe('GET /api/mesh/agents', () => {\n    it('returns agent list', async () => {\n      meshCore.listAgents.mockReturnValue([{ id: 'a1', name: 'Bot' }]);\n\n      const res = await request(app).get('/api/mesh/agents');\n\n      expect(res.status).toBe(200);\n      expect(res.body.agents).toHaveLength(1);\n    });\n\n    it('passes runtime filter', async () => {\n      await request(app).get('/api/mesh/agents?runtime=claude-code');\n\n      expect(meshCore.listAgents).toHaveBeenCalledWith(\n        expect.objectContaining({ runtime: 'claude-code' })\n      );\n    });\n  });\n\n  describe('GET /api/mesh/agents/:id', () => {\n    it('returns agent detail', async () => {\n      meshCore.getAgent.mockReturnValue({ id: 'a1', name: 'Bot' });\n\n      const res = await request(app).get('/api/mesh/agents/a1');\n\n      expect(res.status).toBe(200);\n      expect(res.body.id).toBe('a1');\n    });\n\n    it('returns 404 for unknown agent', async () => {\n      meshCore.getAgent.mockReturnValue(null);\n\n      const res = await request(app).get('/api/mesh/agents/unknown');\n\n      expect(res.status).toBe(404);\n    });\n  });\n\n  describe('PATCH /api/mesh/agents/:id', () => {\n    it('updates agent fields', async () => {\n      meshCore.updateAgent.mockReturnValue({ id: 'a1', name: 'Updated' });\n\n      const res = await request(app)\n        .patch('/api/mesh/agents/a1')\n        .send({ name: 'Updated' });\n\n      expect(res.status).toBe(200);\n      expect(res.body.name).toBe('Updated');\n    });\n\n    it('returns 404 for unknown agent', async () => {\n      meshCore.updateAgent.mockReturnValue(null);\n\n      const res = await request(app)\n        .patch('/api/mesh/agents/unknown')\n        .send({ name: 'x' });\n\n      expect(res.status).toBe(404);\n    });\n  });\n\n  describe('DELETE /api/mesh/agents/:id', () => {\n    it('unregisters agent', async () => {\n      meshCore.unregister.mockReturnValue(true);\n\n      const res = await request(app).delete('/api/mesh/agents/a1');\n\n      expect(res.status).toBe(200);\n      expect(res.body.success).toBe(true);\n    });\n\n    it('returns 404 for unknown agent', async () => {\n      meshCore.unregister.mockReturnValue(false);\n\n      const res = await request(app).delete('/api/mesh/agents/unknown');\n\n      expect(res.status).toBe(404);\n    });\n  });\n\n  describe('POST /api/mesh/deny', () => {\n    it('denies a candidate path', async () => {\n      const res = await request(app)\n        .post('/api/mesh/deny')\n        .send({ path: '/projects/bad-bot', reason: 'Not wanted' });\n\n      expect(res.status).toBe(200);\n      expect(res.body.success).toBe(true);\n      expect(meshCore.deny).toHaveBeenCalledWith('/projects/bad-bot', expect.objectContaining({ reason: 'Not wanted' }));\n    });\n\n    it('returns 400 for missing path', async () => {\n      const res = await request(app)\n        .post('/api/mesh/deny')\n        .send({});\n\n      expect(res.status).toBe(400);\n    });\n  });\n\n  describe('GET /api/mesh/denied', () => {\n    it('returns denial list', async () => {\n      meshCore.listDenied.mockReturnValue([{ path: '/bad', reason: 'test' }]);\n\n      const res = await request(app).get('/api/mesh/denied');\n\n      expect(res.status).toBe(200);\n      expect(res.body.denied).toHaveLength(1);\n    });\n  });\n\n  describe('DELETE /api/mesh/denied/:encodedPath', () => {\n    it('clears a denial', async () => {\n      meshCore.clearDenial.mockReturnValue(true);\n\n      const res = await request(app).delete(\n        `/api/mesh/denied/${encodeURIComponent('/projects/bot')}`\n      );\n\n      expect(res.status).toBe(200);\n      expect(res.body.success).toBe(true);\n    });\n\n    it('returns 404 for unknown denial', async () => {\n      meshCore.clearDenial.mockReturnValue(false);\n\n      const res = await request(app).delete(\n        `/api/mesh/denied/${encodeURIComponent('/unknown')}`\n      );\n\n      expect(res.status).toBe(404);\n    });\n\n    it('rejects paths with traversal sequences', async () => {\n      const res = await request(app).delete(\n        `/api/mesh/denied/${encodeURIComponent('/projects/../etc/passwd')}`\n      );\n\n      expect(res.status).toBe(400);\n      expect(res.body.error).toContain('traversal');\n    });\n  });\n});\n```\n\nThe test file should be run with: `npx vitest run apps/server/src/routes/__tests__/mesh.test.ts`\n\n## Acceptance Criteria\n\n- All 9 endpoint groups have at least one happy path and one error path test\n- POST /discover tests: valid request with candidates, empty roots rejection, missing roots rejection\n- POST /agents tests: successful registration (201), empty path rejection (400)\n- GET /agents tests: list returns agents, runtime filter passes to meshCore\n- GET /agents/:id tests: found (200), not found (404)\n- PATCH /agents/:id tests: update success, not found (404)\n- DELETE /agents/:id tests: unregister success, not found (404)\n- POST /deny tests: deny success, missing path (400)\n- GET /denied tests: returns list\n- DELETE /denied/:encodedPath tests: success, not found (404), path traversal rejection (400)\n- All tests pass with `npx vitest run`",
      "activeForm": "Writing server route tests for mesh endpoints",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.3"],
      "parallelWith": []
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "MCP Tools & Transport",
      "subject": "[mesh-server-client-integration] [P2] Add MCP tool handlers for mesh operations",
      "description": "Add 5 MCP tools to the DorkOS tool server for mesh discovery, registration, listing, denial, and unregistration. Follow the existing Relay tool pattern exactly.\n\n## File to Modify\n\n### `apps/server/src/services/core/mcp-tool-server.ts`\n\n1. **Add import** at the top:\n\n```typescript\nimport type { MeshCore } from '@dorkos/mesh';\n```\n\n2. **Add `meshCore` to `McpToolDeps`** interface:\n\n```typescript\nexport interface McpToolDeps {\n  // ... existing fields\n  /** Optional MeshCore — undefined when Mesh is disabled */\n  meshCore?: MeshCore;\n}\n```\n\n3. **Add guard function** after the existing `requireRelay` guard:\n\n```typescript\n/** Guard that returns an error response when Mesh is disabled. */\nfunction requireMesh(deps: McpToolDeps) {\n  if (!deps.meshCore) {\n    return jsonContent({ error: 'Mesh is not enabled', code: 'MESH_DISABLED' }, true);\n  }\n  return null;\n}\n```\n\n4. **Add handler factories** after the Relay/Adapter/Trace handler sections:\n\n```typescript\n// --- Mesh Tools ---\n\n/** Discover agents by scanning directories. */\nexport function createMeshDiscoverHandler(deps: McpToolDeps) {\n  return async (args: { roots: string[]; maxDepth?: number }) => {\n    const err = requireMesh(deps);\n    if (err) return err;\n    try {\n      const candidates = [];\n      for await (const candidate of deps.meshCore!.discover(args.roots, {\n        maxDepth: args.maxDepth,\n      })) {\n        candidates.push(candidate);\n      }\n      return jsonContent({ candidates, count: candidates.length });\n    } catch (e) {\n      const message = e instanceof Error ? e.message : 'Discovery failed';\n      return jsonContent({ error: message, code: 'DISCOVER_FAILED' }, true);\n    }\n  };\n}\n\n/** Register an agent from a filesystem path. */\nexport function createMeshRegisterHandler(deps: McpToolDeps) {\n  return async (args: {\n    path: string;\n    name?: string;\n    description?: string;\n    runtime?: string;\n    capabilities?: string[];\n  }) => {\n    const err = requireMesh(deps);\n    if (err) return err;\n    try {\n      const overrides: Record<string, unknown> = {};\n      if (args.name) overrides.name = args.name;\n      if (args.description) overrides.description = args.description;\n      if (args.runtime) overrides.runtime = args.runtime;\n      if (args.capabilities) overrides.capabilities = args.capabilities;\n      const agent = await deps.meshCore!.register(args.path, {\n        overrides: Object.keys(overrides).length > 0 ? overrides : undefined,\n        approver: 'mcp-tool',\n      });\n      return jsonContent({ agent });\n    } catch (e) {\n      const message = e instanceof Error ? e.message : 'Registration failed';\n      return jsonContent({ error: message, code: 'REGISTER_FAILED' }, true);\n    }\n  };\n}\n\n/** List registered agents with optional filters. */\nexport function createMeshListHandler(deps: McpToolDeps) {\n  return async (args: { runtime?: string; capability?: string }) => {\n    const err = requireMesh(deps);\n    if (err) return err;\n    const agents = deps.meshCore!.listAgents(args);\n    return jsonContent({ agents, count: agents.length });\n  };\n}\n\n/** Deny a candidate path from future discovery. */\nexport function createMeshDenyHandler(deps: McpToolDeps) {\n  return async (args: { path: string; reason?: string }) => {\n    const err = requireMesh(deps);\n    if (err) return err;\n    try {\n      deps.meshCore!.deny(args.path, {\n        reason: args.reason,\n        denier: 'mcp-tool',\n      });\n      return jsonContent({ success: true, path: args.path });\n    } catch (e) {\n      const message = e instanceof Error ? e.message : 'Deny failed';\n      return jsonContent({ error: message, code: 'DENY_FAILED' }, true);\n    }\n  };\n}\n\n/** Unregister an agent by ID. */\nexport function createMeshUnregisterHandler(deps: McpToolDeps) {\n  return async (args: { agentId: string }) => {\n    const err = requireMesh(deps);\n    if (err) return err;\n    try {\n      const removed = deps.meshCore!.unregister(args.agentId);\n      if (!removed) {\n        return jsonContent({ error: `Agent ${args.agentId} not found` }, true);\n      }\n      return jsonContent({ success: true, agentId: args.agentId });\n    } catch (e) {\n      const message = e instanceof Error ? e.message : 'Unregister failed';\n      return jsonContent({ error: message, code: 'UNREGISTER_FAILED' }, true);\n    }\n  };\n}\n```\n\n5. **Register tools** in `createDorkOsToolServer`. Add after the `traceTools` definition:\n\n```typescript\nconst meshTools = deps.meshCore\n  ? [\n      tool(\n        'mesh_discover',\n        'Scan directories for agent candidates. Returns paths with detected runtime, capabilities, and suggested names.',\n        {\n          roots: z.array(z.string()).describe('Root directories to scan for agents'),\n          maxDepth: z.number().int().min(1).optional().describe('Maximum directory depth (default 3)'),\n        },\n        createMeshDiscoverHandler(deps)\n      ),\n      tool(\n        'mesh_register',\n        'Register an agent from a filesystem path. Creates a .dork/agent.json manifest and adds the agent to the registry.',\n        {\n          path: z.string().describe('Filesystem path to the agent directory'),\n          name: z.string().optional().describe('Display name override'),\n          description: z.string().optional().describe('Agent description'),\n          runtime: z.string().optional().describe('Runtime: claude-code, cursor, codex, or other'),\n          capabilities: z.array(z.string()).optional().describe('Agent capabilities'),\n        },\n        createMeshRegisterHandler(deps)\n      ),\n      tool(\n        'mesh_list',\n        'List all registered agents with optional filters.',\n        {\n          runtime: z.string().optional().describe('Filter by runtime'),\n          capability: z.string().optional().describe('Filter by capability'),\n        },\n        createMeshListHandler(deps)\n      ),\n      tool(\n        'mesh_deny',\n        'Deny a candidate path from future discovery scans.',\n        {\n          path: z.string().describe('Path to deny'),\n          reason: z.string().optional().describe('Reason for denial'),\n        },\n        createMeshDenyHandler(deps)\n      ),\n      tool(\n        'mesh_unregister',\n        'Unregister an agent by ID, removing it from the registry.',\n        {\n          agentId: z.string().describe('Agent ID to unregister'),\n        },\n        createMeshUnregisterHandler(deps)\n      ),\n    ]\n  : [];\n```\n\n6. **Add to tools array** in the `createSdkMcpServer` call:\n\n```typescript\nreturn createSdkMcpServer({\n  name: 'dorkos',\n  version: '1.0.0',\n  tools: [\n    // ... existing tools\n    ...meshTools,\n  ],\n});\n```\n\n## Acceptance Criteria\n\n- All 5 mesh tools are registered when `meshCore` is provided in deps\n- No mesh tools are registered when `meshCore` is undefined\n- `mesh_discover` collects async generator results into an array\n- `mesh_register` builds overrides object from individual args\n- `mesh_list` passes runtime/capability filters through to `meshCore.listAgents()`\n- `mesh_deny` passes reason and sets denier to `'mcp-tool'`\n- `mesh_unregister` returns error when agent not found\n- All tools return `MESH_DISABLED` error when mesh is not enabled\n- `npm run typecheck` passes",
      "activeForm": "Adding MCP tool handlers for mesh operations",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.4"],
      "parallelWith": ["2.2"]
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "MCP Tools & Transport",
      "subject": "[mesh-server-client-integration] [P2] Add Mesh methods to Transport interface, HttpTransport, and mock transport",
      "description": "Extend the Transport interface with Mesh methods, implement them in HttpTransport, and add mock stubs to the test utilities.\n\n## Files to Modify\n\n### 1. `packages/shared/src/transport.ts`\n\nAdd imports for Mesh types:\n\n```typescript\nimport type {\n  AgentManifest,\n  DiscoveryCandidate,\n  DenialRecord,\n} from './mesh-schemas.js';\n```\n\nAdd Mesh section to the `Transport` interface after the Relay Adapters section:\n\n```typescript\n// --- Mesh Agent Discovery ---\n\n/** Discover agents by scanning directories. */\ndiscoverMeshAgents(roots: string[], maxDepth?: number): Promise<{ candidates: DiscoveryCandidate[] }>;\n/** List registered agents with optional filters. */\nlistMeshAgents(filters?: { runtime?: string; capability?: string }): Promise<{ agents: AgentManifest[] }>;\n/** Get a single registered agent by ID. */\ngetMeshAgent(id: string): Promise<AgentManifest>;\n/** Register an agent from a path with optional overrides. */\nregisterMeshAgent(path: string, overrides?: Partial<AgentManifest>, approver?: string): Promise<AgentManifest>;\n/** Update a registered agent's mutable fields. */\nupdateMeshAgent(id: string, updates: { name?: string; description?: string; capabilities?: string[] }): Promise<AgentManifest>;\n/** Unregister an agent by ID. */\nunregisterMeshAgent(id: string): Promise<{ success: boolean }>;\n/** Deny a candidate path from future discovery. */\ndenyMeshAgent(path: string, reason?: string, denier?: string): Promise<{ success: boolean }>;\n/** List all denied paths. */\nlistDeniedMeshAgents(): Promise<{ denied: DenialRecord[] }>;\n/** Clear a denial to re-allow discovery of a path. */\nclearMeshDenial(path: string): Promise<{ success: boolean }>;\n```\n\n### 2. `apps/client/src/layers/shared/lib/http-transport.ts`\n\nAdd Mesh method implementations at the bottom of the class, before the closing brace. Follow the same patterns as the Relay methods:\n\n```typescript\n// --- Mesh Agent Discovery ---\n\nasync discoverMeshAgents(roots: string[], maxDepth?: number) {\n  return fetchJSON<{ candidates: DiscoveryCandidate[] }>(this.baseUrl, '/mesh/discover', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ roots, maxDepth }),\n  });\n}\n\nasync listMeshAgents(filters?: { runtime?: string; capability?: string }) {\n  const params = new URLSearchParams();\n  if (filters?.runtime) params.set('runtime', filters.runtime);\n  if (filters?.capability) params.set('capability', filters.capability);\n  const qs = params.toString();\n  return fetchJSON<{ agents: AgentManifest[] }>(this.baseUrl, `/mesh/agents${qs ? `?${qs}` : ''}`);\n}\n\nasync getMeshAgent(id: string) {\n  return fetchJSON<AgentManifest>(this.baseUrl, `/mesh/agents/${id}`);\n}\n\nasync registerMeshAgent(path: string, overrides?: Partial<AgentManifest>, approver?: string) {\n  return fetchJSON<AgentManifest>(this.baseUrl, '/mesh/agents', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ path, overrides, approver }),\n  });\n}\n\nasync updateMeshAgent(id: string, updates: { name?: string; description?: string; capabilities?: string[] }) {\n  return fetchJSON<AgentManifest>(this.baseUrl, `/mesh/agents/${id}`, {\n    method: 'PATCH',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(updates),\n  });\n}\n\nasync unregisterMeshAgent(id: string) {\n  return fetchJSON<{ success: boolean }>(this.baseUrl, `/mesh/agents/${id}`, {\n    method: 'DELETE',\n  });\n}\n\nasync denyMeshAgent(path: string, reason?: string, denier?: string) {\n  return fetchJSON<{ success: boolean }>(this.baseUrl, '/mesh/deny', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ path, reason, denier }),\n  });\n}\n\nasync listDeniedMeshAgents() {\n  return fetchJSON<{ denied: DenialRecord[] }>(this.baseUrl, '/mesh/denied');\n}\n\nasync clearMeshDenial(path: string) {\n  return fetchJSON<{ success: boolean }>(this.baseUrl, `/mesh/denied/${encodeURIComponent(path)}`, {\n    method: 'DELETE',\n  });\n}\n```\n\nAlso add the necessary type imports at the top of `http-transport.ts`:\n\n```typescript\nimport type { AgentManifest, DiscoveryCandidate, DenialRecord } from '@dorkos/shared/mesh-schemas';\n```\n\n### 3. `packages/test-utils/src/mock-factories.ts`\n\nAdd mock Mesh methods to `createMockTransport()` after the Relay Adapters section:\n\n```typescript\n// Mesh\ndiscoverMeshAgents: vi.fn().mockResolvedValue({ candidates: [] }),\nlistMeshAgents: vi.fn().mockResolvedValue({ agents: [] }),\ngetMeshAgent: vi.fn(),\nregisterMeshAgent: vi.fn(),\nupdateMeshAgent: vi.fn(),\nunregisterMeshAgent: vi.fn().mockResolvedValue({ success: true }),\ndenyMeshAgent: vi.fn().mockResolvedValue({ success: true }),\nlistDeniedMeshAgents: vi.fn().mockResolvedValue({ denied: [] }),\nclearMeshDenial: vi.fn().mockResolvedValue({ success: true }),\n```\n\n## Acceptance Criteria\n\n- Transport interface includes all 9 Mesh methods with correct signatures\n- HttpTransport implements all 9 methods mapping to the correct HTTP endpoints\n- `clearMeshDenial` uses `encodeURIComponent` for path in the URL\n- Mock transport stubs all 9 methods with reasonable defaults\n- `npm run typecheck` passes across all workspaces\n- `npm run build` passes",
      "activeForm": "Adding Mesh methods to Transport interface and implementations",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.2"],
      "parallelWith": ["2.1"]
    },
    {
      "id": "2.3",
      "phase": 2,
      "phaseName": "MCP Tools & Transport",
      "subject": "[mesh-server-client-integration] [P2] Add MCP tool tests for mesh tools",
      "description": "Add tests for the 5 mesh MCP tools in the existing MCP tool server test file, verifying both enabled and disabled behavior.\n\n## File to Modify or Create\n\nIf `apps/server/src/services/core/__tests__/mcp-tool-server.test.ts` exists, add mesh tests to it. Otherwise create a new test file for mesh tools:\n\n### Test file at `apps/server/src/services/core/__tests__/mesh-tools.test.ts` (NEW if needed)\n\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport {\n  createMeshDiscoverHandler,\n  createMeshRegisterHandler,\n  createMeshListHandler,\n  createMeshDenyHandler,\n  createMeshUnregisterHandler,\n} from '../mcp-tool-server.js';\nimport type { McpToolDeps } from '../mcp-tool-server.js';\n\nfunction createMockDeps(meshEnabled = true): McpToolDeps {\n  const mockMeshCore = {\n    discover: vi.fn(),\n    register: vi.fn(),\n    listAgents: vi.fn().mockReturnValue([]),\n    getAgent: vi.fn(),\n    updateAgent: vi.fn(),\n    unregister: vi.fn(),\n    deny: vi.fn(),\n    listDenied: vi.fn().mockReturnValue([]),\n    clearDenial: vi.fn(),\n    close: vi.fn(),\n  };\n\n  return {\n    transcriptReader: {} as any,\n    defaultCwd: '/test',\n    ...(meshEnabled && { meshCore: mockMeshCore as any }),\n  };\n}\n\ndescribe('Mesh MCP Tools', () => {\n  describe('when mesh is disabled', () => {\n    it('mesh_discover returns MESH_DISABLED error', async () => {\n      const deps = createMockDeps(false);\n      const handler = createMeshDiscoverHandler(deps);\n      const result = await handler({ roots: ['/test'] });\n      expect(result.isError).toBe(true);\n      expect(JSON.parse(result.content[0].text)).toEqual(\n        expect.objectContaining({ code: 'MESH_DISABLED' })\n      );\n    });\n\n    it('mesh_register returns MESH_DISABLED error', async () => {\n      const deps = createMockDeps(false);\n      const handler = createMeshRegisterHandler(deps);\n      const result = await handler({ path: '/test/bot' });\n      expect(result.isError).toBe(true);\n    });\n\n    it('mesh_list returns MESH_DISABLED error', async () => {\n      const deps = createMockDeps(false);\n      const handler = createMeshListHandler(deps);\n      const result = await handler({});\n      expect(result.isError).toBe(true);\n    });\n\n    it('mesh_deny returns MESH_DISABLED error', async () => {\n      const deps = createMockDeps(false);\n      const handler = createMeshDenyHandler(deps);\n      const result = await handler({ path: '/bad' });\n      expect(result.isError).toBe(true);\n    });\n\n    it('mesh_unregister returns MESH_DISABLED error', async () => {\n      const deps = createMockDeps(false);\n      const handler = createMeshUnregisterHandler(deps);\n      const result = await handler({ agentId: 'a1' });\n      expect(result.isError).toBe(true);\n    });\n  });\n\n  describe('when mesh is enabled', () => {\n    it('mesh_discover returns candidates', async () => {\n      const deps = createMockDeps(true);\n      const mockCandidates = [{ path: '/bot', strategy: 'claude-code', hints: {}, discoveredAt: new Date().toISOString() }];\n      (deps.meshCore as any).discover.mockImplementation(async function* () {\n        for (const c of mockCandidates) yield c;\n      });\n\n      const handler = createMeshDiscoverHandler(deps);\n      const result = await handler({ roots: ['/test'] });\n      const data = JSON.parse(result.content[0].text);\n      expect(data.candidates).toHaveLength(1);\n      expect(data.count).toBe(1);\n    });\n\n    it('mesh_register creates an agent', async () => {\n      const deps = createMockDeps(true);\n      const mockAgent = { id: 'a1', name: 'Bot' };\n      (deps.meshCore as any).register.mockResolvedValue(mockAgent);\n\n      const handler = createMeshRegisterHandler(deps);\n      const result = await handler({ path: '/test/bot', name: 'Bot' });\n      const data = JSON.parse(result.content[0].text);\n      expect(data.agent.id).toBe('a1');\n    });\n\n    it('mesh_list returns agents with filters', async () => {\n      const deps = createMockDeps(true);\n      (deps.meshCore as any).listAgents.mockReturnValue([{ id: 'a1' }]);\n\n      const handler = createMeshListHandler(deps);\n      const result = await handler({ runtime: 'claude-code' });\n      const data = JSON.parse(result.content[0].text);\n      expect(data.agents).toHaveLength(1);\n      expect((deps.meshCore as any).listAgents).toHaveBeenCalledWith({ runtime: 'claude-code' });\n    });\n\n    it('mesh_deny denies a path', async () => {\n      const deps = createMockDeps(true);\n\n      const handler = createMeshDenyHandler(deps);\n      const result = await handler({ path: '/bad', reason: 'no good' });\n      const data = JSON.parse(result.content[0].text);\n      expect(data.success).toBe(true);\n      expect((deps.meshCore as any).deny).toHaveBeenCalledWith('/bad', { reason: 'no good', denier: 'mcp-tool' });\n    });\n\n    it('mesh_unregister removes an agent', async () => {\n      const deps = createMockDeps(true);\n      (deps.meshCore as any).unregister.mockReturnValue(true);\n\n      const handler = createMeshUnregisterHandler(deps);\n      const result = await handler({ agentId: 'a1' });\n      const data = JSON.parse(result.content[0].text);\n      expect(data.success).toBe(true);\n    });\n\n    it('mesh_unregister returns error for unknown agent', async () => {\n      const deps = createMockDeps(true);\n      (deps.meshCore as any).unregister.mockReturnValue(false);\n\n      const handler = createMeshUnregisterHandler(deps);\n      const result = await handler({ agentId: 'unknown' });\n      expect(result.isError).toBe(true);\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n\n- All 5 tools tested in disabled mode (return MESH_DISABLED error)\n- All 5 tools tested in enabled mode (happy path)\n- `mesh_unregister` tested for not-found case\n- `mesh_discover` properly collects async generator results\n- `mesh_register` passes overrides built from individual arguments\n- `mesh_deny` passes denier as 'mcp-tool'\n- All tests pass with `npx vitest run`",
      "activeForm": "Writing MCP tool tests for mesh operations",
      "size": "small",
      "priority": "medium",
      "dependencies": ["2.1"],
      "parallelWith": []
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Client Entity Layer",
      "subject": "[mesh-server-client-integration] [P3] Create client entity hooks for mesh data fetching",
      "description": "Create the mesh entity layer with 8 TanStack Query hooks following the relay entity patterns.\n\n## Directory to Create\n\n`apps/client/src/layers/entities/mesh/` with the following structure:\n\n```\nmesh/\n├── model/\n│   ├── use-mesh-config.ts\n│   ├── use-mesh-agents.ts\n│   ├── use-mesh-discover.ts\n│   ├── use-mesh-register.ts\n│   ├── use-mesh-deny.ts\n│   ├── use-mesh-unregister.ts\n│   ├── use-mesh-update.ts\n│   └── use-mesh-denied.ts\n└── index.ts\n```\n\n### `model/use-mesh-config.ts`\n\n```typescript\nimport { useQuery } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\n\n/**\n * Returns whether the Mesh subsystem is enabled on the server.\n * Reads the `mesh.enabled` field from the server config response.\n */\nexport function useMeshEnabled(): boolean {\n  const transport = useTransport();\n  const { data } = useQuery({\n    queryKey: ['config'],\n    queryFn: () => transport.getConfig(),\n    staleTime: 5 * 60 * 1000,\n  });\n  return data?.mesh?.enabled ?? false;\n}\n```\n\n### `model/use-mesh-agents.ts`\n\n```typescript\nimport { useQuery } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\n\n/**\n * Fetch the list of registered agents from the Mesh registry.\n *\n * @param enabled - Only fetches when true (tied to mesh feature flag)\n */\nexport function useRegisteredAgents(enabled: boolean) {\n  const transport = useTransport();\n  return useQuery({\n    queryKey: ['mesh', 'agents'],\n    queryFn: () => transport.listMeshAgents(),\n    enabled,\n    staleTime: 30_000,\n  });\n}\n```\n\n### `model/use-mesh-discover.ts`\n\n```typescript\nimport { useMutation } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\n\n/** Mutation to trigger a discovery scan of directories for agent candidates. */\nexport function useDiscoverAgents() {\n  const transport = useTransport();\n  return useMutation({\n    mutationFn: ({ roots, maxDepth }: { roots: string[]; maxDepth?: number }) =>\n      transport.discoverMeshAgents(roots, maxDepth),\n  });\n}\n```\n\n### `model/use-mesh-register.ts`\n\n```typescript\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\n/** Mutation to register an agent. Invalidates the agents query on success. */\nexport function useRegisterAgent() {\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: ({ path, overrides, approver }: {\n      path: string;\n      overrides?: Partial<AgentManifest>;\n      approver?: string;\n    }) => transport.registerMeshAgent(path, overrides, approver),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['mesh', 'agents'] });\n    },\n  });\n}\n```\n\n### `model/use-mesh-deny.ts`\n\n```typescript\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\n\n/** Mutation to deny a candidate path. Invalidates the denied list on success. */\nexport function useDenyAgent() {\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: ({ path, reason, denier }: { path: string; reason?: string; denier?: string }) =>\n      transport.denyMeshAgent(path, reason, denier),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['mesh', 'denied'] });\n    },\n  });\n}\n```\n\n### `model/use-mesh-unregister.ts`\n\n```typescript\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\n\n/** Mutation to unregister an agent. Invalidates the agents query on success. */\nexport function useUnregisterAgent() {\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: (agentId: string) => transport.unregisterMeshAgent(agentId),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['mesh', 'agents'] });\n    },\n  });\n}\n```\n\n### `model/use-mesh-update.ts`\n\n```typescript\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\n\n/** Mutation to update a registered agent's mutable fields. */\nexport function useUpdateAgent() {\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: ({ id, updates }: {\n      id: string;\n      updates: { name?: string; description?: string; capabilities?: string[] };\n    }) => transport.updateMeshAgent(id, updates),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['mesh', 'agents'] });\n    },\n  });\n}\n```\n\n### `model/use-mesh-denied.ts`\n\n```typescript\nimport { useQuery } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\n\n/**\n * Fetch the list of denied paths.\n *\n * @param enabled - Only fetches when true (tied to mesh feature flag)\n */\nexport function useDeniedAgents(enabled: boolean) {\n  const transport = useTransport();\n  return useQuery({\n    queryKey: ['mesh', 'denied'],\n    queryFn: () => transport.listDeniedMeshAgents(),\n    enabled,\n    staleTime: 30_000,\n  });\n}\n```\n\n### `index.ts`\n\n```typescript\n/**\n * Mesh entity — domain hooks for agent discovery and registry.\n *\n * @module entities/mesh\n */\nexport { useMeshEnabled } from './model/use-mesh-config';\nexport { useRegisteredAgents } from './model/use-mesh-agents';\nexport { useDiscoverAgents } from './model/use-mesh-discover';\nexport { useRegisterAgent } from './model/use-mesh-register';\nexport { useDenyAgent } from './model/use-mesh-deny';\nexport { useUnregisterAgent } from './model/use-mesh-unregister';\nexport { useUpdateAgent } from './model/use-mesh-update';\nexport { useDeniedAgents } from './model/use-mesh-denied';\n```\n\n## Acceptance Criteria\n\n- All 8 hooks are created and exported from the barrel\n- `useMeshEnabled` reads from the config query with 5-minute stale time\n- `useRegisteredAgents` and `useDeniedAgents` use `enabled` parameter to conditionally fetch\n- Mutation hooks (`useRegisterAgent`, `useUnregisterAgent`, `useUpdateAgent`, `useDenyAgent`) invalidate the appropriate query keys on success\n- `useDiscoverAgents` is a mutation (not a query) since discovery is triggered on demand\n- All hooks use `useTransport()` from `@/layers/shared/model`\n- No FSD layer violations (entities only import from shared)\n- `npm run typecheck` passes",
      "activeForm": "Creating client entity hooks for mesh data fetching",
      "size": "medium",
      "priority": "high",
      "dependencies": ["2.2"],
      "parallelWith": ["3.2"]
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "Client Entity Layer",
      "subject": "[mesh-server-client-integration] [P3] Add client entity hook tests for mesh",
      "description": "Write tests for the mesh entity hooks verifying correct query/mutation behavior with mock transport.\n\n## File to Create\n\n### `apps/client/src/layers/entities/mesh/__tests__/mesh-hooks.test.ts` (NEW)\n\n```typescript\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { renderHook, waitFor } from '@testing-library/react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { TransportProvider } from '@/layers/shared/model';\nimport { createMockTransport } from '@dorkos/test-utils';\nimport {\n  useMeshEnabled,\n  useRegisteredAgents,\n  useDiscoverAgents,\n  useRegisterAgent,\n  useUnregisterAgent,\n  useDeniedAgents,\n} from '../index';\nimport type { Transport } from '@dorkos/shared/transport';\nimport type { ReactNode } from 'react';\n\nfunction createWrapper(transport: Transport) {\n  const queryClient = new QueryClient({\n    defaultOptions: { queries: { retry: false } },\n  });\n\n  return function Wrapper({ children }: { children: ReactNode }) {\n    return (\n      <QueryClientProvider client={queryClient}>\n        <TransportProvider transport={transport}>\n          {children}\n        </TransportProvider>\n      </QueryClientProvider>\n    );\n  };\n}\n\ndescribe('Mesh Entity Hooks', () => {\n  let transport: ReturnType<typeof createMockTransport>;\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    transport = createMockTransport();\n  });\n\n  describe('useMeshEnabled', () => {\n    it('returns false when config has no mesh field', async () => {\n      transport.getConfig.mockResolvedValue({\n        version: '1.0.0',\n        port: 4242,\n        uptime: 0,\n        workingDirectory: '/test',\n        nodeVersion: 'v20.0.0',\n        claudeCliPath: null,\n      });\n\n      const { result } = renderHook(() => useMeshEnabled(), {\n        wrapper: createWrapper(transport),\n      });\n\n      // Initially false before data loads\n      expect(result.current).toBe(false);\n    });\n\n    it('returns true when mesh is enabled', async () => {\n      transport.getConfig.mockResolvedValue({\n        version: '1.0.0',\n        port: 4242,\n        uptime: 0,\n        workingDirectory: '/test',\n        nodeVersion: 'v20.0.0',\n        claudeCliPath: null,\n        mesh: { enabled: true },\n      });\n\n      const { result } = renderHook(() => useMeshEnabled(), {\n        wrapper: createWrapper(transport),\n      });\n\n      await waitFor(() => {\n        expect(result.current).toBe(true);\n      });\n    });\n  });\n\n  describe('useRegisteredAgents', () => {\n    it('does not fetch when disabled', () => {\n      renderHook(() => useRegisteredAgents(false), {\n        wrapper: createWrapper(transport),\n      });\n\n      expect(transport.listMeshAgents).not.toHaveBeenCalled();\n    });\n\n    it('fetches agents when enabled', async () => {\n      transport.listMeshAgents.mockResolvedValue({ agents: [{ id: 'a1', name: 'Bot' }] });\n\n      const { result } = renderHook(() => useRegisteredAgents(true), {\n        wrapper: createWrapper(transport),\n      });\n\n      await waitFor(() => {\n        expect(result.current.data?.agents).toHaveLength(1);\n      });\n    });\n  });\n\n  describe('useDiscoverAgents', () => {\n    it('calls discoverMeshAgents on mutate', async () => {\n      transport.discoverMeshAgents.mockResolvedValue({ candidates: [] });\n\n      const { result } = renderHook(() => useDiscoverAgents(), {\n        wrapper: createWrapper(transport),\n      });\n\n      result.current.mutate({ roots: ['/projects'] });\n\n      await waitFor(() => {\n        expect(transport.discoverMeshAgents).toHaveBeenCalledWith(['/projects'], undefined);\n      });\n    });\n  });\n\n  describe('useRegisterAgent', () => {\n    it('calls registerMeshAgent and invalidates agents query', async () => {\n      transport.registerMeshAgent.mockResolvedValue({ id: 'a1', name: 'Bot' });\n\n      const { result } = renderHook(() => useRegisterAgent(), {\n        wrapper: createWrapper(transport),\n      });\n\n      result.current.mutate({ path: '/projects/bot' });\n\n      await waitFor(() => {\n        expect(transport.registerMeshAgent).toHaveBeenCalled();\n      });\n    });\n  });\n\n  describe('useUnregisterAgent', () => {\n    it('calls unregisterMeshAgent', async () => {\n      const { result } = renderHook(() => useUnregisterAgent(), {\n        wrapper: createWrapper(transport),\n      });\n\n      result.current.mutate('agent-1');\n\n      await waitFor(() => {\n        expect(transport.unregisterMeshAgent).toHaveBeenCalledWith('agent-1');\n      });\n    });\n  });\n\n  describe('useDeniedAgents', () => {\n    it('does not fetch when disabled', () => {\n      renderHook(() => useDeniedAgents(false), {\n        wrapper: createWrapper(transport),\n      });\n\n      expect(transport.listDeniedMeshAgents).not.toHaveBeenCalled();\n    });\n\n    it('fetches denied list when enabled', async () => {\n      transport.listDeniedMeshAgents.mockResolvedValue({ denied: [{ path: '/bad' }] });\n\n      const { result } = renderHook(() => useDeniedAgents(true), {\n        wrapper: createWrapper(transport),\n      });\n\n      await waitFor(() => {\n        expect(result.current.data?.denied).toHaveLength(1);\n      });\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n\n- `useMeshEnabled` tests: returns false when config has no mesh, returns true when enabled\n- `useRegisteredAgents` tests: doesn't fetch when disabled, fetches when enabled\n- `useDiscoverAgents` test: calls transport on mutate\n- `useRegisterAgent` test: calls transport and triggers invalidation\n- `useUnregisterAgent` test: calls transport with agent ID\n- `useDeniedAgents` tests: doesn't fetch when disabled, fetches when enabled\n- All tests pass with `npx vitest run`",
      "activeForm": "Writing client entity hook tests for mesh",
      "size": "small",
      "priority": "medium",
      "dependencies": ["3.1"],
      "parallelWith": []
    },
    {
      "id": "4.1",
      "phase": 4,
      "phaseName": "Client Feature Layer",
      "subject": "[mesh-server-client-integration] [P4] Create MeshPanel with tabs and disabled state",
      "description": "Create the main MeshPanel feature component with 3 tabs (Discovery, Agents, Denied) and a disabled state when mesh is not enabled.\n\n## Files to Create\n\n### `apps/client/src/layers/features/mesh/ui/MeshPanel.tsx` (NEW)\n\nThe panel follows the same pattern as `RelayPanel.tsx` — rendered in a `ResponsiveDialog` from the sidebar, with a feature flag guard.\n\n```typescript\nimport { Tabs, TabsList, TabsTrigger, TabsContent } from '@/layers/shared/ui';\nimport { Network } from 'lucide-react';\nimport { useMeshEnabled } from '@/layers/entities/mesh';\nimport { DiscoveryTab } from './DiscoveryTab';\nimport { AgentsTab } from './AgentsTab';\nimport { DeniedTab } from './DeniedTab';\n\n/** Main Mesh panel with Discovery, Agents, and Denied tabs. */\nexport function MeshPanel() {\n  const meshEnabled = useMeshEnabled();\n\n  if (!meshEnabled) {\n    return (\n      <div className=\"flex flex-col items-center justify-center gap-3 p-8 text-center\">\n        <Network className=\"size-8 text-muted-foreground/50\" />\n        <div>\n          <p className=\"font-medium\">Mesh is not enabled</p>\n          <p className=\"mt-1 text-sm text-muted-foreground\">\n            Mesh provides agent discovery and registration. Start DorkOS with mesh enabled.\n          </p>\n        </div>\n        <code className=\"mt-2 rounded-md bg-muted px-3 py-1.5 font-mono text-sm\">\n          DORKOS_MESH_ENABLED=true dorkos\n        </code>\n      </div>\n    );\n  }\n\n  return (\n    <Tabs defaultValue=\"agents\" className=\"flex h-full flex-col\">\n      <TabsList className=\"mx-4 mt-3 shrink-0\">\n        <TabsTrigger value=\"discovery\">Discovery</TabsTrigger>\n        <TabsTrigger value=\"agents\">Agents</TabsTrigger>\n        <TabsTrigger value=\"denied\">Denied</TabsTrigger>\n      </TabsList>\n      <TabsContent value=\"discovery\" className=\"flex-1 overflow-y-auto p-4\">\n        <DiscoveryTab />\n      </TabsContent>\n      <TabsContent value=\"agents\" className=\"flex-1 overflow-y-auto p-4\">\n        <AgentsTab />\n      </TabsContent>\n      <TabsContent value=\"denied\" className=\"flex-1 overflow-y-auto p-4\">\n        <DeniedTab />\n      </TabsContent>\n    </Tabs>\n  );\n}\n```\n\n### `apps/client/src/layers/features/mesh/ui/DiscoveryTab.tsx` (NEW)\n\nContains the scan button with directory picker and renders candidate cards:\n\n```typescript\nimport { useState } from 'react';\nimport { DirectoryPicker } from '@/layers/shared/ui';\nimport { useDiscoverAgents, useRegisterAgent, useDenyAgent } from '@/layers/entities/mesh';\nimport { CandidateCard } from './CandidateCard';\nimport { Search, Loader2 } from 'lucide-react';\n\n/** Discovery tab — scan directories and review agent candidates. */\nexport function DiscoveryTab() {\n  const [scanRoot, setScanRoot] = useState<string>('');\n  const discover = useDiscoverAgents();\n  const register = useRegisterAgent();\n  const deny = useDenyAgent();\n\n  const handleScan = () => {\n    if (!scanRoot) return;\n    discover.mutate({ roots: [scanRoot] });\n  };\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex items-center gap-2\">\n        <DirectoryPicker\n          value={scanRoot}\n          onChange={setScanRoot}\n          className=\"flex-1\"\n        />\n        <button\n          onClick={handleScan}\n          disabled={!scanRoot || discover.isPending}\n          className=\"inline-flex items-center gap-1.5 rounded-md bg-primary px-3 py-2 text-sm font-medium text-primary-foreground hover:bg-primary/90 disabled:opacity-50\"\n        >\n          {discover.isPending ? (\n            <Loader2 className=\"size-4 animate-spin\" />\n          ) : (\n            <Search className=\"size-4\" />\n          )}\n          Scan\n        </button>\n      </div>\n\n      {discover.data?.candidates && discover.data.candidates.length === 0 && (\n        <p className=\"text-sm text-muted-foreground\">No agent candidates found.</p>\n      )}\n\n      <div className=\"space-y-3\">\n        {discover.data?.candidates?.map((candidate) => (\n          <CandidateCard\n            key={candidate.path}\n            candidate={candidate}\n            onRegister={(path) => register.mutate({ path })}\n            onDeny={(path, reason) => deny.mutate({ path, reason })}\n            isRegistering={register.isPending}\n            isDenying={deny.isPending}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n```\n\n### `apps/client/src/layers/features/mesh/ui/AgentsTab.tsx` (NEW)\n\nLists registered agents with a manual registration button:\n\n```typescript\nimport { useState } from 'react';\nimport { useMeshEnabled, useRegisteredAgents } from '@/layers/entities/mesh';\nimport { AgentCard } from './AgentCard';\nimport { RegisterAgentDialog } from './RegisterAgentDialog';\nimport { Plus, Loader2 } from 'lucide-react';\n\n/** Agents tab — list registered agents and add new ones. */\nexport function AgentsTab() {\n  const meshEnabled = useMeshEnabled();\n  const { data, isLoading } = useRegisteredAgents(meshEnabled);\n  const [registerOpen, setRegisterOpen] = useState(false);\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center p-8\">\n        <Loader2 className=\"size-6 animate-spin text-muted-foreground\" />\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex items-center justify-between\">\n        <p className=\"text-sm text-muted-foreground\">\n          {data?.agents.length ?? 0} registered agent{data?.agents.length !== 1 ? 's' : ''}\n        </p>\n        <button\n          onClick={() => setRegisterOpen(true)}\n          className=\"inline-flex items-center gap-1.5 rounded-md bg-primary px-3 py-2 text-sm font-medium text-primary-foreground hover:bg-primary/90\"\n        >\n          <Plus className=\"size-4\" />\n          Register Agent\n        </button>\n      </div>\n\n      <div className=\"space-y-3\">\n        {data?.agents.map((agent) => (\n          <AgentCard key={agent.id} agent={agent} />\n        ))}\n      </div>\n\n      {data?.agents.length === 0 && (\n        <p className=\"text-center text-sm text-muted-foreground\">\n          No agents registered yet. Use Discovery to find agents or register one manually.\n        </p>\n      )}\n\n      <RegisterAgentDialog open={registerOpen} onOpenChange={setRegisterOpen} />\n    </div>\n  );\n}\n```\n\n### `apps/client/src/layers/features/mesh/ui/DeniedTab.tsx` (NEW)\n\nLists denied paths with option to clear denials:\n\n```typescript\nimport { useMeshEnabled, useDeniedAgents } from '@/layers/entities/mesh';\nimport { useTransport } from '@/layers/shared/model';\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { X, Loader2 } from 'lucide-react';\n\n/** Denied tab — list denied paths and clear denials. */\nexport function DeniedTab() {\n  const meshEnabled = useMeshEnabled();\n  const { data, isLoading } = useDeniedAgents(meshEnabled);\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n\n  const clearDenial = useMutation({\n    mutationFn: (path: string) => transport.clearMeshDenial(path),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['mesh', 'denied'] });\n    },\n  });\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center p-8\">\n        <Loader2 className=\"size-6 animate-spin text-muted-foreground\" />\n      </div>\n    );\n  }\n\n  if (!data?.denied.length) {\n    return <p className=\"text-center text-sm text-muted-foreground\">No denied paths.</p>;\n  }\n\n  return (\n    <div className=\"space-y-2\">\n      {data.denied.map((denial) => (\n        <div\n          key={denial.path}\n          className=\"flex items-center justify-between rounded-lg border p-3\"\n        >\n          <div className=\"min-w-0 flex-1\">\n            <p className=\"truncate font-mono text-sm\">{denial.path}</p>\n            {denial.reason && (\n              <p className=\"mt-0.5 text-xs text-muted-foreground\">{denial.reason}</p>\n            )}\n          </div>\n          <button\n            onClick={() => clearDenial.mutate(denial.path)}\n            className=\"ml-2 rounded-md p-1 hover:bg-destructive/10\"\n            aria-label={`Clear denial for ${denial.path}`}\n          >\n            <X className=\"size-4 text-muted-foreground\" />\n          </button>\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n\n### `apps/client/src/layers/features/mesh/index.ts` (NEW)\n\n```typescript\n/**\n * Mesh feature — agent discovery and registry management UI.\n *\n * @module features/mesh\n */\nexport { MeshPanel } from './ui/MeshPanel';\n```\n\n## Acceptance Criteria\n\n- MeshPanel renders disabled state when mesh is not enabled, showing the enable instruction\n- MeshPanel renders 3 tabs (Discovery, Agents, Denied) when enabled\n- Default tab is \"agents\"\n- DiscoveryTab has a DirectoryPicker and Scan button\n- AgentsTab shows registered agents and a \"Register Agent\" button\n- DeniedTab shows denied paths with clear buttons\n- No FSD layer violations (features import from entities and shared only)\n- `npm run typecheck` passes",
      "activeForm": "Creating MeshPanel with tabs and disabled state",
      "size": "large",
      "priority": "high",
      "dependencies": ["3.1"],
      "parallelWith": []
    },
    {
      "id": "4.2",
      "phase": 4,
      "phaseName": "Client Feature Layer",
      "subject": "[mesh-server-client-integration] [P4] Create CandidateCard and AgentCard components",
      "description": "Create the card components for displaying discovery candidates and registered agents.\n\n## Files to Create\n\n### `apps/client/src/layers/features/mesh/ui/CandidateCard.tsx` (NEW)\n\nCard for a discovered candidate showing directory path, runtime badge, strategy badge, suggested name, and capabilities. Actions: Approve (register) and Deny (with optional reason).\n\n```typescript\nimport { useState } from 'react';\nimport { Badge } from '@/layers/shared/ui';\nimport { Check, Ban } from 'lucide-react';\nimport type { DiscoveryCandidate } from '@dorkos/shared/mesh-schemas';\n\ninterface CandidateCardProps {\n  candidate: DiscoveryCandidate;\n  onRegister: (path: string) => void;\n  onDeny: (path: string, reason?: string) => void;\n  isRegistering: boolean;\n  isDenying: boolean;\n}\n\n/** Card displaying a discovery candidate with approve/deny actions. */\nexport function CandidateCard({\n  candidate,\n  onRegister,\n  onDeny,\n  isRegistering,\n  isDenying,\n}: CandidateCardProps) {\n  const [showDenyInput, setShowDenyInput] = useState(false);\n  const [denyReason, setDenyReason] = useState('');\n\n  return (\n    <div className=\"rounded-lg border p-4 space-y-2\">\n      <div className=\"flex items-start justify-between gap-2\">\n        <div className=\"min-w-0 flex-1\">\n          <p className=\"font-medium\">{candidate.hints.suggestedName}</p>\n          <p className=\"truncate font-mono text-xs text-muted-foreground\">{candidate.path}</p>\n        </div>\n        <div className=\"flex shrink-0 gap-1.5\">\n          <Badge variant=\"outline\">{candidate.hints.detectedRuntime}</Badge>\n          <Badge variant=\"secondary\">{candidate.strategy}</Badge>\n        </div>\n      </div>\n\n      {candidate.hints.description && (\n        <p className=\"text-sm text-muted-foreground\">{candidate.hints.description}</p>\n      )}\n\n      {candidate.hints.inferredCapabilities && candidate.hints.inferredCapabilities.length > 0 && (\n        <div className=\"flex flex-wrap gap-1\">\n          {candidate.hints.inferredCapabilities.map((cap) => (\n            <Badge key={cap} variant=\"secondary\" className=\"text-xs\">\n              {cap}\n            </Badge>\n          ))}\n        </div>\n      )}\n\n      {showDenyInput && (\n        <div className=\"flex items-center gap-2\">\n          <input\n            type=\"text\"\n            value={denyReason}\n            onChange={(e) => setDenyReason(e.target.value)}\n            placeholder=\"Reason (optional)\"\n            className=\"flex-1 rounded-md border bg-transparent px-2 py-1 text-sm\"\n          />\n          <button\n            onClick={() => {\n              onDeny(candidate.path, denyReason || undefined);\n              setShowDenyInput(false);\n              setDenyReason('');\n            }}\n            disabled={isDenying}\n            className=\"rounded-md bg-destructive px-2 py-1 text-xs text-destructive-foreground hover:bg-destructive/90 disabled:opacity-50\"\n          >\n            Confirm Deny\n          </button>\n        </div>\n      )}\n\n      <div className=\"flex gap-2 pt-1\">\n        <button\n          onClick={() => onRegister(candidate.path)}\n          disabled={isRegistering}\n          className=\"inline-flex items-center gap-1 rounded-md bg-primary px-2.5 py-1.5 text-xs font-medium text-primary-foreground hover:bg-primary/90 disabled:opacity-50\"\n        >\n          <Check className=\"size-3.5\" />\n          Approve\n        </button>\n        <button\n          onClick={() => setShowDenyInput(!showDenyInput)}\n          disabled={isDenying}\n          className=\"inline-flex items-center gap-1 rounded-md border px-2.5 py-1.5 text-xs hover:bg-muted disabled:opacity-50\"\n        >\n          <Ban className=\"size-3.5\" />\n          Deny\n        </button>\n      </div>\n    </div>\n  );\n}\n```\n\n### `apps/client/src/layers/features/mesh/ui/AgentCard.tsx` (NEW)\n\nCard for a registered agent with expand/collapse detail, edit, and unregister actions:\n\n```typescript\nimport { useState } from 'react';\nimport { Badge } from '@/layers/shared/ui';\nimport { useUnregisterAgent, useUpdateAgent } from '@/layers/entities/mesh';\nimport { ChevronDown, ChevronRight, Pencil, Trash2 } from 'lucide-react';\nimport { cn } from '@/layers/shared/lib';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\ninterface AgentCardProps {\n  agent: AgentManifest;\n}\n\n/** Card displaying a registered agent with management actions. */\nexport function AgentCard({ agent }: AgentCardProps) {\n  const [expanded, setExpanded] = useState(false);\n  const [editing, setEditing] = useState(false);\n  const [editName, setEditName] = useState(agent.name);\n  const [editDesc, setEditDesc] = useState(agent.description);\n  const unregister = useUnregisterAgent();\n  const update = useUpdateAgent();\n\n  const handleSave = () => {\n    update.mutate(\n      { id: agent.id, updates: { name: editName, description: editDesc } },\n      {\n        onSuccess: () => setEditing(false),\n      }\n    );\n  };\n\n  const handleUnregister = () => {\n    if (window.confirm(`Unregister ${agent.name}?`)) {\n      unregister.mutate(agent.id);\n    }\n  };\n\n  return (\n    <div className=\"rounded-lg border\">\n      <button\n        onClick={() => setExpanded(!expanded)}\n        className=\"flex w-full items-center gap-2 p-3 text-left hover:bg-muted/50\"\n      >\n        {expanded ? <ChevronDown className=\"size-4\" /> : <ChevronRight className=\"size-4\" />}\n        <span className=\"flex-1 font-medium\">{agent.name}</span>\n        <Badge variant=\"outline\">{agent.runtime}</Badge>\n      </button>\n\n      {expanded && (\n        <div className=\"border-t px-3 pb-3 pt-2 space-y-2\">\n          {editing ? (\n            <div className=\"space-y-2\">\n              <input\n                type=\"text\"\n                value={editName}\n                onChange={(e) => setEditName(e.target.value)}\n                className=\"w-full rounded-md border bg-transparent px-2 py-1 text-sm\"\n                placeholder=\"Name\"\n              />\n              <input\n                type=\"text\"\n                value={editDesc}\n                onChange={(e) => setEditDesc(e.target.value)}\n                className=\"w-full rounded-md border bg-transparent px-2 py-1 text-sm\"\n                placeholder=\"Description\"\n              />\n              <div className=\"flex gap-2\">\n                <button\n                  onClick={handleSave}\n                  disabled={update.isPending}\n                  className=\"rounded-md bg-primary px-2 py-1 text-xs text-primary-foreground hover:bg-primary/90 disabled:opacity-50\"\n                >\n                  Save\n                </button>\n                <button\n                  onClick={() => setEditing(false)}\n                  className=\"rounded-md border px-2 py-1 text-xs hover:bg-muted\"\n                >\n                  Cancel\n                </button>\n              </div>\n            </div>\n          ) : (\n            <>\n              {agent.description && (\n                <p className=\"text-sm text-muted-foreground\">{agent.description}</p>\n              )}\n              {agent.capabilities.length > 0 && (\n                <div className=\"flex flex-wrap gap-1\">\n                  {agent.capabilities.map((cap) => (\n                    <Badge key={cap} variant=\"secondary\" className=\"text-xs\">\n                      {cap}\n                    </Badge>\n                  ))}\n                </div>\n              )}\n              <div className=\"flex gap-2 pt-1\">\n                <button\n                  onClick={() => setEditing(true)}\n                  className=\"inline-flex items-center gap-1 rounded-md border px-2 py-1 text-xs hover:bg-muted\"\n                >\n                  <Pencil className=\"size-3\" />\n                  Edit\n                </button>\n                <button\n                  onClick={handleUnregister}\n                  disabled={unregister.isPending}\n                  className={cn(\n                    'inline-flex items-center gap-1 rounded-md border px-2 py-1 text-xs',\n                    'hover:bg-destructive/10 hover:text-destructive disabled:opacity-50'\n                  )}\n                >\n                  <Trash2 className=\"size-3\" />\n                  Unregister\n                </button>\n              </div>\n            </>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n## Acceptance Criteria\n\n- CandidateCard displays: suggested name, path, runtime badge, strategy badge, capabilities, description\n- CandidateCard has Approve and Deny buttons\n- Deny button shows optional reason input before confirming\n- AgentCard displays: name, runtime badge, capabilities as badges, description\n- AgentCard expand/collapse shows details\n- AgentCard has Edit (inline name/description editing) and Unregister (with confirm) actions\n- Both components use entity hooks (`useRegisterAgent`, `useUnregisterAgent`, `useUpdateAgent`, `useDenyAgent`)\n- No FSD layer violations\n- `npm run typecheck` passes",
      "activeForm": "Creating CandidateCard and AgentCard components",
      "size": "medium",
      "priority": "high",
      "dependencies": ["3.1"],
      "parallelWith": ["4.1"]
    },
    {
      "id": "4.3",
      "phase": 4,
      "phaseName": "Client Feature Layer",
      "subject": "[mesh-server-client-integration] [P4] Create RegisterAgentDialog for manual registration",
      "description": "Create a manual agent registration dialog using the `ResponsiveDialog` wrapper pattern from Pulse's `CreateScheduleDialog`.\n\n## File to Create\n\n### `apps/client/src/layers/features/mesh/ui/RegisterAgentDialog.tsx` (NEW)\n\n```typescript\nimport { useState } from 'react';\nimport {\n  ResponsiveDialog,\n  ResponsiveDialogContent,\n  ResponsiveDialogHeader,\n  ResponsiveDialogTitle,\n  ResponsiveDialogDescription,\n  DirectoryPicker,\n} from '@/layers/shared/ui';\nimport { useRegisterAgent } from '@/layers/entities/mesh';\nimport { X, Plus } from 'lucide-react';\nimport { Badge } from '@/layers/shared/ui';\n\ninterface RegisterAgentDialogProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n}\n\n/** Dialog for manually registering an agent from a filesystem path. */\nexport function RegisterAgentDialog({ open, onOpenChange }: RegisterAgentDialogProps) {\n  const [agentPath, setAgentPath] = useState('');\n  const [name, setName] = useState('');\n  const [description, setDescription] = useState('');\n  const [runtime, setRuntime] = useState<string>('claude-code');\n  const [capInput, setCapInput] = useState('');\n  const [capabilities, setCapabilities] = useState<string[]>([]);\n  const register = useRegisterAgent();\n\n  const handleAddCapability = () => {\n    const trimmed = capInput.trim();\n    if (trimmed && !capabilities.includes(trimmed)) {\n      setCapabilities([...capabilities, trimmed]);\n      setCapInput('');\n    }\n  };\n\n  const handleRemoveCapability = (cap: string) => {\n    setCapabilities(capabilities.filter((c) => c !== cap));\n  };\n\n  const handleSubmit = () => {\n    if (!agentPath) return;\n    const overrides: Record<string, unknown> = {};\n    if (name) overrides.name = name;\n    if (description) overrides.description = description;\n    if (runtime) overrides.runtime = runtime;\n    if (capabilities.length > 0) overrides.capabilities = capabilities;\n\n    register.mutate(\n      {\n        path: agentPath,\n        overrides: Object.keys(overrides).length > 0 ? overrides as any : undefined,\n        approver: 'user',\n      },\n      {\n        onSuccess: () => {\n          onOpenChange(false);\n          resetForm();\n        },\n      }\n    );\n  };\n\n  const resetForm = () => {\n    setAgentPath('');\n    setName('');\n    setDescription('');\n    setRuntime('claude-code');\n    setCapabilities([]);\n    setCapInput('');\n  };\n\n  return (\n    <ResponsiveDialog open={open} onOpenChange={onOpenChange}>\n      <ResponsiveDialogContent>\n        <ResponsiveDialogHeader>\n          <ResponsiveDialogTitle>Register Agent</ResponsiveDialogTitle>\n          <ResponsiveDialogDescription>\n            Register an agent from a directory containing agent configuration.\n          </ResponsiveDialogDescription>\n        </ResponsiveDialogHeader>\n\n        <div className=\"space-y-4 p-4\">\n          {/* Path picker */}\n          <div className=\"space-y-1.5\">\n            <label className=\"text-sm font-medium\">Agent Directory</label>\n            <DirectoryPicker value={agentPath} onChange={setAgentPath} />\n          </div>\n\n          {/* Name */}\n          <div className=\"space-y-1.5\">\n            <label className=\"text-sm font-medium\">Name (optional)</label>\n            <input\n              type=\"text\"\n              value={name}\n              onChange={(e) => setName(e.target.value)}\n              placeholder=\"Auto-detected from directory\"\n              className=\"w-full rounded-md border bg-transparent px-3 py-2 text-sm\"\n            />\n          </div>\n\n          {/* Description */}\n          <div className=\"space-y-1.5\">\n            <label className=\"text-sm font-medium\">Description (optional)</label>\n            <input\n              type=\"text\"\n              value={description}\n              onChange={(e) => setDescription(e.target.value)}\n              placeholder=\"What does this agent do?\"\n              className=\"w-full rounded-md border bg-transparent px-3 py-2 text-sm\"\n            />\n          </div>\n\n          {/* Runtime select */}\n          <div className=\"space-y-1.5\">\n            <label className=\"text-sm font-medium\">Runtime</label>\n            <select\n              value={runtime}\n              onChange={(e) => setRuntime(e.target.value)}\n              className=\"w-full rounded-md border bg-transparent px-3 py-2 text-sm\"\n            >\n              <option value=\"claude-code\">Claude Code</option>\n              <option value=\"cursor\">Cursor</option>\n              <option value=\"codex\">Codex</option>\n              <option value=\"other\">Other</option>\n            </select>\n          </div>\n\n          {/* Capabilities tag input */}\n          <div className=\"space-y-1.5\">\n            <label className=\"text-sm font-medium\">Capabilities</label>\n            <div className=\"flex gap-2\">\n              <input\n                type=\"text\"\n                value={capInput}\n                onChange={(e) => setCapInput(e.target.value)}\n                onKeyDown={(e) => {\n                  if (e.key === 'Enter') {\n                    e.preventDefault();\n                    handleAddCapability();\n                  }\n                }}\n                placeholder=\"Add capability...\"\n                className=\"flex-1 rounded-md border bg-transparent px-3 py-2 text-sm\"\n              />\n              <button\n                type=\"button\"\n                onClick={handleAddCapability}\n                className=\"rounded-md border px-2 py-2 hover:bg-muted\"\n                aria-label=\"Add capability\"\n              >\n                <Plus className=\"size-4\" />\n              </button>\n            </div>\n            {capabilities.length > 0 && (\n              <div className=\"flex flex-wrap gap-1 pt-1\">\n                {capabilities.map((cap) => (\n                  <Badge key={cap} variant=\"secondary\" className=\"gap-1 pr-1\">\n                    {cap}\n                    <button\n                      onClick={() => handleRemoveCapability(cap)}\n                      className=\"rounded-full hover:bg-muted\"\n                      aria-label={`Remove ${cap}`}\n                    >\n                      <X className=\"size-3\" />\n                    </button>\n                  </Badge>\n                ))}\n              </div>\n            )}\n          </div>\n\n          {/* Submit */}\n          <button\n            onClick={handleSubmit}\n            disabled={!agentPath || register.isPending}\n            className=\"w-full rounded-md bg-primary py-2 text-sm font-medium text-primary-foreground hover:bg-primary/90 disabled:opacity-50\"\n          >\n            {register.isPending ? 'Registering...' : 'Register Agent'}\n          </button>\n        </div>\n      </ResponsiveDialogContent>\n    </ResponsiveDialog>\n  );\n}\n```\n\nKey implementation details:\n- Uses `DirectoryPicker` from `shared/ui` for path selection (same component reused by the working directory picker)\n- Capabilities use a controlled `Input` + `Badge` pattern with no new dependencies (Enter key and + button to add, X button on badges to remove)\n- Runtime uses a native `<select>` with the 4 runtime options from `AgentRuntimeSchema`\n- Form resets on successful submission\n- Submit calls `registerMeshAgent` via the `useRegisterAgent` hook\n\n## Acceptance Criteria\n\n- Dialog opens/closes via `open`/`onOpenChange` props\n- DirectoryPicker allows selecting an agent directory path\n- Name and description are optional text inputs\n- Runtime dropdown has 4 options: claude-code, cursor, codex, other\n- Capabilities can be added via Enter key or + button, removed via X\n- Submit is disabled when no path is selected or when registering\n- Dialog closes and form resets on successful registration\n- No FSD layer violations\n- `npm run typecheck` passes",
      "activeForm": "Creating RegisterAgentDialog for manual registration",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["3.1"],
      "parallelWith": ["4.1", "4.2"]
    },
    {
      "id": "4.4",
      "phase": 4,
      "phaseName": "Client Feature Layer",
      "subject": "[mesh-server-client-integration] [P4] Mount MeshPanel in sidebar alongside Pulse and Relay",
      "description": "Add the Mesh panel trigger button and dialog to the SessionSidebar, following the same pattern as Pulse and Relay panels.\n\n## File to Modify\n\n### `apps/client/src/layers/features/session-list/ui/SessionSidebar.tsx`\n\n1. **Add imports**:\n\n```typescript\nimport { useMeshEnabled } from '@/layers/entities/mesh';\nimport { MeshPanel } from '@/layers/features/mesh';\nimport { Network } from 'lucide-react'; // Add Network to the lucide-react import\n```\n\n2. **Add state and hook** inside the `SessionSidebar` component, after `relayEnabled`:\n\n```typescript\nconst [meshOpen, setMeshOpen] = useState(false);\nconst meshEnabled = useMeshEnabled();\n```\n\n3. **Add Mesh button** in the footer toolbar area, alongside the Relay and Pulse buttons. Look for the section with the `Route` icon button (Relay) and `HeartPulse` icon button (Pulse), and add a Mesh button before or after them:\n\n```typescript\n<Tooltip>\n  <TooltipTrigger asChild>\n    <button\n      onClick={() => setMeshOpen(true)}\n      className={cn(\n        'rounded-md p-1 transition-colors duration-150 max-md:p-2',\n        meshEnabled\n          ? 'hover:bg-accent text-foreground'\n          : 'text-muted-foreground/50 hover:bg-accent/50'\n      )}\n      aria-label=\"Mesh discovery\"\n    >\n      <Network className=\"size-(--size-icon-sm)\" />\n    </button>\n  </TooltipTrigger>\n  {!meshEnabled && (\n    <TooltipContent>Mesh is not enabled</TooltipContent>\n  )}\n</Tooltip>\n```\n\n4. **Add MeshPanel dialog** alongside the existing PulsePanel and RelayPanel `ResponsiveDialog` instances at the bottom of the component:\n\n```typescript\n<ResponsiveDialog open={meshOpen} onOpenChange={setMeshOpen}>\n  <ResponsiveDialogContent className=\"max-h-[80vh] sm:max-w-2xl\">\n    <ResponsiveDialogHeader>\n      <ResponsiveDialogTitle>Mesh</ResponsiveDialogTitle>\n      <ResponsiveDialogDescription>\n        Discover and manage agents in your filesystem.\n      </ResponsiveDialogDescription>\n    </ResponsiveDialogHeader>\n    <MeshPanel />\n  </ResponsiveDialogContent>\n</ResponsiveDialog>\n```\n\nNote: The exact placement of the button and dialog should match the existing pattern used for Relay and Pulse. Look at how `relayOpen`/`setRelayOpen` and `pulseOpen`/`setPulseOpen` are used and follow the same pattern.\n\n## Acceptance Criteria\n\n- Network icon button appears in the sidebar footer toolbar\n- Button has dimmed styling when mesh is disabled, full styling when enabled\n- Tooltip shows \"Mesh is not enabled\" when disabled\n- Clicking the button opens the MeshPanel in a ResponsiveDialog\n- Dialog has title \"Mesh\" and description \"Discover and manage agents in your filesystem\"\n- MeshPanel renders inside the dialog (showing disabled state or tabs depending on feature flag)\n- No FSD layer violations\n- `npm run typecheck` passes\n- `npm run build` passes",
      "activeForm": "Mounting MeshPanel in sidebar alongside Pulse and Relay",
      "size": "small",
      "priority": "high",
      "dependencies": ["4.1"],
      "parallelWith": []
    },
    {
      "id": "4.5",
      "phase": 4,
      "phaseName": "Client Feature Layer",
      "subject": "[mesh-server-client-integration] [P4] Add MeshPanel component tests",
      "description": "Write component tests for the MeshPanel verifying disabled state and tab rendering.\n\n## File to Create\n\n### `apps/client/src/layers/features/mesh/__tests__/MeshPanel.test.tsx` (NEW)\n\n```typescript\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { TransportProvider } from '@/layers/shared/model';\nimport { createMockTransport } from '@dorkos/test-utils';\nimport { MeshPanel } from '../index';\nimport type { Transport } from '@dorkos/shared/transport';\nimport type { ReactNode } from 'react';\n\n// Mock motion to render plain elements\nvi.mock('motion/react', () => ({\n  motion: {\n    div: ({ children, ...props }: any) => <div {...props}>{children}</div>,\n  },\n  AnimatePresence: ({ children }: any) => children,\n}));\n\nfunction createWrapper(transport: Transport) {\n  const queryClient = new QueryClient({\n    defaultOptions: { queries: { retry: false } },\n  });\n\n  return function Wrapper({ children }: { children: ReactNode }) {\n    return (\n      <QueryClientProvider client={queryClient}>\n        <TransportProvider transport={transport}>\n          {children}\n        </TransportProvider>\n      </QueryClientProvider>\n    );\n  };\n}\n\ndescribe('MeshPanel', () => {\n  let transport: ReturnType<typeof createMockTransport>;\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('renders disabled state when mesh is not enabled', async () => {\n    transport = createMockTransport({\n      getConfig: vi.fn().mockResolvedValue({\n        version: '1.0.0',\n        port: 4242,\n        uptime: 0,\n        workingDirectory: '/test',\n        nodeVersion: 'v20.0.0',\n        claudeCliPath: null,\n        mesh: { enabled: false },\n      }),\n    });\n\n    render(<MeshPanel />, { wrapper: createWrapper(transport) });\n\n    // Should show disabled message\n    expect(await screen.findByText('Mesh is not enabled')).toBeInTheDocument();\n    expect(screen.getByText(/DORKOS_MESH_ENABLED=true/)).toBeInTheDocument();\n  });\n\n  it('renders tabs when mesh is enabled', async () => {\n    transport = createMockTransport({\n      getConfig: vi.fn().mockResolvedValue({\n        version: '1.0.0',\n        port: 4242,\n        uptime: 0,\n        workingDirectory: '/test',\n        nodeVersion: 'v20.0.0',\n        claudeCliPath: null,\n        mesh: { enabled: true },\n      }),\n    });\n\n    render(<MeshPanel />, { wrapper: createWrapper(transport) });\n\n    // Should show tabs\n    expect(await screen.findByRole('tab', { name: /discovery/i })).toBeInTheDocument();\n    expect(screen.getByRole('tab', { name: /agents/i })).toBeInTheDocument();\n    expect(screen.getByRole('tab', { name: /denied/i })).toBeInTheDocument();\n  });\n\n  it('shows agents tab content by default', async () => {\n    transport = createMockTransport({\n      getConfig: vi.fn().mockResolvedValue({\n        version: '1.0.0',\n        port: 4242,\n        uptime: 0,\n        workingDirectory: '/test',\n        nodeVersion: 'v20.0.0',\n        claudeCliPath: null,\n        mesh: { enabled: true },\n      }),\n      listMeshAgents: vi.fn().mockResolvedValue({ agents: [] }),\n    });\n\n    render(<MeshPanel />, { wrapper: createWrapper(transport) });\n\n    // The agents tab should be selected by default\n    const agentsTab = await screen.findByRole('tab', { name: /agents/i });\n    expect(agentsTab).toHaveAttribute('aria-selected', 'true');\n  });\n});\n```\n\n## Acceptance Criteria\n\n- Test: renders disabled state when mesh is not enabled (shows message and env var instruction)\n- Test: renders all 3 tabs when mesh is enabled\n- Test: agents tab is selected by default\n- All tests pass with `npx vitest run`\n- Tests use mock transport and QueryClient with retry disabled",
      "activeForm": "Writing MeshPanel component tests",
      "size": "small",
      "priority": "medium",
      "dependencies": ["4.1"],
      "parallelWith": ["4.4"]
    },
    {
      "id": "5.1",
      "phase": 5,
      "phaseName": "Documentation & Polish",
      "subject": "[mesh-server-client-integration] [P5] Update CLAUDE.md with Mesh subsystem documentation",
      "description": "Update CLAUDE.md to document the Mesh subsystem integration across server, client, and shared packages.\n\n## File to Modify\n\n### `CLAUDE.md`\n\nMake the following updates:\n\n1. **Route groups section** (under Server description): Add `routes/mesh.ts` to the list of route groups:\n\n```\n- **`routes/mesh.ts`** - Mesh agent discovery and registry (POST discover, POST/GET/PATCH/DELETE agents, POST deny, GET/DELETE denied). Feature-flag guarded via `mesh-state.ts`\n```\n\n2. **Services section**: Add mesh-state to the service list:\n\n```\n- **`services/mesh/mesh-state.ts`** - Feature flag holder for Mesh subsystem. Exports `setMeshEnabled()`/`isMeshEnabled()`. Same pattern as `pulse-state.ts` and `relay-state.ts`.\n```\n\n3. **MCP tool server description**: Add meshCore to the McpToolDeps listing and add the mesh tools to the tool list:\n\n```\nMesh tools: `mesh_discover`, `mesh_register`, `mesh_list`, `mesh_deny`, `mesh_unregister`.\n```\n\n4. **Client FSD layers table**: Add the mesh entity and feature:\n\n```\n| `entities/mesh/`      | useMeshEnabled, useRegisteredAgents, useDiscoverAgents, useRegisterAgent, useDenyAgent, useUnregisterAgent, useUpdateAgent, useDeniedAgents | Mesh discovery domain hooks |\n| `features/mesh/`      | MeshPanel, CandidateCard, AgentCard, RegisterAgentDialog, DiscoveryTab  | Mesh agent discovery UI     |\n```\n\n5. **Transport interface section**: Note that Mesh methods have been added to the Transport interface.\n\n6. **Shared package description**: Note `mesh-schemas.ts` now includes HTTP request/response schemas.\n\n## Acceptance Criteria\n\n- All new server routes, services, MCP tools, and client layers are documented\n- CLAUDE.md accurately reflects the Mesh subsystem in all relevant sections\n- No existing documentation is removed or broken",
      "activeForm": "Updating CLAUDE.md with Mesh subsystem documentation",
      "size": "small",
      "priority": "medium",
      "dependencies": ["4.4"],
      "parallelWith": ["5.2"]
    },
    {
      "id": "5.2",
      "phase": 5,
      "phaseName": "Documentation & Polish",
      "subject": "[mesh-server-client-integration] [P5] Register Mesh endpoints in OpenAPI registry",
      "description": "Register all Mesh HTTP endpoints in the OpenAPI registry for Scalar API docs at `/api/docs`.\n\n## File to Modify\n\n### `apps/server/src/services/core/openapi-registry.ts`\n\nAdd Mesh endpoint registrations following the same pattern as existing Pulse and Relay endpoint registrations. Each endpoint should reference the Zod schemas from `@dorkos/shared/mesh-schemas` for request/response documentation.\n\nEndpoints to register:\n\n1. `POST /api/mesh/discover` - Request: `DiscoverRequestSchema`, Response: `{ candidates: DiscoveryCandidate[] }`\n2. `POST /api/mesh/agents` - Request: `RegisterAgentRequestSchema`, Response: `AgentManifestSchema` (201)\n3. `GET /api/mesh/agents` - Query: `AgentListQuerySchema`, Response: `{ agents: AgentManifest[] }`\n4. `GET /api/mesh/agents/{id}` - Response: `AgentManifestSchema`\n5. `PATCH /api/mesh/agents/{id}` - Request: `UpdateAgentRequestSchema`, Response: `AgentManifestSchema`\n6. `DELETE /api/mesh/agents/{id}` - Response: `{ success: boolean }`\n7. `POST /api/mesh/deny` - Request: `DenyRequestSchema`, Response: `{ success: boolean }`\n8. `GET /api/mesh/denied` - Response: `{ denied: DenialRecord[] }`\n9. `DELETE /api/mesh/denied/{encodedPath}` - Response: `{ success: boolean }`\n\nAll endpoints should be tagged with `'Mesh'` for grouping in the Scalar docs UI.\n\nAfter adding the registrations, regenerate the OpenAPI spec:\n```bash\nnpm run docs:export-api\n```\n\n## Acceptance Criteria\n\n- All 9 Mesh endpoints appear in the OpenAPI spec\n- Endpoints are tagged as \"Mesh\" for grouped display\n- Request/response schemas reference the Zod schemas from mesh-schemas.ts\n- `/api/docs` (Scalar UI) shows the Mesh endpoints when the server is running\n- `npm run docs:export-api` generates the updated spec without errors",
      "activeForm": "Registering Mesh endpoints in OpenAPI registry",
      "size": "small",
      "priority": "low",
      "dependencies": ["1.3"],
      "parallelWith": ["5.1"]
    }
  ]
}
