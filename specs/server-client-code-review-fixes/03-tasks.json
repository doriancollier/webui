{
  "spec": "specs/server-client-code-review-fixes/02-specification.md",
  "slug": "server-client-code-review-fixes",
  "generatedAt": "2026-02-28T22:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Server Fixes",
      "subject": "[server-client-code-review-fixes] [P1] Fix double lock release race condition in sessions.ts",
      "description": "## S1: Double Lock Release Race Condition\n\n**File:** `apps/server/src/routes/sessions.ts`\n\n**Problem:** In the POST `/api/sessions/:id/messages` handler (line 194), the legacy SSE path registers `res.on('close')` (line 234) to release the lock AND the `finally` block (line 261) also releases the lock. Both fire on normal completion. If a new client acquires the lock between the two calls, the second release deletes the wrong client's lock.\n\n**Current code (lines 220-264):**\n```typescript\n// Relay path\nif (isRelayEnabled() && relayCore) {\n  try {\n    const receipt = await publishViaRelay(relayCore, sessionId, clientId, content, cwd);\n    return res.status(202).json(receipt);\n  } catch (err) {\n    const message = err instanceof Error ? err.message : 'Relay publish failed';\n    return res.status(500).json({ error: message });\n  } finally {\n    agentManager.releaseLock(sessionId, clientId);\n  }\n}\n\n// Legacy path\nres.on('close', () => {\n  agentManager.releaseLock(sessionId, clientId);\n});\n\n// ...\nfinally {\n  agentManager.releaseLock(sessionId, clientId);\n  endSSEStream(res);\n}\n```\n\n**Fix:** Create a `releaseLockOnce` closure with a boolean guard before both the relay and legacy branches. Replace all three `agentManager.releaseLock(sessionId, clientId)` calls with `releaseLockOnce()`.\n\n**Replacement code — insert after the lock acquisition block (after line 216), before the relay path check:**\n```typescript\nlet lockReleased = false;\nconst releaseLockOnce = () => {\n  if (!lockReleased) {\n    lockReleased = true;\n    agentManager.releaseLock(sessionId, clientId);\n  }\n};\n```\n\n**Then replace all three lock release call sites:**\n\n1. Relay path `finally` block (line 228): Replace `agentManager.releaseLock(sessionId, clientId);` with `releaseLockOnce();`\n\n2. Legacy `res.on('close')` (line 235): Replace `agentManager.releaseLock(sessionId, clientId);` with `releaseLockOnce();`\n\n3. Legacy `finally` block (line 262): Replace `agentManager.releaseLock(sessionId, clientId);` with `releaseLockOnce();`\n\n**Acceptance criteria:**\n- The `releaseLockOnce` function is idempotent — calling it multiple times only releases the lock once\n- Both the relay and legacy paths use the same `releaseLockOnce` closure\n- No behavior change for the relay path (still releases in `finally`)\n- The legacy path's `res.on('close')` and `finally` both call `releaseLockOnce` but only the first one actually releases\n- Existing tests (if any) continue to pass\n- `pnpm typecheck` passes",
      "activeForm": "Fixing double lock release race condition in sessions.ts",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.2", "1.3", "1.4"]
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Server Fixes",
      "subject": "[server-client-code-review-fixes] [P1] Fix inFlight promise permanently poisoned on failure in binding-router.ts",
      "description": "## S2: inFlight Promise Permanently Poisoned on Failure\n\n**File:** `apps/server/src/services/relay/binding-router.ts`\n\n**Problem:** In the `getOrCreateSession` method (line 163), the `inFlight.delete(key)` call (line 174) is inside the success path of the async IIFE. If `createNewSession()` throws, the rejected promise remains in `inFlight` permanently, blocking all future session creation attempts for that key.\n\n**Current code (lines 171-178):**\n```typescript\nconst promise = (async () => {\n  const sessionId = await this.createNewSession(binding);\n  this.sessionMap.set(key, sessionId);\n  this.inFlight.delete(key);\n  this.evictOldestSessions();\n  await this.saveSessionMap();\n  return sessionId;\n})();\n```\n\n**Fix:** Move `this.inFlight.delete(key)` into a `finally` block so it always runs, whether the async IIFE succeeds or fails.\n\n**Replacement code:**\n```typescript\nconst promise = (async () => {\n  try {\n    const sessionId = await this.createNewSession(binding);\n    this.sessionMap.set(key, sessionId);\n    this.evictOldestSessions();\n    await this.saveSessionMap();\n    return sessionId;\n  } finally {\n    this.inFlight.delete(key);\n  }\n})();\n```\n\n**Implementation steps:**\n1. Open `apps/server/src/services/relay/binding-router.ts`\n2. Find the `getOrCreateSession` method (line 163)\n3. Replace the async IIFE body (lines 171-178) with the try/finally version above\n4. The outer code (`this.inFlight.set(key, promise)` and `return promise`) remains unchanged\n\n**Acceptance criteria:**\n- When `createNewSession()` throws, the key is removed from `inFlight` so subsequent calls retry session creation\n- When `createNewSession()` succeeds, behavior is identical to before (session mapped, eviction checked, map saved)\n- The promise returned to callers still rejects if `createNewSession()` throws (the `finally` does not swallow the error)\n- `pnpm typecheck` passes",
      "activeForm": "Fixing inFlight promise cleanup in binding-router.ts",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1", "1.3", "1.4"]
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Server Fixes",
      "subject": "[server-client-code-review-fixes] [P1] Restrict CORS from wildcard to localhost origins in app.ts",
      "description": "## S3: CORS Wildcard on Local Server\n\n**Files:**\n- `apps/server/src/app.ts` (primary)\n- `turbo.json` (add env var)\n\n**Problem:** `app.use(cors())` on line 26 of `app.ts` uses no options, defaulting to `Access-Control-Allow-Origin: *`. This allows any website to make cross-origin requests to the DorkOS server, enabling cross-origin reads of session data from arbitrary web pages.\n\n**Current code (line 26):**\n```typescript\napp.use(cors());\n```\n\n**Fix:** Add a `buildCorsOrigin()` helper function that constructs an origin allowlist. Default to localhost origins on common DorkOS ports. Support override via `DORKOS_CORS_ORIGIN` env var. Also add a dynamic middleware for tunnel URL support.\n\n**Implementation steps:**\n\n1. In `apps/server/src/app.ts`, add this function before `createApp()`:\n```typescript\nfunction buildCorsOrigin(): cors.CorsOptions['origin'] {\n  const envOrigin = process.env.DORKOS_CORS_ORIGIN;\n\n  // Explicit wildcard opt-in\n  if (envOrigin === '*') return '*';\n\n  // User-specified origins (comma-separated)\n  if (envOrigin) {\n    return envOrigin.split(',').map((o) => o.trim());\n  }\n\n  // Default: localhost on common DorkOS ports\n  const port = process.env.DORKOS_PORT || '4242';\n  const vitePort = process.env.VITE_PORT || '4241';\n  return [\n    `http://localhost:${port}`,\n    `http://localhost:${vitePort}`,\n    `http://127.0.0.1:${port}`,\n    `http://127.0.0.1:${vitePort}`,\n  ];\n}\n```\n\n2. Replace `app.use(cors());` with:\n```typescript\napp.use(cors({ origin: buildCorsOrigin() }));\n```\n\n3. Add a dynamic middleware after the cors middleware for tunnel URL support:\n```typescript\napp.use((req, res, next) => {\n  const tunnelUrl = req.app.locals.tunnelUrl as string | undefined;\n  if (tunnelUrl) {\n    const origin = req.headers.origin;\n    if (origin && tunnelUrl.startsWith(origin)) {\n      res.setHeader('Access-Control-Allow-Origin', origin);\n    }\n  }\n  next();\n});\n```\n\n4. In `turbo.json`, add `\"DORKOS_CORS_ORIGIN\"` to the `globalPassThroughEnv` array (alphabetical order, after `\"DORKOS_BOUNDARY\"`).\n\n**Acceptance criteria:**\n- Default behavior (no env var): Only `http://localhost:{DORKOS_PORT}`, `http://localhost:{VITE_PORT}`, and their `127.0.0.1` equivalents are allowed\n- `DORKOS_CORS_ORIGIN=*` explicitly opts into wildcard behavior\n- `DORKOS_CORS_ORIGIN=https://example.com,https://other.com` allows custom origins\n- When tunnel is active, the tunnel origin is dynamically allowed via the middleware\n- The `DORKOS_CORS_ORIGIN` env var is declared in `turbo.json` `globalPassThroughEnv` so Turbo passes it through\n- `pnpm typecheck` passes\n- Existing dev workflow (`pnpm dev`) works without setting any new env vars (defaults cover localhost)",
      "activeForm": "Restricting CORS from wildcard to localhost in app.ts",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1", "1.2", "1.4"]
    },
    {
      "id": "1.4",
      "phase": 1,
      "phaseName": "Server Fixes",
      "subject": "[server-client-code-review-fixes] [P1] Validate relay SSE subscription patterns in relay.ts",
      "description": "## S4: Unvalidated Relay Subscription Pattern\n\n**File:** `apps/server/src/routes/relay.ts`\n\n**Problem:** The GET `/stream` handler (line 306) accepts an arbitrary `subject` query param and passes it directly to `relayCore.subscribe()` with no validation. The default is `'>'` (global wildcard), which allows clients to subscribe to all relay traffic including inter-agent messages. This implements the unaddressed consequence from ADR 0018: \"Pattern validation must happen server-side to prevent invalid subscriptions.\"\n\n**Current code (line 307):**\n```typescript\nconst pattern = (req.query.subject as string) || '>';\n```\n\n**Fix:** Add a pattern validation function with an allowlist of prefixes, reject invalid patterns with 400, and change the default from `'>'` to `'relay.human.console.>'`.\n\n**Implementation steps:**\n\n1. At the top of the `createRelayRouter` function (or above it), add:\n```typescript\nconst ALLOWED_PREFIXES = [\n  'relay.human.console.',\n  'relay.system.',\n  'relay.signal.',\n];\n\nfunction validateSubscriptionPattern(pattern: string): boolean {\n  // Block the global wildcard\n  if (pattern === '>') return false;\n\n  // Allow any pattern that starts with an allowed prefix\n  return ALLOWED_PREFIXES.some((prefix) => pattern.startsWith(prefix));\n}\n```\n\n2. In the GET `/stream` handler (line 306-346), change the pattern assignment and add validation:\n```typescript\nrouter.get('/stream', (req, res) => {\n  const pattern = (req.query.subject as string) || 'relay.human.console.>';\n\n  if (!validateSubscriptionPattern(pattern)) {\n    return res.status(400).json({\n      error: 'Invalid subscription pattern',\n      allowedPrefixes: ALLOWED_PREFIXES,\n    });\n  }\n\n  initSSEStream(res);\n  // ... rest unchanged\n});\n```\n\n**Key changes:**\n- Default pattern changed from `'>'` to `'relay.human.console.>'`\n- Pattern `'>'` (global wildcard) is explicitly blocked\n- Only patterns starting with `relay.human.console.`, `relay.system.`, or `relay.signal.` are allowed\n- Invalid patterns return 400 with the list of allowed prefixes\n- The `ALLOWED_PREFIXES` constant and `validateSubscriptionPattern` function are defined at module scope (or inside `createRelayRouter`) for clarity\n\n**Acceptance criteria:**\n- `GET /stream` with no query param uses `relay.human.console.>` (safe default)\n- `GET /stream?subject=>` returns 400 with `{ error: 'Invalid subscription pattern', allowedPrefixes: [...] }`\n- `GET /stream?subject=relay.human.console.xyz` succeeds (valid prefix)\n- `GET /stream?subject=relay.agent.some-session` returns 400 (prevents cross-session snooping)\n- `GET /stream?subject=relay.system.pulse.schedule1` succeeds (valid prefix)\n- SSE stream behavior (keepalive, relay_message, relay_signal events) is unchanged for valid patterns\n- `pnpm typecheck` passes",
      "activeForm": "Validating relay SSE subscription patterns in relay.ts",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1", "1.2", "1.3"]
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "Client Critical Fixes",
      "subject": "[server-client-code-review-fixes] [P2] Fix EventSource reconnection cascade in useChatSession and stream-event-handler",
      "description": "## C1+C2: EventSource Reconnection Cascade\n\n**Files:**\n- `apps/client/src/layers/features/chat/ui/ChatPanel.tsx` (lines 44-81)\n- `apps/client/src/layers/features/chat/model/use-chat-session.ts` (lines 108-130, 163-172)\n- `apps/client/src/layers/features/chat/model/stream-event-handler.ts` (lines 14-31, 57-75)\n- `apps/client/src/layers/features/chat/model/chat-types.ts` (read-only reference)\n\n**Root cause:** Three compounding issues create a reconnection cascade:\n1. In `ChatPanel.tsx`, `handleTaskEventWithCelebrations` depends on `taskState` and `celebrations` objects (new every render), making the `useCallback` effectively unstable\n2. `onStreamingDone` is an inline `useCallback` inside the `options` object literal (line 76)\n3. In `use-chat-session.ts`, the `options` bag is always a new reference, making the `streamEventHandler` `useMemo` dependency array `[sessionId, options]` (line 129) recreate on every render\n4. The `useEffect` on line 175 depends on `streamEventHandler`, so it tears down and reopens the EventSource on every render\n\n**Fix (Part A) — Ref-stabilize callbacks in `useChatSession`:**\n\nIn `apps/client/src/layers/features/chat/model/use-chat-session.ts`:\n\n1. At the top of `useChatSession`, after destructuring `options`, add refs to stabilize callbacks:\n```typescript\nconst onTaskEventRef = useRef(options.onTaskEvent);\nconst onSessionIdChangeRef = useRef(options.onSessionIdChange);\nconst onStreamingDoneRef = useRef(options.onStreamingDone);\nconst transformContentRef = useRef(options.transformContent);\n\n// Sync refs on every render (no useEffect needed — refs are synchronous)\nonTaskEventRef.current = options.onTaskEvent;\nonSessionIdChangeRef.current = options.onSessionIdChange;\nonStreamingDoneRef.current = options.onStreamingDone;\ntransformContentRef.current = options.transformContent;\n```\n\n2. Update `createStreamEventHandler` call (line 108-130) to pass refs instead of the `options` bag, and remove `options` from the dependency array:\n```typescript\nconst streamEventHandler = useMemo(\n  () =>\n    createStreamEventHandler({\n      currentPartsRef,\n      assistantCreatedRef,\n      sessionStatusRef,\n      streamStartTimeRef,\n      estimatedTokensRef,\n      textStreamingTimerRef,\n      isTextStreamingRef,\n      setMessages,\n      setError,\n      setStatus,\n      setSessionStatus,\n      setEstimatedTokens,\n      setStreamStartTime,\n      setIsTextStreaming,\n      sessionId,\n      onTaskEventRef,\n      onSessionIdChangeRef,\n      onStreamingDoneRef,\n    }),\n  [sessionId]\n);\n```\n\n3. Update the `handleSubmit` callback (line 255) to use `transformContentRef` instead of `options.transformContent`:\n```typescript\nconst finalContent = transformContentRef.current\n  ? await transformContentRef.current(userMessage.content)\n  : userMessage.content;\n```\n\n**Fix (Part B) — Update `createStreamEventHandler` to accept refs:**\n\nIn `apps/client/src/layers/features/chat/model/stream-event-handler.ts`:\n\n1. Update the `StreamEventDeps` interface — replace `options: ChatSessionOptions` with individual refs:\n```typescript\ninterface StreamEventDeps {\n  currentPartsRef: React.MutableRefObject<MessagePart[]>;\n  assistantCreatedRef: React.MutableRefObject<boolean>;\n  sessionStatusRef: React.MutableRefObject<SessionStatusEvent | null>;\n  streamStartTimeRef: React.MutableRefObject<number | null>;\n  estimatedTokensRef: React.MutableRefObject<number>;\n  textStreamingTimerRef: React.MutableRefObject<ReturnType<typeof setTimeout> | null>;\n  isTextStreamingRef: React.MutableRefObject<boolean>;\n  setMessages: React.Dispatch<React.SetStateAction<ChatMessage[]>>;\n  setError: (error: string | null) => void;\n  setStatus: (status: 'idle' | 'streaming' | 'error') => void;\n  setSessionStatus: (status: SessionStatusEvent | null) => void;\n  setEstimatedTokens: (tokens: number) => void;\n  setStreamStartTime: (time: number | null) => void;\n  setIsTextStreaming: (streaming: boolean) => void;\n  sessionId: string;\n  onTaskEventRef: React.MutableRefObject<((event: TaskUpdateEvent) => void) | undefined>;\n  onSessionIdChangeRef: React.MutableRefObject<((newSessionId: string) => void) | undefined>;\n  onStreamingDoneRef: React.MutableRefObject<(() => void) | undefined>;\n}\n```\n\n2. Update the destructuring at the top of `createStreamEventHandler`:\n```typescript\nconst {\n  // ... existing refs and setters ...\n  sessionId,\n  onTaskEventRef,\n  onSessionIdChangeRef,\n  onStreamingDoneRef,\n} = deps;\n```\n\n3. Replace `options.onTaskEvent?.(taskEvent)` (line 254) with:\n```typescript\nonTaskEventRef.current?.(taskEvent);\n```\n\n4. Replace `options.onSessionIdChange?.(doneData.sessionId)` (line 261) with:\n```typescript\nonSessionIdChangeRef.current?.(doneData.sessionId);\n```\n\n5. Replace `options.onStreamingDone?.()` (line 265) with:\n```typescript\nonStreamingDoneRef.current?.();\n```\n\n6. Remove the `import type { ChatSessionOptions } from './chat-types'` if it was only used for the `options` parameter.\n\n**Fix (Part C) — Fix ChatPanel `handleTaskEventWithCelebrations`:**\n\nIn `apps/client/src/layers/features/chat/ui/ChatPanel.tsx`:\n\n1. Destructure stable references from `taskState` and `celebrations` (lines 44-53):\n```typescript\nconst { handleTaskEvent: taskHandleEvent, tasks } = taskState;\nconst { handleTaskEvent: celebHandleEvent } = celebrations;\n\nconst handleTaskEventWithCelebrations = useCallback(\n  (event: TaskUpdateEvent) => {\n    taskHandleEvent(event);\n    const projectedTasks = tasks.map((t) =>\n      t.id === event.task.id ? { ...t, ...event.task } : t\n    );\n    celebHandleEvent(event, projectedTasks);\n  },\n  [taskHandleEvent, tasks, celebHandleEvent]\n);\n```\n\nNote: `taskHandleEvent` is already stabilized with `useCallback([], [])` in `use-task-state.ts`. `celebHandleEvent` is stabilized with `useCallback([], [])` in `use-celebrations.ts`. The `tasks` array changes when tasks update, which is correct for projection.\n\n**Fix (Part D) — Fix incremental history seeding:**\n\nIn `apps/client/src/layers/features/chat/model/use-chat-session.ts` (lines 164-171):\n\nReplace the array-length comparison with ID-based deduplication:\n```typescript\nif (historySeededRef.current && !isStreaming) {\n  const currentMessages = messagesRef.current;\n  const existingIds = new Set(currentMessages.map((m) => m.id));\n  const newMessages = history.filter((m) => !existingIds.has(m.id));\n\n  if (newMessages.length > 0) {\n    setMessages((prev) => [...prev, ...newMessages.map(mapHistoryMessage)]);\n  }\n}\n```\n\n**Acceptance criteria:**\n- The `streamEventHandler` identity is stable across renders when only the `options` bag changes (not `sessionId`)\n- The EventSource `useEffect` does not tear down and reopen on every render\n- `handleTaskEventWithCelebrations` only changes when `taskHandleEvent`, `tasks`, or `celebHandleEvent` change\n- Incremental history seeding uses ID-based deduplication instead of array length comparison\n- The relay path still works: `relay_message` events are processed by `streamEventHandler` via the EventSource\n- The legacy SSE path still works: inline events are processed by `streamEventHandler` via `handleSubmit`\n- `pnpm typecheck` passes\n- No visual regressions in the chat UI",
      "activeForm": "Fixing EventSource reconnection cascade in useChatSession",
      "size": "large",
      "priority": "high",
      "dependencies": [],
      "parallelWith": []
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "Client Critical Fixes",
      "subject": "[server-client-code-review-fixes] [P2] Fix FSD layer violation by moving FileEntry type to shared",
      "description": "## C3: FSD Layer Violation\n\n**Files:**\n- `apps/client/src/layers/features/chat/model/use-file-autocomplete.ts` (line 3)\n- `apps/client/src/layers/features/files/ui/FilePalette.tsx` (lines 5-10, type definition)\n- `apps/client/src/layers/features/files/index.ts` (line 7, re-export)\n- `apps/client/src/layers/shared/lib/file-types.ts` (new file)\n- `apps/client/src/layers/shared/lib/index.ts` (add re-export)\n- `apps/client/src/layers/features/chat/ui/ChatPanel.tsx` (line 21, update import)\n\n**Problem:** `use-file-autocomplete.ts` (a feature model hook in `features/chat`) imports `FileEntry` from `@/layers/features/files` — a cross-feature model import that violates the FSD layer rules. Features must not import from sibling features' models.\n\n**Current violation (use-file-autocomplete.ts line 3):**\n```typescript\nimport type { FileEntry } from '@/layers/features/files';\n```\n\n**Fix:** Move the `FileEntry` type to `shared/lib/file-types.ts`. Update imports in all consumers. Re-export from `features/files/index.ts` for backward compatibility.\n\n**Implementation steps:**\n\n1. Create `apps/client/src/layers/shared/lib/file-types.ts`:\n```typescript\n/** A file or directory entry for autocomplete and file browser UIs. */\nexport interface FileEntry {\n  path: string;\n  filename: string;\n  directory: string;\n  isDirectory: boolean;\n}\n```\n\n2. Update `apps/client/src/layers/shared/lib/index.ts` — add re-export:\n```typescript\nexport type { FileEntry } from './file-types';\n```\n\n3. Update `apps/client/src/layers/features/files/ui/FilePalette.tsx` — remove the local interface definition (lines 5-10) and import from shared:\n```typescript\nimport type { FileEntry } from '@/layers/shared/lib';\n```\n\n4. Update `apps/client/src/layers/features/files/index.ts` — change re-export source:\n```typescript\nexport type { FileEntry } from '@/layers/shared/lib';\n```\n\n5. Update `apps/client/src/layers/features/chat/model/use-file-autocomplete.ts` — change import (line 3):\n```typescript\nimport type { FileEntry } from '@/layers/shared/lib';\n```\n\n6. Update `apps/client/src/layers/features/chat/ui/ChatPanel.tsx` — change import (line 21):\n```typescript\nimport type { FileEntry } from '@/layers/shared/lib';\n```\n\n**Acceptance criteria:**\n- `FileEntry` is defined in `shared/lib/file-types.ts` (the canonical location)\n- Both `features/chat` and `features/files` import `FileEntry` from `@/layers/shared/lib`\n- `features/files/index.ts` re-exports `FileEntry` from `@/layers/shared/lib` for backward compat\n- No cross-feature model imports remain\n- `pnpm typecheck` passes\n- `pnpm lint` passes (no FSD layer violation errors)",
      "activeForm": "Moving FileEntry type to shared to fix FSD layer violation",
      "size": "small",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["2.3"]
    },
    {
      "id": "2.3",
      "phase": 2,
      "phaseName": "Client Critical Fixes",
      "subject": "[server-client-code-review-fixes] [P2] Make streaming text_delta updates immutable in stream-event-handler.ts",
      "description": "## C4: Mutable Ref During Streaming\n\n**File:** `apps/client/src/layers/features/chat/model/stream-event-handler.ts` (lines 124-132)\n\n**Problem:** In the `text_delta` case of `handleStreamEvent`, `lastPart.text += text` mutates the existing part object in place, and `parts.push()` mutates the array. Since `currentPartsRef.current` holds the same array reference, React may not detect changes correctly when `updateAssistantMessage` reads from it.\n\n**Current code (lines 124-132):**\n```typescript\ncase 'text_delta': {\n  const { text } = data as TextDelta;\n  const parts = currentPartsRef.current;\n  const lastPart = parts[parts.length - 1];\n  if (lastPart && lastPart.type === 'text') {\n    lastPart.text += text;\n  } else {\n    parts.push({ type: 'text', text });\n  }\n  // ...\n}\n```\n\n**Fix:** Replace in-place mutation with immutable updates — create new arrays and objects instead of mutating the existing ones.\n\n**Replacement code for the `text_delta` case (lines 124-145):**\n```typescript\ncase 'text_delta': {\n  const { text } = data as TextDelta;\n  const parts = currentPartsRef.current;\n  const lastPart = parts[parts.length - 1];\n  if (lastPart && lastPart.type === 'text') {\n    // Create new array with replaced last element\n    currentPartsRef.current = [\n      ...parts.slice(0, -1),\n      { ...lastPart, text: lastPart.text + text },\n    ];\n  } else {\n    // Create new array with appended element\n    currentPartsRef.current = [...parts, { type: 'text', text }];\n  }\n  estimatedTokensRef.current += text.length / 4;\n  setEstimatedTokens(estimatedTokensRef.current);\n  if (!isTextStreamingRef.current) {\n    isTextStreamingRef.current = true;\n    setIsTextStreaming(true);\n  }\n  if (textStreamingTimerRef.current) clearTimeout(textStreamingTimerRef.current);\n  textStreamingTimerRef.current = setTimeout(() => {\n    isTextStreamingRef.current = false;\n    setIsTextStreaming(false);\n  }, 500);\n  updateAssistantMessage(assistantId);\n  break;\n}\n```\n\nNote: The `updateAssistantMessage` function already creates shallow copies via `currentPartsRef.current.map((p) => ({ ...p }))` on line 106, so this change makes the entire chain immutable from ref storage through to React state.\n\nNote: This task must be coordinated with task 2.1 (C1+C2 fix) since both modify `stream-event-handler.ts`. If running in parallel, merge carefully. If running sequentially, task 2.1 should be done first since it changes the `StreamEventDeps` interface.\n\n**Acceptance criteria:**\n- `text_delta` processing creates new part objects instead of mutating existing ones\n- `currentPartsRef.current` is reassigned (not mutated) on every `text_delta`\n- Streaming text still renders correctly in the chat UI\n- `tool_call_start`, `tool_call_delta`, `tool_call_end`, and `tool_result` cases are NOT changed in this task (they already use `findToolCallPart` which returns a reference — those mutations are addressed by `updateAssistantMessage` which copies all parts)\n- `pnpm typecheck` passes\n- No visual regressions in streaming text rendering",
      "activeForm": "Making streaming text_delta updates immutable",
      "size": "small",
      "priority": "medium",
      "dependencies": ["2.1"],
      "parallelWith": ["2.2"]
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Client Quality Fixes",
      "subject": "[server-client-code-review-fixes] [P3] Fix ARIA roles on LinkSafetyModal in StreamingText.tsx",
      "description": "## C5: Incorrect ARIA on LinkSafetyModal\n\n**File:** `apps/client/src/layers/features/chat/ui/StreamingText.tsx` (lines 17-31)\n\n**Problem:** The `LinkSafetyModal` backdrop uses `role=\"button\"` and `tabIndex={0}` on the outer container div. A backdrop is not a button — it's a decorative overlay. The actual dialog content (`div` on line 28) uses `role=\"presentation\"` which provides no semantic meaning. This confuses screen readers: the backdrop is announced as a button, and the dialog is invisible to assistive technology.\n\n**Current code (lines 16-32):**\n```tsx\nreturn createPortal(\n  <div\n    className=\"fixed inset-0 z-50 flex items-center justify-center\"\n    data-streamdown=\"link-safety-modal\"\n    onClick={onClose}\n    onKeyDown={(e) => {\n      if (e.key === 'Escape') onClose();\n    }}\n    role=\"button\"\n    tabIndex={0}\n  >\n    <div\n      className=\"bg-background relative mx-4 flex w-full max-w-md flex-col gap-4 rounded-xl border p-6 shadow-lg\"\n      onClick={(e) => e.stopPropagation()}\n      onKeyDown={(e) => e.stopPropagation()}\n      role=\"presentation\"\n    >\n```\n\n**Fix:** Remove `role=\"button\"` and `tabIndex={0}` from the backdrop. Add `aria-hidden=\"true\"` to the backdrop since it's decorative. Add proper dialog ARIA (`role=\"dialog\"`, `aria-modal=\"true\"`, `aria-label`) to the content div. Move keyboard handling to the content div.\n\n**Replacement code for the entire `LinkSafetyModal` component:**\n```tsx\nfunction LinkSafetyModal({ url, isOpen, onClose, onConfirm }: LinkSafetyModalProps) {\n  if (!isOpen) return null;\n\n  return createPortal(\n    <div\n      className=\"fixed inset-0 z-50 flex items-center justify-center\"\n      data-streamdown=\"link-safety-modal\"\n      onClick={onClose}\n      aria-hidden=\"true\"\n    >\n      <div className=\"fixed inset-0 bg-black/50\" aria-hidden=\"true\" />\n      <div\n        className=\"bg-background relative mx-4 flex w-full max-w-md flex-col gap-4 rounded-xl border p-6 shadow-lg\"\n        onClick={(e) => e.stopPropagation()}\n        onKeyDown={(e) => {\n          if (e.key === 'Escape') onClose();\n          e.stopPropagation();\n        }}\n        role=\"dialog\"\n        aria-modal=\"true\"\n        aria-label=\"External link confirmation\"\n        tabIndex={-1}\n      >\n        <button\n          className=\"text-muted-foreground hover:bg-muted hover:text-foreground absolute top-4 right-4 rounded-md p-1 transition-all\"\n          onClick={onClose}\n          title=\"Close\"\n          type=\"button\"\n        >\n          <X size={16} />\n        </button>\n        <div className=\"flex flex-col gap-2\">\n          <div className=\"flex items-center gap-2 text-lg font-semibold\">\n            <ExternalLink size={20} />\n            <span>Open external link?</span>\n          </div>\n          <p className=\"text-muted-foreground text-sm\">\n            You&apos;re about to visit an external website.\n          </p>\n        </div>\n        <div className=\"bg-muted rounded-md p-3 font-mono text-sm break-all\">{url}</div>\n        <div className=\"flex gap-3\">\n          <button\n            className=\"hover:bg-muted flex flex-1 items-center justify-center gap-2 rounded-lg border px-4 py-2 text-sm font-medium transition-colors\"\n            onClick={() => {\n              navigator.clipboard.writeText(url);\n              onClose();\n            }}\n            type=\"button\"\n          >\n            <Copy size={14} />\n            Copy link\n          </button>\n          <button\n            className=\"bg-foreground text-background hover:bg-foreground/90 flex flex-1 items-center justify-center gap-2 rounded-lg px-4 py-2 text-sm font-medium transition-colors\"\n            onClick={onConfirm}\n            type=\"button\"\n          >\n            <ExternalLink size={14} />\n            Open link\n          </button>\n        </div>\n      </div>\n    </div>,\n    document.body\n  );\n}\n```\n\n**Key changes:**\n- Outer backdrop: removed `role=\"button\"`, removed `tabIndex={0}`, added `aria-hidden=\"true\"`\n- Added explicit backdrop overlay div `<div className=\"fixed inset-0 bg-black/50\" aria-hidden=\"true\" />` (note: the original had no visible backdrop — if it already has one via CSS, adjust accordingly)\n- Content div: changed `role=\"presentation\"` to `role=\"dialog\"` with `aria-modal=\"true\"` and `aria-label=\"External link confirmation\"`\n- Content div: added `tabIndex={-1}` for programmatic focus\n- Moved `onKeyDown` (Escape handling) from backdrop to content div with `e.stopPropagation()`\n\n**Acceptance criteria:**\n- Screen readers announce the modal as a dialog, not a button\n- Escape key still closes the modal\n- Clicking the backdrop still closes the modal\n- The dialog content div has proper ARIA roles\n- `pnpm typecheck` passes\n- Visual appearance is unchanged",
      "activeForm": "Fixing ARIA roles on LinkSafetyModal",
      "size": "small",
      "priority": "low",
      "dependencies": [],
      "parallelWith": ["3.2", "3.3"]
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "Client Quality Fixes",
      "subject": "[server-client-code-review-fixes] [P3] Deduplicate sessions query in SessionSidebar.tsx",
      "description": "## C6: Duplicated Sessions Query\n\n**File:** `apps/client/src/layers/features/session-list/ui/SessionSidebar.tsx` (lines 88-92)\n\n**Problem:** `SessionSidebar` has an inline `useQuery` with `queryKey: ['sessions', selectedCwd]` that duplicates the canonical `useSessions()` hook from `@/layers/entities/session`. This means two independent query instances with the same key but different configs — the inline one lacks `refetchInterval`, while `useSessions()` has `refetchInterval: QUERY_TIMING.SESSIONS_REFETCH_MS`. TanStack Query deduplicates by key, but having two hook callsites with different configs is confusing and wastes a query observer.\n\n**Current code (lines 88-92):**\n```typescript\nconst { data: sessions = [] } = useQuery({\n  queryKey: ['sessions', selectedCwd],\n  queryFn: () => transport.listSessions(selectedCwd ?? undefined),\n  enabled: selectedCwd !== null,\n});\n```\n\n**Canonical hook (entities/session/model/use-sessions.ts):**\n```typescript\nexport function useSessions() {\n  // ...\n  const sessionsQuery = useQuery({\n    queryKey: ['sessions', selectedCwd],\n    queryFn: () => transport.listSessions(selectedCwd ?? undefined),\n    refetchInterval: QUERY_TIMING.SESSIONS_REFETCH_MS,\n    enabled: selectedCwd !== null,\n  });\n\n  return {\n    sessions: sessionsQuery.data ?? [],\n    isLoading: sessionsQuery.isLoading,\n    createSession,\n    activeSessionId,\n    setActiveSession,\n  };\n}\n```\n\n**Fix:** Replace the inline `useQuery` with `useSessions()` from the entity layer. Verify that `useSessions()` provides the same data shape.\n\n**Implementation steps:**\n\n1. In `apps/client/src/layers/features/session-list/ui/SessionSidebar.tsx`:\n\n2. Add `useSessions` to imports from `@/layers/entities/session` (line 27):\n```typescript\nimport { useSessionId, useDirectoryState, useSessions } from '@/layers/entities/session';\n```\n\n3. Replace the inline query (lines 88-92) with:\n```typescript\nconst { sessions } = useSessions();\n```\n\n4. Remove `useQuery` from the `@tanstack/react-query` import (line 2) — check if `useQuery` is still used elsewhere in the file. `useMutation` and `useQueryClient` are still needed, so update the import to only include those:\n```typescript\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\n```\n\n5. Remove the `useTransport` import from `@/layers/shared/model` (line 4) — check if `transport` is still used elsewhere in the file. It is used in `createMutation` (line 103), so it must remain. Actually, `useSessions` already provides `createSession` — but the `SessionSidebar` has custom `onSuccess` logic (invalidate, highlight, auto-close), so keep the local `createMutation`.\n\nWait — `transport` IS still used in `createMutation.mutationFn` (line 103). So keep the `useTransport` import. But check: the `useSessions` hook already has `createSession` mutation. However, the sidebar's mutation has different `onSuccess` behavior (highlighting, auto-close on mobile), so the local mutation should remain.\n\n**Acceptance criteria:**\n- `SessionSidebar` uses `useSessions()` for the sessions list instead of a duplicate inline `useQuery`\n- `useQuery` is removed from the import if no longer used directly\n- Session list rendering behavior is unchanged\n- The `refetchInterval` from `useSessions()` is now active (this is an improvement — session list auto-refreshes)\n- `pnpm typecheck` passes\n- `pnpm lint` passes",
      "activeForm": "Deduplicating sessions query in SessionSidebar",
      "size": "small",
      "priority": "low",
      "dependencies": [],
      "parallelWith": ["3.1", "3.3"]
    },
    {
      "id": "3.3",
      "phase": 3,
      "phaseName": "Client Quality Fixes",
      "subject": "[server-client-code-review-fixes] [P3] Add error handling to relay SSE JSON.parse in use-relay-event-stream.ts",
      "description": "## C7: Uncaught JSON.parse in Relay SSE Listeners\n\n**File:** `apps/client/src/layers/entities/relay/model/use-relay-event-stream.ts` (lines 43-69)\n\n**Problem:** Both `relay_message` and `relay_delivery` event listeners call `JSON.parse(e.data)` without any error handling. If the server sends malformed JSON (e.g., due to a partial write, encoding issue, or relay protocol error), the uncaught exception will crash the React component tree.\n\n**Current code (lines 43-69):**\n```typescript\nsource.addEventListener('relay_message', (e) => {\n  const envelope = JSON.parse(e.data);\n  queryClient.setQueryData(\n    ['relay', 'messages', undefined],\n    (old: { messages: unknown[]; nextCursor?: string } | undefined) => {\n      if (!old) return { messages: [envelope] };\n      return { ...old, messages: [envelope, ...old.messages] };\n    },\n  );\n});\n\nsource.addEventListener('relay_delivery', (e) => {\n  const data = JSON.parse(e.data);\n  queryClient.setQueryData(\n    ['relay', 'messages', undefined],\n    (old: { messages: unknown[]; nextCursor?: string } | undefined) => {\n      if (!old) return old;\n      return {\n        ...old,\n        messages: old.messages.map((msg) => {\n          const m = msg as Record<string, unknown>;\n          return m.id === data.messageId ? { ...m, status: data.status } : msg;\n        }),\n      };\n    },\n  );\n});\n```\n\n**Fix:** Wrap both `JSON.parse` calls in try/catch blocks with `console.warn` for debugging.\n\n**Replacement code for both event listeners (lines 43-69):**\n```typescript\nsource.addEventListener('relay_message', (e) => {\n  try {\n    const envelope = JSON.parse(e.data);\n    queryClient.setQueryData(\n      ['relay', 'messages', undefined],\n      (old: { messages: unknown[]; nextCursor?: string } | undefined) => {\n        if (!old) return { messages: [envelope] };\n        return { ...old, messages: [envelope, ...old.messages] };\n      },\n    );\n  } catch {\n    console.warn('[Relay] Failed to parse relay_message event:', e.data);\n  }\n});\n\nsource.addEventListener('relay_delivery', (e) => {\n  try {\n    const data = JSON.parse(e.data);\n    queryClient.setQueryData(\n      ['relay', 'messages', undefined],\n      (old: { messages: unknown[]; nextCursor?: string } | undefined) => {\n        if (!old) return old;\n        return {\n          ...old,\n          messages: old.messages.map((msg) => {\n            const m = msg as Record<string, unknown>;\n            return m.id === data.messageId ? { ...m, status: data.status } : msg;\n          }),\n        };\n      },\n    );\n  } catch {\n    console.warn('[Relay] Failed to parse relay_delivery event:', e.data);\n  }\n});\n```\n\n**Acceptance criteria:**\n- Malformed JSON in `relay_message` events logs a warning instead of crashing\n- Malformed JSON in `relay_delivery` events logs a warning instead of crashing\n- Valid JSON is processed identically to before (no behavior change)\n- The `console.warn` includes the raw `e.data` for debugging\n- `pnpm typecheck` passes",
      "activeForm": "Adding error handling to relay SSE JSON.parse",
      "size": "small",
      "priority": "low",
      "dependencies": [],
      "parallelWith": ["3.1", "3.2"]
    },
    {
      "id": "4.1",
      "phase": 4,
      "phaseName": "Validation",
      "subject": "[server-client-code-review-fixes] [P4] Validate all fixes with lint, typecheck, and test suite",
      "description": "## Validation: Lint, Typecheck, and Test Suite\n\nAfter all fixes from Phases 1-3 are applied, run the full validation suite to ensure no regressions.\n\n**Commands to run (in order):**\n\n1. **TypeScript type checking:**\n```bash\npnpm typecheck\n```\nExpect: Clean pass across all packages. If there are type errors, they are likely from the `StreamEventDeps` interface change in task 2.1 — check that all callsites of `createStreamEventHandler` use the new ref-based interface.\n\n2. **ESLint:**\n```bash\npnpm lint\n```\nExpect: No new errors. The FSD layer violation from C3 should be resolved. Check for any new `react-hooks/exhaustive-deps` warnings from the ref changes in task 2.1 — the eslint-disable comment on the `useMemo` should be updated or removed since `options` is no longer in the dependency array.\n\n3. **Test suite:**\n```bash\npnpm test -- --run\n```\nExpect: All existing tests pass. Tests that import `createStreamEventHandler` may need updating if they pass an `options` parameter — they should now pass `onTaskEventRef`, `onSessionIdChangeRef`, `onStreamingDoneRef` refs instead.\n\n4. **Check for any existing tests related to modified files:**\n- Look for test files in `apps/server/src/routes/__tests__/sessions.test.ts`\n- Look for test files in `apps/server/src/services/relay/__tests__/binding-router.test.ts`\n- Look for test files in `apps/client/src/layers/features/chat/model/__tests__/use-chat-session.test.ts`\n- Look for test files in `apps/client/src/layers/features/chat/model/__tests__/stream-event-handler.test.ts`\n- If tests exist that pass the old `options` shape to `createStreamEventHandler`, update them to use the ref-based interface\n\n**Fix any issues found:**\n- Type errors: Fix the relevant source file\n- Lint errors: Fix or update eslint-disable comments as appropriate\n- Test failures: Update test mocks/expectations to match the new interfaces\n\n**Acceptance criteria:**\n- `pnpm typecheck` passes with zero errors\n- `pnpm lint` passes with no new errors (warnings are acceptable if pre-existing)\n- `pnpm test -- --run` passes with zero failures\n- All 11 issues (S1-S4, C1-C7) are verified as fixed",
      "activeForm": "Validating all code review fixes",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1", "1.2", "1.3", "1.4", "2.1", "2.2", "2.3", "3.1", "3.2", "3.3"],
      "parallelWith": []
    }
  ]
}
