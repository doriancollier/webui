{
  "spec": "specs/relay-release-preparation/02-specification.md",
  "slug": "relay-release-preparation",
  "generatedAt": "2026-02-25T12:00:00Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[relay-release-preparation] [P1] Update spec manifest statuses, homepage module statuses, and CLI keywords",
      "description": "Three quick-win changes that unblock everything else.\n\n## 1. Spec Manifest Cleanup\n\n**File:** `specs/manifest.json`\n\nIn the `specs` array, find each of these entries by their `number` field and change their `status` value:\n\n| Spec # | Slug | Current Status | New Status |\n|--------|------|----------------|------------|\n| 51 | relay-server-client-integration | ideation | implemented |\n| 53 | relay-external-adapters | specified | implemented |\n| 54 | mesh-core-library | specified | implemented |\n| 56 | mesh-server-client-integration | specified | implemented |\n| 58 | mesh-network-topology | specified | implemented |\n| 59 | mesh-observability-lifecycle | specified | implemented |\n\nDo NOT change specs 50 or 57 (already `implemented`) or spec 52 (stays `specified` — not fully implemented).\n\n## 2. Homepage Module Status\n\n**File:** `apps/web/src/layers/features/marketing/lib/modules.ts`\n\nFind the module definitions and change the `status` field for three modules:\n- `pulse`: change `'coming-soon'` to `'available'`\n- `relay`: change `'coming-soon'` to `'available'`\n- `mesh`: change `'coming-soon'` to `'available'`\n\nThis is a simple string replacement in each module's object literal.\n\n## 3. CLI Package Keywords\n\n**File:** `packages/cli/package.json`\n\nAdd the following strings to the existing `keywords` array:\n```json\n\"relay\", \"mesh\", \"agent-mesh\", \"pub-sub\", \"agent-discovery\", \"message-bus\", \"scheduler\", \"pulse\"\n```\n\nDo not remove existing keywords; append these new ones.\n\n## Acceptance Criteria\n- `specs/manifest.json` has 6 specs updated to `implemented` status\n- Homepage modules.ts shows all three subsystems as `'available'`\n- CLI package.json keywords array includes all 8 new terms\n- `npm run typecheck` passes (catches any TS issues in modules.ts)\n- `npm run build --filter=@dorkos/web` succeeds",
      "activeForm": "Updating spec manifest, homepage statuses, and CLI keywords",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": []
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "Concept Pages",
      "subject": "[relay-release-preparation] [P2] Write Relay and Mesh concept pages and update concepts meta.json",
      "description": "Create two new MDX concept pages and update the navigation config.\n\n## File 1: `docs/concepts/relay.mdx`\n\nFrontmatter:\n```yaml\n---\ntitle: Relay\ndescription: How the subject-based pub/sub message bus works under the hood.\n---\n```\n\nWrite the following sections with substantive content drawn from the source material in `plans/relay-specs/`, `packages/shared/src/relay-schemas.ts`, and `apps/server/src/services/relay/`:\n\n1. **Architecture Overview** — RelayCore as in-process message router. Subject-based routing with wildcard matching (e.g., `relay.agent.*`). Subscriber registry with pattern matching. Explain that RelayCore is a singleton that manages publish/subscribe lifecycle, message routing, and adapter coordination.\n\n2. **Subject Hierarchy** — Document the four subject namespaces:\n   - `relay.agent.{sessionId}` — messages routed to agent sessions\n   - `relay.human.console.{clientId}` — messages routed back to human clients\n   - `relay.system.pulse.{scheduleId}` — Pulse schedule dispatch\n   - `relay.external.{adapter}.{channel}` — external adapter channels\n\n3. **Message Envelopes** — Document the envelope schema from relay-schemas.ts: `id`, `subject`, `payload`, `from`, `replyTo`, `budget` (maxHops, maxReplies, ttlMs), `metadata` (traceId, parentId, timestamps). Use a Fumadocs `TypeTable` component to display the schema fields.\n\n4. **Adapter Architecture** — AdapterRegistry plugin system. Adapter lifecycle: `initialize()` -> `subscribe()` -> `publish()` -> `shutdown()`. Built-in adapters: ClaudeCodeAdapter, TelegramAdapter, WebhookAdapter. Custom adapters loaded via config.\n\n5. **Message Tracing** — SQLite trace store (`message_traces` table in `~/.dork/relay/index.db`). Span model: publish -> route -> deliver. Metrics aggregation (success rate, latency percentiles, throughput). Use `relay_get_trace` and `relay_get_metrics` MCP tools.\n\n6. **Convergence** — How Relay unifies session messaging (POST /messages publishes to Relay, ClaudeCodeAdapter handles delivery) and Pulse dispatch (scheduler publishes to `relay.system.pulse.*` instead of calling AgentManager directly). Fallback: when Relay is disabled, both systems use direct in-process calls.\n\nUse Fumadocs components: `Callout` for important notes, `TypeTable` for schema fields, `Cards`/`Card` for cross-references.\n\n## File 2: `docs/concepts/mesh.mdx`\n\nFrontmatter:\n```yaml\n---\ntitle: Mesh\ndescription: Agent discovery, network topology, and coordination in DorkOS.\n---\n```\n\nWrite the following sections with substantive content drawn from `plans/mesh-specs/`, `packages/shared/src/mesh-schemas.ts`, and `apps/server/src/services/mesh/`:\n\n1. **Architecture Overview** — MeshCore as agent registry and discovery engine. In-memory registry with SQLite persistence. Discovery is pull-based (POST /discover triggers scan). MeshCore is a singleton managing the agent lifecycle.\n\n2. **Agent Manifests** — Document the AgentManifest schema from mesh-schemas.ts: `id`, `name`, `capabilities` (array of strings), `subjects` (array of Relay subjects the agent subscribes to), `healthEndpoint` (optional URL), `metadata` (freeform key-value). Use `TypeTable` for fields.\n\n3. **Discovery Flow** — POST /api/mesh/discover returns `DiscoveryCandidate[]`. UI presents candidates via CandidateCard. User accepts (registers agent) or denies (adds to denial list with reason). Flow diagram in text.\n\n4. **Network Topology** — Graph model: agents are nodes, message routes are edges. TopologyGraph component renders a force-directed layout. Health data overlays (node colors reflect health state). Topology types from mesh-schemas.ts.\n\n5. **Health Monitoring** — Heartbeat protocol: agents POST to `/api/mesh/agents/:id/heartbeat` at configured intervals. Health states: `healthy`, `degraded`, `unreachable`. State transitions based on missed heartbeats. AgentHealthDetail component shows per-agent drill-down.\n\n6. **Lifecycle Events** — Event types: `registered`, `deregistered`, `heartbeat`, `health_changed`. Events stored in MeshCore event store. SSE streaming for real-time lifecycle updates in the MeshPanel.\n\n7. **Access Control** — Denial records with reason tracking (POST /api/mesh/deny). Denied agents excluded from future discovery. Audit trail via GET /api/mesh/denied. Subject-based access rules.\n\n## File 3: Update `docs/concepts/meta.json`\n\nThe current pages array likely contains `[\"architecture\", \"sessions\", \"transport\"]`. Add `\"relay\"` and `\"mesh\"` to the end:\n\n```json\n{\n  \"title\": \"Concepts\",\n  \"pages\": [\"architecture\", \"sessions\", \"transport\", \"relay\", \"mesh\"]\n}\n```\n\nRead the file first to confirm the existing entries before editing.\n\n## Acceptance Criteria\n- `docs/concepts/relay.mdx` exists with all 6 sections, valid frontmatter, and Fumadocs components\n- `docs/concepts/mesh.mdx` exists with all 7 sections, valid frontmatter, and Fumadocs components\n- `docs/concepts/meta.json` includes `relay` and `mesh` in pages array\n- `npm run build --filter=@dorkos/web` succeeds (validates MDX syntax)\n- Internal links use correct `/docs/` paths",
      "activeForm": "Writing Relay and Mesh concept pages",
      "size": "large",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": []
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "User Guides",
      "subject": "[relay-release-preparation] [P3] Write Relay messaging and observability guides",
      "description": "Create two MDX guide pages covering Relay usage and observability.\n\n## File 1: `docs/guides/relay-messaging.mdx`\n\nFrontmatter:\n```yaml\n---\ntitle: Relay Messaging\ndescription: Send messages between agents, humans, and external systems using subject-based pub/sub.\n---\n```\n\nSections:\n\n1. **What is Relay?** — Brief intro: Relay is DorkOS's inter-agent message bus. Subject-based pub/sub routing. Link to `/docs/concepts/relay` for architecture deep dive. Use a `Callout` component for the link.\n\n2. **Enabling Relay** — Set `DORKOS_RELAY_ENABLED=true` in your `.env` file or pass `--relay` to the CLI. Restart the server. The Relay tab appears in the sidebar. Use `Steps` component:\n   ```mdx\n   <Steps>\n   ### Set the environment variable\n   Add `DORKOS_RELAY_ENABLED=true` to your `.env` file.\n   \n   ### Restart DorkOS\n   Restart the server for changes to take effect.\n   \n   ### Open the Relay tab\n   The Relay tab now appears in the sidebar navigation.\n   </Steps>\n   ```\n\n3. **Sending Messages** — Three methods:\n   - **RelayPanel UI**: Open Relay tab, compose message with subject and payload, click Send\n   - **REST API**: `POST /api/relay/messages` with JSON body `{ subject, payload, budget? }`\n   - **MCP tools**: `relay_send` (send message), `relay_inbox` (read inbox)\n   Show example curl command and example MCP tool usage.\n\n4. **Built-in Adapters** — Table of three built-in adapters:\n   - Claude Code: Routes messages to agent sessions via `relay.agent.{sessionId}`\n   - Telegram: Bridges Telegram Bot API messages into Relay subjects\n   - Webhook: Sends HTTP callbacks to configured URLs on message delivery\n\n5. **Message Tracing** — Every message gets a `traceId`. View traces in the MessageTrace panel (click any message row). Metrics dashboard shows delivery success rate, latency, throughput. Link to `/docs/guides/relay-observability` for details.\n\n6. **Relay + Pulse Integration** — When both Relay and Pulse are enabled: Pulse schedule dispatch publishes to `relay.system.pulse.{scheduleId}` instead of calling AgentManager directly. Session messaging routes through Relay transport. Fallback behavior when Relay is disabled.\n\n7. **Configuration Reference** — Table of config options:\n   - `DORKOS_RELAY_ENABLED`: Enable/disable (default: false)\n   - `~/.dork/config.json` relay section: adapter configs\n   - Subject prefix conventions: `relay.agent.*`, `relay.human.*`, `relay.system.*`, `relay.external.*`\n\n## File 2: `docs/guides/relay-observability.mdx`\n\nFrontmatter:\n```yaml\n---\ntitle: Relay Observability\ndescription: Monitor message delivery, trace failures, and understand Relay metrics.\n---\n```\n\nSections:\n\n1. **Message Tracing** — How traces work: every published message gets a unique `traceId`. Spans track the message through publish -> route -> deliver stages. SQLite storage in `~/.dork/relay/index.db`. Explain the span model with a simple diagram in text.\n\n2. **Delivery Metrics Dashboard** — The DeliveryMetricsDashboard component in the Relay tab. Key indicators: total messages, success rate, average latency, throughput (msg/sec). Time-series data. Explain what each metric means and healthy ranges.\n\n3. **Debugging Failed Deliveries** — Dead letter queue: messages that fail delivery appear in GET /api/relay/dead-letters. Common failure modes:\n   - No subscriber for subject (check subject spelling, verify agent is registered)\n   - Budget exceeded (maxHops, maxReplies, ttlMs expired)\n   - Adapter error (check adapter logs, verify external service connectivity)\n   Resolution steps for each.\n\n4. **Using MCP Tools** — Programmatic access for agents:\n   - `relay_get_trace` — Retrieve full trace for a message by traceId\n   - `relay_get_metrics` — Get aggregate delivery metrics\n   Show example usage patterns.\n\n## Acceptance Criteria\n- Both MDX files exist with valid frontmatter and all specified sections\n- Cross-links between guides use correct `/docs/` paths\n- Fumadocs components (Steps, Callout, TypeTable) used appropriately\n- `npm run build --filter=@dorkos/web` succeeds",
      "activeForm": "Writing Relay messaging and observability guides",
      "size": "large",
      "priority": "high",
      "dependencies": ["2.1"],
      "parallelWith": ["3.2", "3.3"]
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "User Guides",
      "subject": "[relay-release-preparation] [P3] Write Agent Discovery and Pulse Scheduler guides",
      "description": "Create two MDX guide pages covering Mesh agent discovery and Pulse scheduling.\n\n## File 1: `docs/guides/agent-discovery.mdx`\n\nFrontmatter:\n```yaml\n---\ntitle: Agent Discovery\ndescription: Discover, register, and coordinate agents across your network with Mesh.\n---\n```\n\nSections:\n\n1. **What is Mesh?** — Brief intro: Mesh is DorkOS's agent discovery and registry system. Agents register manifests describing their capabilities. Link to `/docs/concepts/mesh` for deep dive.\n\n2. **Enabling Mesh** — Set `DORKOS_MESH_ENABLED=true` in `.env`. Restart. Mesh tab appears. Use `Steps` component similar to Relay guide.\n\n3. **Discovering Agents** — POST /api/mesh/discover triggers a discovery scan. Returns `DiscoveryCandidate[]`. In the UI, CandidateCard components display each candidate with name, capabilities, and accept/deny buttons. Example curl:\n   ```bash\n   curl -X POST http://localhost:4242/api/mesh/discover\n   ```\n\n4. **Agent Manifests** — JSON format for agent registration. Required fields: `name` (string), `capabilities` (string array). Optional fields: `subjects` (Relay subjects array), `healthEndpoint` (URL string), `metadata` (object). Example manifest:\n   ```json\n   {\n     \"name\": \"research-agent\",\n     \"capabilities\": [\"web-search\", \"summarization\"],\n     \"subjects\": [\"relay.agent.research.*\"],\n     \"healthEndpoint\": \"http://localhost:5000/health\",\n     \"metadata\": { \"version\": \"1.0\", \"owner\": \"team-alpha\" }\n   }\n   ```\n\n5. **Registering Agents** — Three methods:\n   - **MeshPanel UI**: Click \"Register Agent\", fill in RegisterAgentDialog form\n   - **REST API**: POST /api/mesh/agents with manifest JSON body\n   - **MCP tools**: `mesh_register` tool with manifest as argument\n\n6. **Network Topology** — TopologyGraph visualization shows agents as nodes and message routes as edges. Live health data overlays (node colors: green=healthy, yellow=degraded, red=unreachable). Edge weights reflect message volume.\n\n7. **Health Monitoring** — Heartbeat protocol: agents POST to `/api/mesh/agents/:id/heartbeat` periodically. Health states: `healthy` (recent heartbeat), `degraded` (missed 1-2 heartbeats), `unreachable` (missed 3+ heartbeats). AgentHealthDetail component shows per-agent timeline.\n\n8. **Access Control** — Deny agents via POST /api/mesh/deny with `{ agentId, reason }`. Denied agents excluded from discovery results. View denied list: GET /api/mesh/denied. Remove denial: DELETE /api/mesh/denied/:id.\n\n9. **Configuration Reference** — Table:\n   - `DORKOS_MESH_ENABLED`: Enable/disable (default: false)\n   - Agent manifest format (see section 4)\n   - Health check intervals: configurable per-agent via manifest\n\n## File 2: `docs/guides/pulse-scheduler.mdx`\n\nFrontmatter:\n```yaml\n---\ntitle: Pulse Scheduler\ndescription: Autonomous cron-based agent jobs that work while you sleep.\n---\n```\n\nSections:\n\n1. **What is Pulse?** — Cron scheduling for AI agents. Create schedules that trigger agent sessions at specified intervals. Agents run autonomously with configurable prompts and working directories.\n\n2. **Enabling Pulse** — `DORKOS_PULSE_ENABLED=true` (enabled by default). Pulse tab appears in sidebar. Or pass `--pulse` / `--no-pulse` to CLI.\n\n3. **Creating Schedules** — Three methods:\n   - **PulsePanel UI**: Click \"Create Schedule\", fill in dialog with name, cron expression, prompt, cwd\n   - **REST API**: POST /api/pulse/schedules with JSON body\n   - **MCP tools**: `create_schedule` tool (enters `pending_approval` state when created by agents)\n   Show example curl for creating a schedule.\n\n4. **Cron Syntax** — Visual CronVisualBuilder component for building expressions. CronPresets for common patterns (every hour, daily at midnight, weekly, etc.). TimezoneCombobox for timezone selection. Link to crontab.guru for reference.\n\n5. **Run History** — RunHistoryPanel shows past runs with status (success, failure, running, cancelled). Click a run to see details. Runs stored in SQLite (`~/.dork/pulse.db`). Retention pruning keeps database manageable.\n\n6. **Pulse + Relay** — When `DORKOS_RELAY_ENABLED=true`, schedule dispatch publishes to `relay.system.pulse.{scheduleId}` instead of calling AgentManager directly. ClaudeCodeAdapter handles the dispatched message. Benefits: message tracing for scheduled runs, unified delivery metrics.\n\n7. **Configuration** — Table:\n   - `DORKOS_PULSE_ENABLED`: Enable/disable (default: true)\n   - Max concurrent runs: configurable in scheduler service\n   - Approval modes: `pending_approval` for agent-created schedules\n   - Schedule states: `active`, `paused`, `pending_approval`\n\n## Acceptance Criteria\n- Both MDX files exist with valid frontmatter and all specified sections\n- Example commands use correct API paths and ports\n- Fumadocs components used appropriately\n- `npm run build --filter=@dorkos/web` succeeds",
      "activeForm": "Writing Agent Discovery and Pulse Scheduler guides",
      "size": "large",
      "priority": "high",
      "dependencies": ["2.1"],
      "parallelWith": ["3.1", "3.3"]
    },
    {
      "id": "3.3",
      "phase": 3,
      "phaseName": "User Guides",
      "subject": "[relay-release-preparation] [P3] Write Building Relay Adapters and Agent Coordination guides",
      "description": "Create two MDX guide pages for advanced topics and update guides/meta.json.\n\n## File 1: `docs/guides/building-relay-adapters.mdx`\n\nFrontmatter:\n```yaml\n---\ntitle: Building Relay Adapters\ndescription: Create custom adapters to bridge external channels into the Relay message bus.\n---\n```\n\n**Source material:** Adapt key content from `contributing/relay-adapters.md` (internal 22KB guide) for an external audience. Read that file first to understand the adapter interface and patterns.\n\nSections:\n\n1. **What is an Adapter?** — Adapters bridge external systems (Telegram, Slack, webhooks, custom APIs) into Relay's subject-based pub/sub. Each adapter translates between the external protocol and Relay envelopes.\n\n2. **Adapter Interface** — Document the RelayAdapter type. Required methods:\n   - `id`: Unique string identifier\n   - `name`: Human-readable name\n   - `subjectPatterns`: Array of subject patterns this adapter handles (e.g., `relay.external.telegram.*`)\n   - `start(relayCore)`: Initialize adapter, set up subscriptions\n   - `stop()`: Clean shutdown\n   - `deliver(envelope)`: Handle inbound message delivery\n   Show the TypeScript interface definition.\n\n3. **Built-in Adapters Reference** — Brief description of each:\n   - **ClaudeCodeAdapter**: Routes `relay.agent.*` messages to AgentManager sessions. Handles response streaming back to `relay.human.console.*`.\n   - **TelegramAdapter**: Bridges Telegram Bot API. Maps chat IDs to Relay subjects. Requires `TELEGRAM_BOT_TOKEN`.\n   - **WebhookAdapter**: Sends HTTP POST callbacks to configured URLs. Supports retry with exponential backoff.\n\n4. **Creating a Custom Adapter** — Step-by-step walkthrough:\n   - Step 1: Implement the RelayAdapter interface\n   - Step 2: Handle `start()` — subscribe to your subject patterns via `relayCore.subscribe()`\n   - Step 3: Handle `deliver()` — translate Relay envelopes to your external format\n   - Step 4: Handle `stop()` — clean up connections and subscriptions\n   - Step 5: Register via config\n   Include a complete code example of a minimal adapter (e.g., a simple logging adapter).\n\n5. **Plugin Loading** — How adapters are loaded:\n   - Built-in: Bundled with DorkOS, always available\n   - npm packages: Install and reference in config\n   - Local file paths: Point to a `.js` file exporting a factory function\n   - `~/.dork/relay/adapters.json` config format\n\n6. **Configuration** — `~/.dork/relay/adapters.json` format:\n   ```json\n   {\n     \"adapters\": [\n       { \"type\": \"builtin\", \"id\": \"claude-code\" },\n       { \"type\": \"npm\", \"package\": \"dorkos-adapter-slack\", \"config\": {} },\n       { \"type\": \"local\", \"path\": \"./my-adapter.js\", \"config\": {} }\n     ]\n   }\n   ```\n   Subject prefix conventions: always use `relay.external.{adapterName}.*`.\n\n7. **Testing Adapters** — Mock RelayCore patterns for unit testing. Create a mock that tracks subscribe/publish calls. Integration testing with a real RelayCore instance.\n\n## File 2: `docs/guides/agent-coordination.mdx`\n\nFrontmatter:\n```yaml\n---\ntitle: Agent Coordination Patterns\ndescription: Best practices for multi-agent workflows using Relay and Mesh.\n---\n```\n\nSections:\n\n1. **Overview** — Why coordinate agents: complex tasks benefit from specialization. When to use patterns: single agent is insufficient, tasks are decomposable, agents have different capabilities. Prerequisites: Relay and Mesh both enabled.\n\n2. **Supervisor-Worker** — Pattern: one supervisor agent dispatches sub-tasks to worker agents. Supervisor publishes to `relay.agent.{workerId}` with task payload. Workers reply to `replyTo` subject. Supervisor aggregates results. Use case: research tasks where one agent coordinates web search, summarization, and writing agents.\n\n3. **Peer-to-Peer** — Pattern: agents communicate directly via known subjects. No central coordinator. Each agent subscribes to its own subject and publishes to peers. Use case: collaborative editing where agents work on different sections.\n\n4. **Broadcast Coordination** — Pattern: one agent publishes to a wildcard subject, all matching subscribers receive. Use case: announcements, configuration updates, \"stop all work\" signals. Budget management critical here (set `maxHops: 1` to prevent loops).\n\n5. **Budget Management** — Preventing runaway loops with envelope budgets:\n   - `maxHops`: Maximum forwarding hops (default: 5). Prevents infinite routing loops.\n   - `maxReplies`: Maximum reply chain depth (default: 3). Prevents conversation explosion.\n   - `ttlMs`: Time-to-live in milliseconds (default: 300000 / 5 min). Prevents stale message delivery.\n   Best practices: start conservative, increase as needed. Monitor via Relay metrics.\n\n## File 3: Update `docs/guides/meta.json`\n\nRead the current file first. Add the 6 new guide slugs to the pages array:\n\n```json\n{\n  \"title\": \"Guides\",\n  \"pages\": [\n    \"cli-usage\",\n    \"obsidian-plugin\",\n    \"tool-approval\",\n    \"slash-commands\",\n    \"keyboard-shortcuts\",\n    \"tunnel-setup\",\n    \"relay-messaging\",\n    \"agent-discovery\",\n    \"pulse-scheduler\",\n    \"relay-observability\",\n    \"building-relay-adapters\",\n    \"agent-coordination\"\n  ]\n}\n```\n\nVerify the existing entries first and preserve them; only append the new ones.\n\n## Acceptance Criteria\n- Both MDX files exist with valid frontmatter and all specified sections\n- `building-relay-adapters.mdx` includes a complete code example of a custom adapter\n- `agent-coordination.mdx` includes concrete use cases for each pattern\n- `docs/guides/meta.json` includes all 12 pages (6 existing + 6 new)\n- `npm run build --filter=@dorkos/web` succeeds",
      "activeForm": "Writing adapter and coordination guides and updating meta.json",
      "size": "large",
      "priority": "high",
      "dependencies": ["2.1"],
      "parallelWith": ["3.1", "3.2"]
    },
    {
      "id": "4.1",
      "phase": 4,
      "phaseName": "Integration Updates",
      "subject": "[relay-release-preparation] [P4] Update SSE protocol docs, docs landing page, and configuration guide",
      "description": "Update three existing documentation files to incorporate Relay and Mesh content.\n\n## File 1: SSE Protocol Update\n\n**File:** `docs/integrations/sse-protocol.mdx`\n\nRead the file first to understand its current structure.\n\nAdd a new \"Relay Events\" section after the existing \"Control Events\" TypeTable. Insert this MDX content:\n\n```mdx\n### Relay Events\n\nWhen `DORKOS_RELAY_ENABLED` is true, the SSE stream includes additional event types:\n\n<TypeTable type={{\n  \"relay_message\": { type: \"{ streamEvent: StreamEvent, messageId: string }\", description: \"Relay response chunk containing a nested StreamEvent from the message bus\" },\n  \"relay_receipt\": { type: \"{ messageId: string, traceId: string }\", description: \"Delivery confirmation for a Relay-routed message\" },\n  \"message_delivered\": { type: \"{ messageId: string, subject: string }\", description: \"Message delivery notification from the Relay transport\" },\n}} />\n```\n\nAlso add a note in the Session Sync Protocol section (find the sync events section):\n\n```mdx\n<Callout type=\"info\">\n  When Relay is enabled, the SSE stream also carries `relay_message`, `relay_receipt`, and `message_delivered` events alongside standard sync events.\n</Callout>\n```\n\n## File 2: Documentation Landing Page\n\n**File:** `docs/index.mdx`\n\nRead the file first to understand its current structure and where cards are grouped.\n\nIn the \"Guides\" Cards section, add after existing cards:\n```mdx\n<Card title=\"Relay Messaging\" href=\"/docs/guides/relay-messaging\">\n  Send messages between agents via subject-based pub/sub.\n</Card>\n<Card title=\"Agent Discovery\" href=\"/docs/guides/agent-discovery\">\n  Register, discover, and monitor agents with Mesh.\n</Card>\n<Card title=\"Pulse Scheduler\" href=\"/docs/guides/pulse-scheduler\">\n  Autonomous cron-based agent jobs.\n</Card>\n```\n\nIn the \"Concepts\" Cards section, add:\n```mdx\n<Card title=\"Relay\" href=\"/docs/concepts/relay\">\n  The subject-based pub/sub message bus architecture.\n</Card>\n<Card title=\"Mesh\" href=\"/docs/concepts/mesh\">\n  Agent discovery, registry, and network topology.\n</Card>\n```\n\nIn the \"Integrations\" Cards section, add:\n```mdx\n<Card title=\"Building Relay Adapters\" href=\"/docs/guides/building-relay-adapters\">\n  Create custom adapters for external channels.\n</Card>\n```\n\n## File 3: Configuration Guide\n\n**File:** `docs/getting-started/configuration.mdx`\n\nRead the file first. Add two new subsections in the environment variables area:\n\n**Relay Configuration:**\n```mdx\n### Relay\n\n| Variable | Default | Description |\n|----------|---------|-------------|\n| `DORKOS_RELAY_ENABLED` | `false` | Enable the Relay message bus for inter-agent communication |\n\nWhen enabled, Relay provides subject-based pub/sub messaging between agents, humans, and external systems. Adapter configuration lives in `~/.dork/config.json` under the `relay` key. See the [Relay Messaging guide](/docs/guides/relay-messaging) for setup details.\n```\n\n**Mesh Configuration:**\n```mdx\n### Mesh\n\n| Variable | Default | Description |\n|----------|---------|-------------|\n| `DORKOS_MESH_ENABLED` | `false` | Enable agent discovery and registry |\n\nWhen enabled, Mesh provides agent discovery, health monitoring, and network topology visualization. See the [Agent Discovery guide](/docs/guides/agent-discovery) for setup details.\n```\n\n## Acceptance Criteria\n- SSE protocol page has Relay Events TypeTable and Callout note\n- Landing page has 6 new Card components pointing to correct hrefs\n- Configuration page has Relay and Mesh env var sections\n- All internal links use correct `/docs/` paths\n- `npm run build --filter=@dorkos/web` succeeds",
      "activeForm": "Updating SSE protocol docs, landing page, and configuration guide",
      "size": "medium",
      "priority": "high",
      "dependencies": ["3.1", "3.2", "3.3"],
      "parallelWith": []
    },
    {
      "id": "5.1",
      "phase": 5,
      "phaseName": "Project Files",
      "subject": "[relay-release-preparation] [P5] Update README, CONTRIBUTING, and contributing/architecture docs",
      "description": "Update three project-level files to reflect Relay and Mesh availability.\n\n## File 1: README.md\n\n**File:** `README.md` (repo root)\n\nRead the file first. Make two changes:\n\n1. **Update the \"What is DorkOS?\" paragraph** — Find the introductory paragraph and update it to mention multi-agent coordination. The new text should include:\n   ```\n   DorkOS gives Claude Code a browser-based chat UI with tool approval flows, slash command discovery, cross-client session synchronization, inter-agent messaging via Relay, and agent discovery via Mesh.\n   ```\n   Locate the existing description and replace/extend it with this wording.\n\n2. **Add to the Features list** — Find the features list (likely a markdown bullet list) and add:\n   ```markdown\n   - Relay message bus for inter-agent communication (subject-based pub/sub)\n   - Mesh agent discovery with network topology visualization\n   - Pulse scheduler for autonomous cron-based agent jobs\n   ```\n   Add these after the existing feature bullets.\n\n## File 2: CONTRIBUTING.md\n\n**File:** `CONTRIBUTING.md` (repo root)\n\nRead the file first. Make three changes:\n\n1. **Update app count** — Find the intro paragraph that says \"four apps\" and change it to \"five apps\".\n\n2. **Add roadmap row** — Find the monorepo structure table and add a row for apps/roadmap:\n   ```\n   | `apps/roadmap` | `@dorkos/roadmap` | Roadmap manager (Express + React 19 SPA) |\n   ```\n\n3. **Add Subsystems section** — After the monorepo structure table, add:\n   ```markdown\n   ### Subsystems\n\n   DorkOS includes three optional subsystems that extend the core platform:\n\n   | Subsystem | Enable | Description |\n   |-----------|--------|-------------|\n   | Pulse | `DORKOS_PULSE_ENABLED=true` (default) | Cron-based agent scheduling |\n   | Relay | `DORKOS_RELAY_ENABLED=true` | Inter-agent message bus |\n   | Mesh | `DORKOS_MESH_ENABLED=true` | Agent discovery and registry |\n\n   Server-side services live in `apps/server/src/services/`. Shared schemas in `packages/shared/src/` (`relay-schemas.ts`, `mesh-schemas.ts`). Client UI in `apps/client/src/layers/features/`.\n   ```\n\n## File 3: contributing/architecture.md\n\n**File:** `contributing/architecture.md`\n\nRead the file first. Add or expand two sections:\n\n1. **Relay Subsystem** — Find any existing mention of Relay and expand it with:\n   - RelayCore architecture: in-process message router, subject-based routing, subscriber registry\n   - Data flow: publish -> RelayCore.route() -> subscriber.deliver() -> adapter.handle()\n   - Service map: `relay-state.ts` (feature flag), `trace-store.ts` (SQLite traces), `adapter-manager.ts` (adapter lifecycle)\n   - Route group: `routes/relay.ts` with 14+ endpoints (messages, endpoints, inbox, dead-letters, metrics, stream, traces)\n   - Client features: `features/relay/` (RelayPanel, ActivityFeed, MessageRow, EndpointList, InboxView, MessageTrace, DeliveryMetricsDashboard)\n\n2. **Mesh Subsystem** (likely a new section):\n   - MeshCore architecture: agent registry, discovery engine, health monitor\n   - Service map: `mesh-state.ts` (feature flag), `mesh/` directory (core, store, health)\n   - Route group: `routes/mesh.ts` with 8+ endpoints (discover, agents CRUD, deny, denied, status, health, heartbeat)\n   - Client features: `features/mesh/` (MeshPanel, CandidateCard, AgentCard, RegisterAgentDialog, TopologyGraph, AgentNode, MeshStatsHeader, AgentHealthDetail)\n\n## Acceptance Criteria\n- README mentions Relay, Mesh, and Pulse in both intro paragraph and features list\n- CONTRIBUTING.md says \"five apps\", has roadmap row, and has Subsystems section\n- contributing/architecture.md has substantive Relay and Mesh subsystem sections\n- No broken markdown formatting",
      "activeForm": "Updating README, CONTRIBUTING, and architecture docs",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["1.1"],
      "parallelWith": []
    },
    {
      "id": "6.1",
      "phase": 6,
      "phaseName": "Marketing",
      "subject": "[relay-release-preparation] [P6] Write release blog post draft",
      "description": "Create a blog post draft for the upcoming release.\n\n## File: `blog/dorkos-[VERSION].mdx`\n\nUse the literal filename `blog/dorkos-VERSION.mdx` (the `[VERSION]` and `[DATE]` placeholders will be filled in during `/system:release`).\n\nFirst, check if a `blog/` directory exists at the repo root. If not, create the file at the repo root level.\n\nFrontmatter:\n```yaml\n---\ntitle: DorkOS [VERSION]\ndescription: Relay message bus and Mesh agent discovery bring multi-agent coordination to DorkOS.\ndate: \"[DATE]\"\nauthor: DorkOS Team\ncategory: release\ntags: [release, relay, mesh, messaging, agent-discovery, topology]\n---\n```\n\nContent structure (write substantive content for each section, not just headers):\n\n1. **Intro** — DorkOS [VERSION] introduces two major subsystems: Relay and Mesh. Together they transform DorkOS from a single-agent interface into a multi-agent coordination platform. This release also includes Pulse scheduler improvements and numerous bug fixes.\n\n2. **Relay Message Bus** — Subject-based pub/sub message routing. Built-in adapters for Claude Code (agent sessions), Telegram (bot API bridge), and Webhooks (HTTP callbacks). Full message tracing with span-level visibility. Delivery metrics dashboard for monitoring throughput and success rates. Session messaging and Pulse dispatch converge through Relay when enabled.\n\n3. **Mesh Agent Discovery** — Agent registry with manifest-based discovery. Network topology visualization with force-directed graph layout. Live health data overlays showing agent states (healthy, degraded, unreachable). Heartbeat-based health monitoring. Access control with denial lists and reason tracking. Lifecycle event streaming.\n\n4. **Relay Convergence** — When Relay is enabled, two existing systems are unified through the message bus: session messaging (POST /messages publishes to Relay instead of direct AgentManager calls) and Pulse dispatch (scheduled jobs publish to `relay.system.pulse.*`). This provides end-to-end message tracing across all agent interactions.\n\n5. **All Changes** — Add a placeholder: `<!-- Mirror CHANGELOG [Unreleased] content here during release -->`\n\n6. **Install / Update** — Instructions:\n   ```\n   npm install -g dorkos@[VERSION]\n   ```\n   Or update existing installation:\n   ```\n   npm update -g dorkos\n   ```\n\nDo NOT use real API keys or tokens in any examples. Use placeholder values like `your-bot-token-here`.\n\n## Acceptance Criteria\n- Blog post MDX file exists with valid frontmatter\n- All 6 sections have substantive content (not just headers)\n- Placeholder markers `[VERSION]` and `[DATE]` are used consistently\n- No real credentials or tokens in examples\n- CHANGELOG section has a clear placeholder comment for release-time fill",
      "activeForm": "Writing release blog post draft",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["1.1"],
      "parallelWith": ["5.1"]
    },
    {
      "id": "7.1",
      "phase": 7,
      "phaseName": "Verification",
      "subject": "[relay-release-preparation] [P7] Verify API docs export and cross-link integrity",
      "description": "Final verification pass to ensure all documentation is consistent and builds correctly.\n\n## 1. API Documentation Verification\n\nRun `npm run docs:export-api` to regenerate the OpenAPI spec at `docs/api/openapi.json`.\n\nAfter generation, verify the output includes:\n- All 14+ Relay endpoints: messages (POST, GET), endpoints (GET, POST, DELETE), inbox (GET), dead-letters (GET), metrics (GET), stream (GET SSE), traces\n- All 8+ Mesh endpoints: discover (POST), agents (POST, GET, PATCH, DELETE), deny (POST), denied (GET, DELETE), status (GET), health (GET /agents/:id/health), heartbeat (POST /agents/:id/heartbeat)\n- Request/response schemas matching the Zod definitions in `packages/shared/src/relay-schemas.ts` and `packages/shared/src/mesh-schemas.ts`\n\nIf any endpoints are missing, check that the routes are registered with `openapi-registry.ts` in `apps/server/src/services/openapi-registry.ts`.\n\n## 2. Cross-Link Verification\n\nCheck all internal links in the new MDX files point to valid pages:\n\n- `docs/concepts/relay.mdx` — links to guides\n- `docs/concepts/mesh.mdx` — links to guides\n- `docs/guides/relay-messaging.mdx` — links to concepts/relay, guides/relay-observability\n- `docs/guides/agent-discovery.mdx` — links to concepts/mesh\n- `docs/guides/relay-observability.mdx` — links to guides/relay-messaging\n- `docs/guides/pulse-scheduler.mdx` — links to guides/relay-messaging\n- `docs/guides/building-relay-adapters.mdx` — links to concepts/relay\n- `docs/guides/agent-coordination.mdx` — links to concepts/relay, concepts/mesh\n- `docs/index.mdx` — all Card hrefs point to existing pages\n- `docs/getting-started/configuration.mdx` — links to guide pages\n\nUse grep to find all `href=` and markdown links `](/docs/` in the new files and verify each target exists.\n\n## 3. Build Verification\n\nRun these commands and verify they all succeed:\n- `npm run build` — full monorepo build (catches MDX syntax errors, broken imports, TS issues)\n- `npm run typecheck` — type-check all packages\n\n## 4. meta.json Consistency\n\nVerify that every new MDX file has a corresponding entry in its section's `meta.json`:\n- `docs/concepts/meta.json` includes `relay` and `mesh`\n- `docs/guides/meta.json` includes all 6 new guide slugs\n\n## Acceptance Criteria\n- `npm run docs:export-api` completes without errors\n- OpenAPI spec includes Relay and Mesh endpoints\n- All cross-links in new MDX files point to existing pages\n- `npm run build` succeeds\n- `npm run typecheck` passes\n- All meta.json files are consistent with the MDX files created",
      "activeForm": "Verifying API docs and cross-link integrity",
      "size": "medium",
      "priority": "high",
      "dependencies": ["4.1", "5.1", "6.1"],
      "parallelWith": []
    }
  ]
}
