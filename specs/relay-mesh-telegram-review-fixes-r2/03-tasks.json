{
  "spec": "specs/relay-mesh-telegram-review-fixes-r2/02-specification.md",
  "slug": "relay-mesh-telegram-review-fixes-r2",
  "generatedAt": "2026-02-28T21:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Telegram Adapter Fixes",
      "subject": "[relay-mesh-telegram-review-fixes-r2] [P1] Fix reconnection bot leak and timer cancellation (C1, C2)",
      "description": "Fix two critical bugs in the Telegram adapter reconnection logic in `packages/relay/src/adapters/telegram-adapter.ts`.\n\n## Problem\n\n**C1 (Critical):** `handlePollingError()` creates a new `Bot` instance and assigns it to `this.bot` (line 521) without first calling `this.bot.stop()` on the old one. This leaks the previous grammy polling loop.\n\n**C2 (Critical):** The `setTimeout` return value from `handlePollingError()` is discarded. If `stop()` is called during the delay window, the timer fires after the adapter is stopped and creates a zombie polling loop. Additionally, the reconnect guard only checks `'disconnected'` but `stop()` transitions through `'stopping'` first.\n\n## Implementation\n\n### Step 1: Add class field for reconnect timer\n\nAdd a new private field to the TelegramAdapter class:\n\n```typescript\n/** Pending reconnection timer — cleared in stop(). */\nprivate reconnectTimer: ReturnType<typeof setTimeout> | null = null;\n```\n\n### Step 2: Update `handlePollingError()` reconnection path (lines 512-524)\n\nReplace the existing `setTimeout` block:\n\n**Before:**\n```typescript\nsetTimeout(() => {\n  // If the adapter was stopped externally, do not reconnect\n  if (this.status.state === 'disconnected') return;\n\n  // Create a fresh bot instance for the reconnection attempt\n  const newBot = new Bot(this.config.token);\n  newBot.api.config.use(autoRetry());\n  newBot.on('message', (ctx) => this.handleInboundMessage(ctx));\n  newBot.catch((e) => this.recordError(e));\n  this.bot = newBot;\n\n  this.startPollingMode(newBot).catch((e) => this.handlePollingError(e));\n}, delay);\n```\n\n**After:**\n```typescript\nthis.reconnectTimer = setTimeout(async () => {\n  // If the adapter was stopped externally or is stopping, do not reconnect\n  if (this.status.state === 'disconnected' || this.status.state === 'stopping') return;\n\n  // Stop the old bot before creating a replacement\n  try {\n    await this.bot?.stop();\n  } catch {\n    // Swallow — old bot is likely already dead\n  }\n\n  // Create a fresh bot instance for the reconnection attempt\n  const newBot = new Bot(this.config.token);\n  newBot.api.config.use(autoRetry());\n  newBot.on('message', (ctx) => this.handleInboundMessage(ctx));\n  newBot.catch((e) => this.recordError(e));\n  this.bot = newBot;\n\n  this.startPollingMode(newBot).catch((e) => this.handlePollingError(e));\n}, delay);\n```\n\nKey changes: (a) assign timer to `this.reconnectTimer`, (b) make callback `async`, (c) add `'stopping'` state check, (d) call `this.bot?.stop()` before creating new bot.\n\n### Step 3: Update `stop()` method (lines 345-369) — add timer cancellation before unsubscribing signals\n\nInsert timer cancellation after the early-return guard but before unsubscribing signals:\n\n```typescript\nasync stop(): Promise<void> {\n  if (this.bot === null) return; // Already stopped\n\n  this.status = { ...this.status, state: 'stopping' };\n\n  // Cancel any pending reconnection timer\n  if (this.reconnectTimer) {\n    clearTimeout(this.reconnectTimer);\n    this.reconnectTimer = null;\n  }\n\n  // Unsubscribe from relay signals before stopping the bot\n  // ... rest unchanged\n```\n\n## Tests\n\nAdd tests in `packages/relay/src/__tests__/adapters/telegram-adapter.test.ts`:\n\n1. **\"Reconnection stops old bot before creating a new one\"** — Set up adapter, trigger `handlePollingError`, verify `bot.stop()` is called on old bot before new bot is created.\n2. **\"`stop()` clears pending reconnect timer\"** — Trigger reconnection, call `stop()` during the delay window, verify timer is cleared and no new bot is created.\n3. **\"Reconnect timer does not fire after `stop()` is called\"** — Trigger reconnection, call `stop()`, advance timers past the reconnect delay, verify no polling loop is started.\n\n## Acceptance Criteria\n\n- Old bot's `stop()` is called before a new bot instance replaces it\n- `reconnectTimer` field exists and is assigned the setTimeout return value\n- `stop()` calls `clearTimeout(this.reconnectTimer)` and nulls the field\n- Reconnect guard checks both `'disconnected'` and `'stopping'` states\n- All existing Telegram adapter tests continue to pass\n- New tests verify the reconnection and timer cancellation behavior",
      "activeForm": "Fixing reconnection bot leak and timer cancellation",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.2", "1.3"]
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Telegram Adapter Fixes",
      "subject": "[relay-mesh-telegram-review-fixes-r2] [P1] Fix webhook error handler leak and connection cleanup (I1, I2)",
      "description": "Fix two important bugs in the Telegram adapter webhook server lifecycle in `packages/relay/src/adapters/telegram-adapter.ts`.\n\n## Problem\n\n**I1 (Important):** `server.on('error', reject)` (line 563-566) registers a persistent error handler that is never removed. After the server starts successfully, subsequent `'error'` events invoke a stale `reject` on a resolved promise.\n\n**I2 (Important):** `server.close()` (lines 572-579) only stops accepting new connections. Existing keep-alive connections (Telegram may reuse connections) keep the server alive indefinitely.\n\n## Implementation\n\n### Step 1: Fix webhook error handler (I1)\n\nIn the webhook server startup promise, change `server.on('error', reject)` to `server.once('error', reject)`.\n\n**Before:**\n```typescript\nawait new Promise<void>((resolve, reject) => {\n  server.listen(port, resolve);\n  server.on('error', reject);\n});\n```\n\n**After:**\n```typescript\nawait new Promise<void>((resolve, reject) => {\n  server.listen(port, resolve);\n  server.once('error', reject);\n});\n```\n\nUsing `once` ensures the handler is automatically removed after the first error event fires (or after the server starts successfully and no error occurs during listen).\n\n### Step 2: Destroy keep-alive connections in `stopWebhookServer` (I2)\n\n**Before:**\n```typescript\nprivate async stopWebhookServer(): Promise<void> {\n  if (!this.webhookServer) return;\n  const server = this.webhookServer;\n  this.webhookServer = null;\n  await new Promise<void>((resolve, reject) => {\n    server.close((err) => (err ? reject(err) : resolve()));\n  });\n}\n```\n\n**After:**\n```typescript\nprivate async stopWebhookServer(): Promise<void> {\n  if (!this.webhookServer) return;\n  const server = this.webhookServer;\n  this.webhookServer = null;\n\n  // Destroy keep-alive connections so close() completes promptly\n  server.closeAllConnections();\n\n  await new Promise<void>((resolve, reject) => {\n    server.close((err) => (err ? reject(err) : resolve()));\n  });\n}\n```\n\n`server.closeAllConnections()` (Node.js 18.2+) sends RST to all tracked connections, allowing `close()` to complete immediately.\n\n## Tests\n\nAdd tests in `packages/relay/src/__tests__/adapters/telegram-adapter.test.ts`:\n\n1. **\"Webhook server uses `once` for error handler\"** — Verify that the error handler is registered with `once` (not `on`), so it auto-removes after first fire.\n2. **\"`stopWebhookServer` calls `closeAllConnections()` before `close()`\"** — Mock the webhook server object, call stop, verify `closeAllConnections()` is called before `close()`.\n\n## Acceptance Criteria\n\n- Webhook startup uses `server.once('error', reject)` instead of `server.on('error', reject)`\n- `stopWebhookServer` calls `server.closeAllConnections()` before `server.close()`\n- All existing Telegram adapter tests continue to pass\n- New tests verify both behaviors",
      "activeForm": "Fixing webhook error handler leak and connection cleanup",
      "size": "small",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["1.1", "1.3"]
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Telegram Adapter Fixes",
      "subject": "[relay-mesh-telegram-review-fixes-r2] [P1] Reject float chat IDs in extractChatId (I3)",
      "description": "Fix `extractChatId()` in `packages/relay/src/adapters/telegram-adapter.ts` to reject float values. Telegram chat IDs are always integers.\n\n## Problem\n\n**I3 (Important):** `extractChatId()` (lines 80-96) accepts floats like `123.456` because `Number.isFinite()` passes for them.\n\n## Implementation\n\nReplace `Number.isFinite(id)` with `Number.isInteger(id)` in both the group format and DM format branches.\n\n**Before (lines 89-95):**\n```typescript\n// Group format: group.{chatId}\nif (remainder.startsWith(`${GROUP_SEGMENT}.`)) {\n  const idStr = remainder.slice(GROUP_SEGMENT.length + 1);\n  const id = Number(idStr);\n  return Number.isFinite(id) ? id : null;\n}\n\n// DM format: {chatId}\nconst id = Number(remainder);\nreturn Number.isFinite(id) ? id : null;\n```\n\n**After:**\n```typescript\n// Group format: group.{chatId}\nif (remainder.startsWith(`${GROUP_SEGMENT}.`)) {\n  const idStr = remainder.slice(GROUP_SEGMENT.length + 1);\n  const id = Number(idStr);\n  return Number.isInteger(id) ? id : null;\n}\n\n// DM format: {chatId}\nconst id = Number(remainder);\nreturn Number.isInteger(id) ? id : null;\n```\n\n## Tests\n\nAdd tests in `packages/relay/src/__tests__/adapters/telegram-adapter.test.ts`:\n\n1. **\"`extractChatId` rejects float values like `123.456`\"** — Call `extractChatId` with a DM-format subject containing `123.456`, verify it returns `null`.\n2. **\"`extractChatId` rejects float values in group format\"** — Call `extractChatId` with a group-format subject containing `group.123.456`, verify it returns `null`.\n3. Verify that valid integer chat IDs (positive, negative for groups) still work correctly.\n\n## Acceptance Criteria\n\n- `extractChatId` returns `null` for float chat IDs in both DM and group format\n- `extractChatId` continues to return valid integers for proper chat IDs\n- All existing `extractChatId` tests continue to pass",
      "activeForm": "Rejecting float chat IDs in extractChatId",
      "size": "small",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["1.1", "1.2"]
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "Relay Subsystem Fixes",
      "subject": "[relay-mesh-telegram-review-fixes-r2] [P2] Fix BindingStore skipNextReload race with generation counter (C3)",
      "description": "Fix a race condition in `apps/server/src/services/relay/binding-store.ts` where the `skipNextReload` boolean flag is consumed by the wrong chokidar event during rapid successive saves.\n\n## Problem\n\n**C3 (Critical):** The `skipNextReload` boolean flag is consumed by the first chokidar `'change'` event regardless of whether it corresponds to the save that set it. If two rapid saves overlap, the first chokidar event consumes the flag and the second triggers a spurious reload.\n\n## Implementation\n\nReplace the boolean flag with a generation counter system.\n\n### Step 1: Replace class fields (lines 43-44)\n\n**Before:**\n```typescript\n/** Guard to skip reload when we just wrote the file ourselves. */\nprivate skipNextReload = false;\n```\n\n**After:**\n```typescript\n/**\n * Generation counter for skip-reload coordination.\n * Incremented on each save; chokidar handler skips reload when it\n * sees a generation it hasn't processed yet from our own writes.\n */\nprivate saveGeneration = 0;\nprivate lastReloadedGeneration = 0;\n```\n\n### Step 2: Update `save()` method (lines 181-205)\n\n**Before:**\n```typescript\nprivate async save(): Promise<void> {\n  this.skipNextReload = true;\n  const data = { bindings: this.getAll() };\n  await mkdir(dirname(this.filePath), { recursive: true });\n  const tmpPath = `${this.filePath}.tmp`;\n  await writeFile(tmpPath, JSON.stringify(data, null, 2), 'utf-8');\n  await rename(tmpPath, this.filePath);\n}\n```\n\n**After:**\n```typescript\nprivate async save(): Promise<void> {\n  this.saveGeneration++;\n  const data = { bindings: this.getAll() };\n  await mkdir(dirname(this.filePath), { recursive: true });\n  const tmpPath = `${this.filePath}.tmp`;\n  await writeFile(tmpPath, JSON.stringify(data, null, 2), 'utf-8');\n  await rename(tmpPath, this.filePath);\n}\n```\n\n### Step 3: Update `watch()` method chokidar handler\n\n**Before:**\n```typescript\nthis.watcher.on('change', async () => {\n  if (this.skipNextReload) {\n    this.skipNextReload = false;\n    return;\n  }\n  logger.info('bindings.json changed on disk, reloading');\n  await this.load();\n});\n```\n\n**After:**\n```typescript\nthis.watcher.on('change', async () => {\n  if (this.lastReloadedGeneration < this.saveGeneration) {\n    // This change was triggered by our own save — skip reload\n    this.lastReloadedGeneration = this.saveGeneration;\n    return;\n  }\n  logger.info('bindings.json changed on disk, reloading');\n  await this.load();\n});\n```\n\nThis is safe because: (1) generation only increases, (2) each save bumps it by exactly 1, and (3) the chokidar handler catches up to the current generation on each own-write event.\n\n## Tests\n\nAdd test in `apps/server/src/services/relay/__tests__/binding-store.test.ts` (new or existing):\n\n1. **\"Rapid successive saves do not trigger spurious reloads\"** — Call `save()` twice in rapid succession, verify that neither chokidar change event triggers a `load()` call, confirming the generation counter correctly skips both events.\n\n## Acceptance Criteria\n\n- `skipNextReload` boolean is replaced with `saveGeneration` and `lastReloadedGeneration` counters\n- `save()` increments `saveGeneration` before writing\n- Chokidar handler compares `lastReloadedGeneration < saveGeneration` to decide whether to skip\n- Rapid successive saves do not trigger spurious reloads\n- External file changes (not from our saves) still trigger reloads correctly",
      "activeForm": "Fixing BindingStore skipNextReload race condition",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["2.2", "2.3"]
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "Relay Subsystem Fixes",
      "subject": "[relay-mesh-telegram-review-fixes-r2] [P2] Prevent duplicate dispatch between DeliveryPipeline and WatcherManager (C4)",
      "description": "Fix a race condition where both `DeliveryPipeline.dispatchToSubscribers()` and `WatcherManager.handleNewMessage()` attempt to claim and dispatch the same message.\n\n## Problem\n\n**C4 (Critical):** When `DeliveryPipeline.dispatchToSubscribers()` claims and dispatches a message, the file move from `new/` to `cur/` may trigger `WatcherManager.handleNewMessage()` before the claim completes, causing a race where both attempt to claim the same message. While `claim()` is atomic (only one succeeds), handler side effects may not be idempotent, and the failed claim generates unnecessary I/O.\n\n## Implementation\n\nThree files need changes: `packages/relay/src/delivery-pipeline.ts`, `packages/relay/src/watcher-manager.ts`, and `packages/relay/src/relay-core.ts`.\n\n### Step 1: Add `recentlyDispatched` set to `DeliveryPipeline` (`delivery-pipeline.ts`)\n\nAdd a private `Set<string>` and a public `wasDispatched()` method:\n\n```typescript\nexport class DeliveryPipeline {\n  /** Message IDs recently dispatched via the synchronous fast-path. */\n  private readonly recentlyDispatched = new Set<string>();\n\n  // ... existing constructor ...\n\n  /** Check whether a message was already dispatched by this pipeline. */\n  wasDispatched(messageId: string): boolean {\n    return this.recentlyDispatched.has(messageId);\n  }\n\n  async dispatchToSubscribers(\n    endpoint: EndpointInfo,\n    messageId: string,\n    envelope: RelayEnvelope,\n  ): Promise<void> {\n    const handlers = this.deps.subscriptionRegistry.getSubscribers(endpoint.subject);\n    if (handlers.length === 0) return;\n\n    // Mark as dispatched before claiming so the watcher can skip it\n    this.recentlyDispatched.add(messageId);\n\n    // Cap the set size to prevent unbounded growth\n    if (this.recentlyDispatched.size > 10_000) {\n      const oldest = this.recentlyDispatched.values().next().value;\n      if (oldest) this.recentlyDispatched.delete(oldest);\n    }\n\n    // Claim the message (move from new/ to cur/)\n    const claimResult = await this.deps.maildirStore.claim(endpoint.hash, messageId);\n    if (!claimResult.ok) return;\n    // ... rest unchanged\n  }\n}\n```\n\n### Step 2: Update `WatcherManager` constructor and `handleNewMessage` (`watcher-manager.ts`)\n\nAccept an optional `wasDispatched` callback in the constructor to avoid circular dependency:\n\n```typescript\nexport class WatcherManager {\n  private readonly watchers = new Map<string, FSWatcher>();\n\n  constructor(\n    private readonly maildirStore: MaildirStore,\n    private readonly subscriptionRegistry: SubscriptionRegistry,\n    private readonly sqliteIndex: SqliteIndex,\n    private readonly circuitBreaker: CircuitBreakerManager,\n    private readonly wasDispatched?: (messageId: string) => boolean,\n  ) {}\n\n  // In handleNewMessage():\n  private async handleNewMessage(endpoint: EndpointInfo, filePath: string): Promise<void> {\n    const filename = path.basename(filePath);\n    if (!filename.endsWith('.json')) return;\n    const messageId = filename.slice(0, -5);\n\n    // Skip messages already dispatched by the synchronous pipeline fast-path\n    if (this.wasDispatched?.(messageId)) return;\n\n    // ... rest unchanged\n  }\n}\n```\n\n### Step 3: Wire up in `relay-core.ts` (line 214-219)\n\nUpdate the `WatcherManager` construction to pass the `wasDispatched` callback:\n\n```typescript\nthis.watcherManager = new WatcherManager(\n  this.maildirStore,\n  this.subscriptionRegistry,\n  this.sqliteIndex,\n  this.circuitBreaker,\n  (messageId) => this.deliveryPipeline.wasDispatched(messageId),\n);\n```\n\n## Tests\n\n**File: `packages/relay/src/__tests__/delivery-pipeline.test.ts`**\n\n1. **\"`wasDispatched()` returns true for pipeline-dispatched message IDs\"** — Call `dispatchToSubscribers()` with a message, verify `wasDispatched()` returns `true` for that message ID.\n2. **\"`recentlyDispatched` set is capped at 10,000 entries\"** — Add 10,001 entries via dispatching, verify the set size is 10,000 (oldest entry was evicted).\n\n**File: `packages/relay/src/__tests__/watcher-manager.test.ts`**\n\n3. **\"`handleNewMessage` skips messages that were already dispatched\"** — Create WatcherManager with a `wasDispatched` callback that returns `true`, trigger `handleNewMessage`, verify the claim step is skipped.\n\n## Acceptance Criteria\n\n- `DeliveryPipeline` tracks dispatched message IDs in a `recentlyDispatched` set\n- Set is capped at 10,000 entries to prevent unbounded memory growth\n- `WatcherManager` accepts an optional `wasDispatched` callback\n- `handleNewMessage` checks `wasDispatched` before attempting to claim\n- `relay-core.ts` wires the callback from `deliveryPipeline.wasDispatched`\n- No duplicate dispatch attempts for pipeline-handled messages",
      "activeForm": "Preventing duplicate dispatch between DeliveryPipeline and WatcherManager",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["2.1", "2.3"]
    },
    {
      "id": "2.3",
      "phase": 2,
      "phaseName": "Relay Subsystem Fixes",
      "subject": "[relay-mesh-telegram-review-fixes-r2] [P2] Add Zod validation to adapter routes, SSE write guards, and sessionMap validation (I4, I5, I6)",
      "description": "Fix three important issues in the Relay server routes and binding router.\n\n## Problem\n\n**I4 (Important):** Three adapter routes in `apps/server/src/routes/relay.ts` (lines 376-444) use `as` type casts on `req.body` instead of Zod validation, violating the project's API validation rule.\n\n**I5 (Important):** The SSE relay stream in `apps/server/src/routes/relay.ts` (lines 303-337) writes to `res` without checking whether the response has already been closed by the client. If the client disconnects between the `req.on('close')` cleanup and the next write, the write throws.\n\n**I6 (Important):** `loadSessionMap()` in `apps/server/src/services/relay/binding-router.ts` (lines 247-256) parses raw JSON and passes it directly to `new Map()` without validating its shape.\n\n## Implementation\n\n### I4: Add Zod schemas and validation to adapter routes\n\n**File:** `apps/server/src/routes/relay.ts`\n\nAdd Zod schemas at the top of the file (or in a local const block):\n\n```typescript\nimport { z } from 'zod';\n\nconst TestAdapterBodySchema = z.object({\n  type: z.string().min(1),\n  config: z.record(z.unknown()),\n});\n\nconst CreateAdapterBodySchema = z.object({\n  type: z.string().min(1),\n  id: z.string().min(1),\n  config: z.record(z.unknown()),\n  enabled: z.boolean().optional(),\n});\n\nconst UpdateAdapterConfigBodySchema = z.object({\n  config: z.record(z.unknown()),\n});\n```\n\nReplace each route handler's body parsing:\n\n**POST `/adapters/test` (line 377-389):**\n```typescript\nrouter.post('/adapters/test', async (req, res) => {\n  const parsed = TestAdapterBodySchema.safeParse(req.body);\n  if (!parsed.success) {\n    return res.status(400).json({ error: 'Validation failed', details: parsed.error.flatten() });\n  }\n  const { type, config } = parsed.data;\n  // ... rest unchanged\n});\n```\n\n**POST `/adapters` (line 392-419):**\n```typescript\nrouter.post('/adapters', async (req, res) => {\n  const parsed = CreateAdapterBodySchema.safeParse(req.body);\n  if (!parsed.success) {\n    return res.status(400).json({ error: 'Validation failed', details: parsed.error.flatten() });\n  }\n  const { type, id, config, enabled } = parsed.data;\n  // ... rest unchanged\n});\n```\n\n**PATCH `/adapters/:id/config` (line 440-444):**\n```typescript\nrouter.patch('/adapters/:id/config', async (req, res) => {\n  const parsed = UpdateAdapterConfigBodySchema.safeParse(req.body);\n  if (!parsed.success) {\n    return res.status(400).json({ error: 'Validation failed', details: parsed.error.flatten() });\n  }\n  const { config } = parsed.data;\n  // ... rest unchanged\n});\n```\n\n### I5: Guard SSE writes with `writableEnded` check\n\n**File:** `apps/server/src/routes/relay.ts`\n\nUpdate the `GET /stream` route handler (lines 303-337) to check `res.writableEnded` before every `res.write()` call:\n\n```typescript\nrouter.get('/stream', (req, res) => {\n  const pattern = (req.query.subject as string) || '>';\n\n  initSSEStream(res);\n\n  res.write(`event: relay_connected\\n`);\n  res.write(`data: ${JSON.stringify({ pattern, connectedAt: new Date().toISOString() })}\\n\\n`);\n\n  const unsubMessages = relayCore.subscribe(pattern, (envelope) => {\n    if (res.writableEnded) return;\n    res.write(`id: ${envelope.id}\\n`);\n    res.write(`event: relay_message\\n`);\n    res.write(`data: ${JSON.stringify(envelope)}\\n\\n`);\n  });\n\n  const unsubSignals = relayCore.onSignal(pattern, (_subject, signal) => {\n    if (res.writableEnded) return;\n    const eventType = signal.type === 'backpressure' ? 'relay_backpressure' : 'relay_signal';\n    res.write(`event: ${eventType}\\n`);\n    res.write(`data: ${JSON.stringify(signal)}\\n\\n`);\n  });\n\n  const keepalive = setInterval(() => {\n    if (res.writableEnded) {\n      clearInterval(keepalive);\n      return;\n    }\n    res.write(`: keepalive\\n\\n`);\n  }, 15_000);\n\n  req.on('close', () => {\n    clearInterval(keepalive);\n    unsubMessages();\n    unsubSignals();\n  });\n});\n```\n\n### I6: Validate `sessionMap` JSON shape\n\n**File:** `apps/server/src/services/relay/binding-router.ts`\n\nReplace `loadSessionMap()` (lines 247-256):\n\n**Before:**\n```typescript\nprivate async loadSessionMap(): Promise<void> {\n  try {\n    const raw = await readFile(this.sessionMapPath, 'utf-8');\n    const entries: [string, string][] = JSON.parse(raw);\n    this.sessionMap = new Map(entries);\n  } catch {\n    // File doesn't exist yet or is invalid — start fresh\n    this.sessionMap = new Map();\n  }\n}\n```\n\n**After:**\n```typescript\nprivate async loadSessionMap(): Promise<void> {\n  try {\n    const raw = await readFile(this.sessionMapPath, 'utf-8');\n    const parsed: unknown = JSON.parse(raw);\n\n    // Validate shape: must be an array of [string, string] tuples\n    if (!Array.isArray(parsed)) {\n      console.warn('BindingRouter: sessionMap is not an array, starting fresh');\n      this.sessionMap = new Map();\n      return;\n    }\n\n    const valid = parsed.filter(\n      (entry): entry is [string, string] =>\n        Array.isArray(entry) &&\n        entry.length === 2 &&\n        typeof entry[0] === 'string' &&\n        typeof entry[1] === 'string',\n    );\n\n    if (valid.length < parsed.length) {\n      console.warn(\n        `BindingRouter: discarded ${parsed.length - valid.length} malformed sessionMap entries`,\n      );\n    }\n\n    this.sessionMap = new Map(valid);\n  } catch {\n    // File doesn't exist yet or JSON parse error — start fresh\n    this.sessionMap = new Map();\n  }\n}\n```\n\n## Tests\n\n**File: `apps/server/src/services/relay/__tests__/binding-router.test.ts`**\n\n1. **\"`loadSessionMap` discards non-array JSON and starts fresh\"** — Write `{}` to the session map file, call `loadSessionMap`, verify the map is empty.\n2. **\"`loadSessionMap` filters out malformed entries and keeps valid ones\"** — Write `[[\"key1\",\"val1\"],[\"bad\"],[1,2],[\"key2\",\"val2\"]]`, verify only `key1` and `key2` entries survive.\n\n## Acceptance Criteria\n\n- All three adapter routes use Zod `safeParse` instead of `as` casts\n- Invalid request bodies return 400 with `{ error, details }` format\n- All `res.write()` calls in the SSE stream are guarded by `res.writableEnded` checks\n- Keepalive interval self-clears when `writableEnded` is true\n- `loadSessionMap` validates that parsed JSON is an array\n- Malformed entries are filtered out with a warning log\n- Valid entries are preserved even when some entries are malformed",
      "activeForm": "Adding Zod validation, SSE write guards, and sessionMap validation",
      "size": "medium",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["2.1", "2.2"]
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Mesh & Transport Fixes",
      "subject": "[relay-mesh-telegram-review-fixes-r2] [P3] Fix Transport bypass in useMeshScanRoots with updateConfig method (C5)",
      "description": "Fix a critical Transport interface bypass where `useMeshScanRoots` uses raw `fetch()` instead of the Transport abstraction, breaking the Obsidian plugin's `DirectTransport`.\n\n## Problem\n\n**C5 (Critical):** The `useMeshScanRoots` hook uses raw `fetch('/api/config', ...)` to persist scan root changes. This bypasses the `Transport` interface, breaking the Obsidian plugin's `DirectTransport` (which has no server to `fetch` from).\n\n## Implementation\n\nFour files need changes across the shared package and client app.\n\n### Step 1: Add `updateConfig()` to Transport interface\n\n**File:** `packages/shared/src/transport.ts`\n\nAdd after the existing `getConfig()` method (after line 101):\n\n```typescript\n/** Partially update the persisted user config. */\nupdateConfig(patch: Record<string, unknown>): Promise<void>;\n```\n\n### Step 2: Implement in `HttpTransport`\n\n**File:** `apps/client/src/layers/shared/lib/http-transport.ts`\n\nAdd method to the `HttpTransport` class:\n\n```typescript\nasync updateConfig(patch: Record<string, unknown>): Promise<void> {\n  await fetchJSON(this.baseUrl, '/config', {\n    method: 'PATCH',\n    body: JSON.stringify(patch),\n  });\n}\n```\n\n### Step 3: Implement in `DirectTransport`\n\n**File:** `apps/client/src/layers/shared/lib/direct-transport.ts`\n\nAdd the method delegating to `configManager`:\n\n```typescript\nasync updateConfig(patch: Record<string, unknown>): Promise<void> {\n  // DirectTransport delegates to the injected config manager\n  if (!this.services.configManager?.applyPatch) {\n    throw new Error('Config updates not available in embedded mode');\n  }\n  this.services.configManager.applyPatch(patch);\n}\n```\n\nAlso update the `DirectTransportServices` interface to include:\n\n```typescript\nconfigManager?: {\n  applyPatch(patch: Record<string, unknown>): void;\n};\n```\n\nNote: If `configManager` is not injected, the method throws a clear error. This is acceptable since mesh scan roots are primarily a standalone-server feature.\n\n### Step 4: Update `useMeshScanRoots`\n\n**File:** `apps/client/src/layers/entities/mesh/model/use-mesh-scan-roots.ts`\n\nReplace the raw `fetch` with `transport.updateConfig()`:\n\n**Before:**\n```typescript\nconst { mutate: saveScanRoots, isPending: isSaving } = useMutation({\n  mutationFn: async (newRoots: string[]) => {\n    const res = await fetch('/api/config', {\n      method: 'PATCH',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ mesh: { scanRoots: newRoots } }),\n    });\n    if (!res.ok) throw new Error('Failed to save scan roots');\n    return res.json();\n  },\n  onSuccess: () => {\n    queryClient.invalidateQueries({ queryKey: ['config'] });\n  },\n});\n```\n\n**After:**\n```typescript\nconst { mutate: saveScanRoots, isPending: isSaving } = useMutation({\n  mutationFn: async (newRoots: string[]) => {\n    await transport.updateConfig({ mesh: { scanRoots: newRoots } });\n  },\n  onSuccess: () => {\n    queryClient.invalidateQueries({ queryKey: ['config'] });\n  },\n});\n```\n\nMake sure to import and use the transport from context:\n```typescript\nconst transport = useTransport();\n```\n\n### Step 5: Update mock transport in test-utils\n\n**File:** `packages/test-utils/` (wherever `createMockTransport` is defined)\n\nAdd `updateConfig` to the mock transport factory so tests don't break:\n\n```typescript\nupdateConfig: vi.fn().mockResolvedValue(undefined),\n```\n\n## Tests\n\nAdd test in `apps/client/src/layers/features/mesh/__tests__/MeshPanel.test.tsx` (or a dedicated transport test):\n\n1. **\"`useMeshScanRoots` calls `transport.updateConfig()` instead of raw fetch\"** — Render the hook with a mock transport, trigger `saveScanRoots`, verify `transport.updateConfig` was called with `{ mesh: { scanRoots: [...] } }` and that no raw `fetch` was made.\n\n## Acceptance Criteria\n\n- Transport interface has an `updateConfig(patch)` method\n- `HttpTransport` implements it using `fetchJSON` with PATCH method\n- `DirectTransport` implements it delegating to `configManager.applyPatch`\n- `useMeshScanRoots` uses `transport.updateConfig()` instead of raw `fetch`\n- Mock transport includes `updateConfig` method\n- `pnpm typecheck` passes across all packages\n- Obsidian plugin build is not broken by the interface addition",
      "activeForm": "Fixing Transport bypass in useMeshScanRoots",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["3.2", "3.3", "3.4"]
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "Mesh & Transport Fixes",
      "subject": "[relay-mesh-telegram-review-fixes-r2] [P3] Complete compensating transaction in MeshCore register methods (C6)",
      "description": "Fix incomplete rollback in MeshCore's `register()` and `registerByPath()` methods where a Relay registration failure leaves orphaned `.dork/agent.json` manifest files on disk.\n\n## Problem\n\n**C6 (Critical):** In both `register()` (lines 212-221) and `registerByPath()` (lines 276-281), when Step 3 (Relay registration) fails, the catch block removes the DB entry (`registry.remove()`) but does NOT remove the manifest file that was written in Step 1. This leaves an orphaned `.dork/agent.json` on disk.\n\n## Implementation\n\n**File:** The MeshCore service file (likely `apps/server/src/services/mesh/mesh-core.ts`)\n\n### Step 1: Update `register()` catch block (lines 212-221)\n\n**Before:**\n```typescript\n// Step 3: Register with Relay\ntry {\n  await this.relayBridge.registerAgent(manifest, candidate.path, namespace, effectiveScanRoot);\n} catch (err) {\n  // Compensate: remove DB entry\n  this.registry.remove(manifest.id);\n  throw err;\n}\n```\n\n**After:**\n```typescript\n// Step 3: Register with Relay\ntry {\n  await this.relayBridge.registerAgent(manifest, candidate.path, namespace, effectiveScanRoot);\n} catch (err) {\n  // Compensate: remove DB entry AND manifest file (written in Step 1)\n  this.registry.remove(manifest.id);\n  await removeManifest(candidate.path);\n  throw err;\n}\n```\n\n### Step 2: Update `registerByPath()` catch block (lines 276-281)\n\n**Before:**\n```typescript\ntry {\n  await this.relayBridge.registerAgent(manifest, projectPath, namespace, effectiveScanRoot);\n} catch (err) {\n  this.registry.remove(manifest.id);\n  throw err;\n}\n```\n\n**After:**\n```typescript\ntry {\n  await this.relayBridge.registerAgent(manifest, projectPath, namespace, effectiveScanRoot);\n} catch (err) {\n  // Compensate: remove DB entry AND manifest file (written above)\n  this.registry.remove(manifest.id);\n  await removeManifest(projectPath);\n  throw err;\n}\n```\n\n`removeManifest` is already imported from `@dorkos/shared/manifest` in this file (it is used in the Step 2 catch block for `register()`).\n\n## Tests\n\n**File:** `packages/mesh/src/__tests__/mesh-core.test.ts` (or wherever MeshCore tests live, likely `apps/server/src/services/mesh/__tests__/mesh-core.test.ts`)\n\n1. **\"`register()` removes manifest file when Relay registration fails\"** — Mock `relayBridge.registerAgent` to throw, call `register()`, verify both `registry.remove()` and `removeManifest()` were called, and that the original error is re-thrown.\n2. **\"`registerByPath()` removes manifest file when Relay registration fails\"** — Same setup for `registerByPath()`, verify both cleanup actions occur.\n\n## Acceptance Criteria\n\n- `register()` calls `removeManifest(candidate.path)` in the Relay failure catch block\n- `registerByPath()` calls `removeManifest(projectPath)` in the Relay failure catch block\n- Both methods still call `registry.remove(manifest.id)` as before\n- Both methods still re-throw the original error\n- No orphaned `.dork/agent.json` files left on disk after failed registrations",
      "activeForm": "Completing compensating transaction in MeshCore register methods",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["3.1", "3.3", "3.4"]
    },
    {
      "id": "3.3",
      "phase": 3,
      "phaseName": "Mesh & Transport Fixes",
      "subject": "[relay-mesh-telegram-review-fixes-r2] [P3] Remove dead CrossNamespaceEdge animation and fix handleNodeClick stale closure (I7, I8)",
      "description": "Fix two UI issues in the Mesh topology visualization.\n\n## Problem\n\n**I7 (Important):** The SVG `<animateMotion>` in `CrossNamespaceEdge.tsx` (lines 55-61) with `<mpath xlinkHref={...}>` references the edge path by `props.id`, but React Flow's `<BaseEdge>` does not set an `id` attribute on the rendered `<path>` element. The `xlinkHref` resolves to nothing, so the animation circle renders at `(0,0)` and never moves.\n\n**I8 (Important):** `handleNodeClick` in `TopologyGraph.tsx` (lines 524-544) includes `layoutedNodes` in its `useCallback` dependency array. Since `layoutedNodes` is state set on every ELK layout pass (and after every drag via `onNodeDragStop`), this recreates the callback on every position change.\n\n## Implementation\n\n### I7: Remove dead `CrossNamespaceEdge` animation\n\n**File:** `apps/client/src/layers/features/mesh/ui/CrossNamespaceEdge.tsx`\n\nRemove the entire dead animation block (lines 54-61):\n\n**Remove this:**\n```tsx\n{/* Flow particle travelling along the edge */}\n{!prefersReducedMotion && (\n  <circle r={3} fill=\"var(--color-primary)\" opacity={0.8}>\n    <animateMotion dur=\"3s\" repeatCount=\"indefinite\">\n      <mpath xlinkHref={`#${props.id}`} />\n    </animateMotion>\n  </circle>\n)}\n```\n\nThe component already has the dashed stroke styling which visually communicates the cross-namespace relationship. If `prefersReducedMotion` is no longer referenced elsewhere in the component after this removal, also clean up the import/hook.\n\n### I8: Fix `handleNodeClick` stale closure\n\n**File:** `apps/client/src/layers/features/mesh/ui/TopologyGraph.tsx`\n\nUse a ref for `layoutedNodes` and remove it from the `useCallback` dependency array.\n\nAdd a ref near the existing state declarations:\n\n```typescript\nconst layoutedNodesRef = useRef<Node[]>([]);\n```\n\nUpdate the ref whenever `layoutedNodes` changes:\n\n```typescript\nuseEffect(() => {\n  layoutedNodesRef.current = layoutedNodes;\n}, [layoutedNodes]);\n```\n\nUpdate `handleNodeClick`:\n\n**Before:**\n```typescript\nconst handleNodeClick = useCallback(\n  (_: React.MouseEvent, node: Node) => {\n    if (node.type !== 'agent') return;\n    onSelectAgentRef.current?.(node.id);\n\n    let centerX = node.position.x + AGENT_NODE_WIDTH / 2;\n    let centerY = node.position.y + AGENT_NODE_HEIGHT / 2;\n\n    if (node.parentId) {\n      const parentNode = layoutedNodes.find((n) => n.id === node.parentId);\n      if (parentNode) {\n        centerX += parentNode.position.x;\n        centerY += parentNode.position.y;\n      }\n    }\n\n    const targetZoom = Math.max(getZoom(), 1.0);\n    setCenter(centerX, centerY, { zoom: targetZoom, duration: 350 });\n  },\n  [setCenter, getZoom, layoutedNodes],\n);\n```\n\n**After:**\n```typescript\nconst handleNodeClick = useCallback(\n  (_: React.MouseEvent, node: Node) => {\n    if (node.type !== 'agent') return;\n    onSelectAgentRef.current?.(node.id);\n\n    let centerX = node.position.x + AGENT_NODE_WIDTH / 2;\n    let centerY = node.position.y + AGENT_NODE_HEIGHT / 2;\n\n    if (node.parentId) {\n      const parentNode = layoutedNodesRef.current.find((n) => n.id === node.parentId);\n      if (parentNode) {\n        centerX += parentNode.position.x;\n        centerY += parentNode.position.y;\n      }\n    }\n\n    const targetZoom = Math.max(getZoom(), 1.0);\n    setCenter(centerX, centerY, { zoom: targetZoom, duration: 350 });\n  },\n  [setCenter, getZoom],\n);\n```\n\nMake sure `useRef` is imported from React if not already.\n\n## Tests\n\n**File: `apps/client/src/layers/features/mesh/ui/__tests__/CrossNamespaceEdge.test.tsx`**\n\n1. **\"Does not render `<animateMotion>` or `<circle>` elements\"** — Render the `CrossNamespaceEdge` component, query the DOM for `animateMotion` and `circle` elements, verify neither exists.\n\n**File: `apps/client/src/layers/features/mesh/ui/__tests__/TopologyGraph.test.tsx`**\n\nThe existing tests should continue to pass. The `handleNodeClick` ref change is behavioral and covered by existing click tests.\n\n## Acceptance Criteria\n\n- `CrossNamespaceEdge` no longer renders `<animateMotion>`, `<mpath>`, or `<circle>` elements\n- Unused `prefersReducedMotion` import is cleaned up if no longer referenced\n- `handleNodeClick` uses `layoutedNodesRef.current` instead of closing over `layoutedNodes`\n- `layoutedNodes` is removed from the `useCallback` dependency array\n- `layoutedNodesRef` is kept in sync via a `useEffect`\n- All existing topology tests continue to pass",
      "activeForm": "Removing dead animation and fixing stale closure",
      "size": "medium",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["3.1", "3.2", "3.4"]
    },
    {
      "id": "3.4",
      "phase": 3,
      "phaseName": "Mesh & Transport Fixes",
      "subject": "[relay-mesh-telegram-review-fixes-r2] [P3] Prevent ELK layout thrashing and extract relativeTime utility (I9, I10)",
      "description": "Fix ELK layout thrashing on topology refetch and extract duplicated `relativeTime` function to a shared utility.\n\n## Problem\n\n**I9 (Important):** The `useTopology` hook refetches every 15 seconds (`refetchInterval: 15_000`). Each refetch creates new object references for `rawNodes` and `rawEdges`, triggering the ELK layout `useEffect` even when the topology data is structurally identical.\n\n**I10 (Important):** `relativeTime()` is duplicated between `AgentNode.tsx` (lines 50-68, robust version with `Number.isNaN` guard and seconds granularity) and `AgentHealthDetail.tsx` (lines 18-27, simpler version). The `AgentNode` version is more correct.\n\n## Implementation\n\n### I9: Add topology fingerprint to prevent layout thrashing\n\n**File:** `apps/client/src/layers/features/mesh/ui/TopologyGraph.tsx`\n\nAdd a fingerprint memo before the ELK layout effect:\n\n```typescript\n/** Stable fingerprint of the topology structure — only changes when nodes/edges actually change. */\nconst topologyFingerprint = useMemo(() => {\n  const nodeIds = rawNodes.map((n) => `${n.id}:${n.type}:${n.parentId ?? ''}`).sort().join('|');\n  const edgeIds = rawEdges.map((e) => `${e.source}->${e.target}:${e.type}`).sort().join('|');\n  return `${nodeIds}::${edgeIds}`;\n}, [rawNodes, rawEdges]);\n```\n\nUpdate the ELK layout effect to depend on the fingerprint instead of the raw arrays:\n\n**Before:**\n```typescript\nuseEffect(() => {\n  let cancelled = false;\n  setIsLayouting(true);\n  applyElkLayout(rawNodes, rawEdges, useGroups)\n    // ...\n}, [rawNodes, rawEdges, useGroups, layoutVersion]);\n```\n\n**After:**\n```typescript\nuseEffect(() => {\n  let cancelled = false;\n  setIsLayouting(true);\n  applyElkLayout(rawNodes, rawEdges, useGroups)\n    // ...\n  // eslint-disable-next-line react-hooks/exhaustive-deps -- fingerprint tracks structural changes\n}, [topologyFingerprint, useGroups, layoutVersion]);\n```\n\nThe `rawNodes` and `rawEdges` references are captured by the closure, so the effect body still has access to the current values. The fingerprint just prevents unnecessary re-runs.\n\n### I10: Extract `relativeTime` to shared utility\n\n**Create new file:** `apps/client/src/layers/features/mesh/lib/relative-time.ts`\n\n```typescript\n/**\n * Convert an ISO timestamp to a relative time string (e.g., \"2m ago\", \"3d ago\").\n *\n * Returns \"just now\" for invalid/future dates and \"Never\" for null input.\n *\n * @param isoString - ISO 8601 timestamp, or null\n */\nexport function relativeTime(isoString: string | null): string {\n  if (!isoString) return 'Never';\n\n  const now = Date.now();\n  const then = new Date(isoString).getTime();\n  const diffMs = now - then;\n\n  if (Number.isNaN(diffMs) || diffMs < 0) return 'just now';\n\n  const seconds = Math.floor(diffMs / 1000);\n  if (seconds < 60) return `${seconds}s ago`;\n\n  const minutes = Math.floor(seconds / 60);\n  if (minutes < 60) return `${minutes}m ago`;\n\n  const hours = Math.floor(minutes / 60);\n  if (hours < 24) return `${hours}h ago`;\n\n  const days = Math.floor(hours / 24);\n  return `${days}d ago`;\n}\n```\n\nThis takes the robust version from `AgentNode.tsx` (with `Number.isNaN` guard and seconds granularity) and adds `null` handling from `AgentHealthDetail.tsx`.\n\n**Update `AgentNode.tsx`** — Remove the inline `relativeTime` function (lines 49-68) and import from shared:\n\n```typescript\nimport { relativeTime } from '../lib/relative-time';\n```\n\n**Update `AgentHealthDetail.tsx`** — Remove the inline `relativeTime` function (lines 18-27) and import from shared:\n\n```typescript\nimport { relativeTime } from '../lib/relative-time';\n```\n\nThe function lives in `features/mesh/lib/` (not `shared/lib/`) because it is only used within the mesh feature.\n\n## Tests\n\n**File: `apps/client/src/layers/features/mesh/ui/__tests__/TopologyGraph.test.tsx`**\n\n1. **\"ELK layout is not re-triggered when refetch returns structurally identical data\"** — Render the topology, trigger a refetch that returns identical data (same node/edge IDs), verify that the ELK layout function is NOT called again.\n\n**File: `apps/client/src/layers/features/mesh/lib/__tests__/relative-time.test.ts` (new)**\n\n1. **\"Returns 'Never' for null input\"** — `relativeTime(null)` returns `'Never'`.\n2. **\"Returns 'just now' for future dates\"** — `relativeTime(futureISOString)` returns `'just now'`.\n3. **\"Returns seconds granularity\"** — `relativeTime(30SecondsAgo)` returns `'30s ago'`.\n4. **\"Returns minutes granularity\"** — `relativeTime(5MinutesAgo)` returns `'5m ago'`.\n5. **\"Returns hours granularity\"** — `relativeTime(3HoursAgo)` returns `'3h ago'`.\n6. **\"Returns days granularity\"** — `relativeTime(2DaysAgo)` returns `'2d ago'`.\n7. **\"Handles NaN dates gracefully\"** — `relativeTime('not-a-date')` returns `'just now'`.\n\n## Acceptance Criteria\n\n- ELK layout effect uses `topologyFingerprint` instead of `rawNodes`/`rawEdges` in dependency array\n- Structurally identical refetch data does not trigger re-layout\n- `relativeTime` is defined once in `features/mesh/lib/relative-time.ts`\n- Both `AgentNode.tsx` and `AgentHealthDetail.tsx` import from the shared utility\n- No duplicate `relativeTime` implementations remain\n- The shared function handles null, NaN, future dates, and all time granularities\n- All existing topology and agent node tests continue to pass",
      "activeForm": "Preventing layout thrashing and extracting relativeTime utility",
      "size": "medium",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["3.1", "3.2", "3.3"]
    }
  ]
}
