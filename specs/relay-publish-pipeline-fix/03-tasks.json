{
  "spec": "specs/relay-publish-pipeline-fix/02-specification.md",
  "slug": "relay-publish-pipeline-fix",
  "generatedAt": "2026-02-27T20:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[relay-publish-pipeline-fix] [P1] Update AdapterRegistryLike interface and AdapterRegistry.deliver() to return DeliveryResult",
      "description": "Update the `AdapterRegistryLike` interface in `packages/relay/src/types.ts` and the `AdapterRegistry.deliver()` implementation in `packages/relay/src/adapter-registry.ts` to return `DeliveryResult | null` instead of `boolean`. This propagates rich delivery results through the pipeline.\n\n**File 1: `packages/relay/src/types.ts`**\n\nChange the `AdapterRegistryLike` interface:\n\n```typescript\n// Before:\nexport interface AdapterRegistryLike {\n  setRelay(relay: RelayPublisher): void;\n  deliver(subject: string, envelope: RelayEnvelope, context?: AdapterContext): Promise<boolean>;\n  shutdown(): Promise<void>;\n}\n\n// After:\nexport interface AdapterRegistryLike {\n  setRelay(relay: RelayPublisher): void;\n  deliver(subject: string, envelope: RelayEnvelope, context?: AdapterContext): Promise<DeliveryResult | null>;\n  shutdown(): Promise<void>;\n}\n```\n\nAlso add the `adapterResult` field to `PublishResultLike` in the same file:\n\n```typescript\n// Before:\nexport interface PublishResultLike {\n  messageId: string;\n  deliveredTo: number;\n  rejected?: Array<{\n    endpointHash: string;\n    reason: 'backpressure' | 'circuit_open' | 'rate_limited' | 'budget_exceeded';\n  }>;\n  mailboxPressure?: Record<string, number>;\n}\n\n// After:\nexport interface PublishResultLike {\n  messageId: string;\n  deliveredTo: number;\n  rejected?: Array<{\n    endpointHash: string;\n    reason: 'backpressure' | 'circuit_open' | 'rate_limited' | 'budget_exceeded';\n  }>;\n  mailboxPressure?: Record<string, number>;\n  /** Result from adapter delivery, if attempted. */\n  adapterResult?: DeliveryResult;\n}\n```\n\n**File 2: `packages/relay/src/adapter-registry.ts`**\n\nChange the `deliver()` method to return `DeliveryResult | null`:\n\n```typescript\n// Before:\nasync deliver(subject: string, envelope: RelayEnvelope, context?: AdapterContext): Promise<boolean> {\n  const adapter = this.getBySubject(subject);\n  if (!adapter) return false;\n  await adapter.deliver(subject, envelope, context);\n  return true;\n}\n\n// After:\nasync deliver(\n  subject: string,\n  envelope: RelayEnvelope,\n  context?: AdapterContext,\n): Promise<DeliveryResult | null> {\n  const adapter = this.getBySubject(subject);\n  if (!adapter) return null;\n  return adapter.deliver(subject, envelope, context);\n}\n```\n\nNote: Import `DeliveryResult` in `adapter-registry.ts` — it is already exported from `./types.js`.\n\n**Acceptance Criteria:**\n- [ ] `AdapterRegistryLike.deliver()` returns `Promise<DeliveryResult | null>` (not `Promise<boolean>`)\n- [ ] `AdapterRegistry.deliver()` returns `null` when no adapter matches (not `false`)\n- [ ] `AdapterRegistry.deliver()` returns the full `DeliveryResult` from the matched adapter (not `true`)\n- [ ] `PublishResultLike` has an optional `adapterResult?: DeliveryResult` field\n- [ ] `pnpm typecheck` passes across the monorepo\n- [ ] Existing adapter-registry tests in `packages/relay/src/__tests__/adapter-registry.test.ts` are updated: the deliver test that asserts `expect(delivered).toBe(true)` must now assert `expect(delivered).toEqual({ success: true, durationMs: 0 })` (matching the mock return value), and the test asserting `expect(result).toBe(false)` must now assert `expect(result).toBeNull()`",
      "activeForm": "Updating adapter delivery return types",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": []
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[relay-publish-pipeline-fix] [P1] Extend PublishResult with adapterResult field",
      "description": "Add the optional `adapterResult` field to the `PublishResult` interface in `packages/relay/src/relay-core.ts`.\n\n**File: `packages/relay/src/relay-core.ts`**\n\nLocate the `PublishResult` interface (around line 76) and add the new field:\n\n```typescript\n// Before:\nexport interface PublishResult {\n  /** The ULID message ID assigned to the published envelope. */\n  messageId: string;\n  /** Number of endpoints the message was delivered to. */\n  deliveredTo: number;\n  /** Endpoints that rejected the message, with structured reasons. */\n  rejected?: Array<{\n    endpointHash: string;\n    reason: 'backpressure' | 'circuit_open' | 'rate_limited' | 'budget_exceeded';\n  }>;\n  /** Per-endpoint pressure ratios for proactive signaling (0.0-1.0). */\n  mailboxPressure?: Record<string, number>;\n}\n\n// After:\nexport interface PublishResult {\n  /** The ULID message ID assigned to the published envelope. */\n  messageId: string;\n  /** Number of endpoints the message was delivered to. */\n  deliveredTo: number;\n  /** Endpoints that rejected the message, with structured reasons. */\n  rejected?: Array<{\n    endpointHash: string;\n    reason: 'backpressure' | 'circuit_open' | 'rate_limited' | 'budget_exceeded';\n  }>;\n  /** Per-endpoint pressure ratios for proactive signaling (0.0-1.0). */\n  mailboxPressure?: Record<string, number>;\n  /** Result from adapter delivery, if attempted. */\n  adapterResult?: DeliveryResult;\n}\n```\n\nAlso add `DeliveryResult` to the existing type imports from `./types.js` at the top of the file. The current import line (around line 36-48) imports many types — add `DeliveryResult` to the list:\n\n```typescript\nimport type {\n  RateLimitConfig,\n  BackpressureConfig,\n  RelayOptions,\n  PublishOptions,\n  MessageHandler,\n  SignalHandler,\n  Unsubscribe,\n  EndpointInfo,\n  RelayMetrics,\n  AdapterRegistryLike,\n  AdapterContext,\n  DeliveryResult,  // <-- add this\n} from './types.js';\n```\n\n**Acceptance Criteria:**\n- [ ] `PublishResult` interface includes `adapterResult?: DeliveryResult`\n- [ ] `DeliveryResult` is imported from `./types.js`\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Extending PublishResult type",
      "size": "small",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": []
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[relay-publish-pipeline-fix] [P1] Add deliverToAdapter() private method to RelayCore",
      "description": "Add a new private method `deliverToAdapter()` to the `RelayCore` class in `packages/relay/src/relay-core.ts`. This method encapsulates adapter delivery with timeout protection, SQLite indexing, and error handling.\n\n**File: `packages/relay/src/relay-core.ts`**\n\n1. Add a static constant for the timeout at the class level (inside the `RelayCore` class body, near the top with other private fields):\n\n```typescript\n/** Adapter delivery timeout in milliseconds. */\nprivate static readonly ADAPTER_TIMEOUT_MS = 30_000;\n```\n\n2. Add the `deliverToAdapter()` private method. Place it after the existing `deliverToEndpoint()` method and before the `subscribe()` method:\n\n```typescript\n/**\n * Deliver a message to a matching adapter with timeout protection,\n * SQLite indexing, and error handling.\n *\n * @param subject - The target subject\n * @param envelope - The relay envelope to deliver\n * @returns DeliveryResult or null if no adapter matched\n */\nprivate async deliverToAdapter(\n  subject: string,\n  envelope: RelayEnvelope,\n): Promise<DeliveryResult | null> {\n  if (!this.adapterRegistry) return null;\n\n  const context = this.adapterContextBuilder?.(subject);\n\n  try {\n    const deliveryPromise = this.adapterRegistry.deliver(subject, envelope, context);\n\n    const result = await Promise.race([\n      deliveryPromise,\n      new Promise<DeliveryResult>((_, reject) =>\n        setTimeout(\n          () => reject(new Error('adapter delivery timeout (30s)')),\n          RelayCore.ADAPTER_TIMEOUT_MS,\n        ),\n      ),\n    ]);\n\n    // Index adapter-delivered messages in SQLite for audit trail\n    if (result && result.success) {\n      const { hashSubject } = await import('./endpoint-registry.js');\n      const subjectHash = hashSubject(subject);\n      this.sqliteIndex.insertMessage({\n        id: envelope.id,\n        subject,\n        endpointHash: `adapter:${subjectHash}`,\n        status: 'delivered',\n        createdAt: envelope.createdAt,\n        expiresAt: null,\n      });\n    }\n\n    return result;\n  } catch (err) {\n    const errorMessage = err instanceof Error ? err.message : String(err);\n    console.warn('RelayCore: adapter delivery failed:', errorMessage);\n    return {\n      success: false,\n      error: errorMessage,\n      deadLettered: false,\n      durationMs: undefined,\n    };\n  }\n}\n```\n\nKey behaviors:\n- Returns `null` if no `adapterRegistry` is configured (no adapter to try)\n- Uses `Promise.race` with a 30-second timeout to protect against slow/hung adapters\n- On successful delivery, indexes the message in SQLite with an `adapter:` prefixed endpoint hash to distinguish from Maildir deliveries\n- On failure (including timeout), returns a `DeliveryResult` with `success: false` and the error message — does NOT throw\n- The `deadLettered: false` in the error result signals that the caller (the `publish()` method) should decide about DLQ based on overall `deliveredTo` count\n\n**Acceptance Criteria:**\n- [ ] `deliverToAdapter()` is a private method on `RelayCore`\n- [ ] `ADAPTER_TIMEOUT_MS` is a static readonly constant set to 30000\n- [ ] Method returns `null` when `this.adapterRegistry` is undefined\n- [ ] Method uses `Promise.race` for timeout protection\n- [ ] On success, a SQLite index entry is inserted with `endpointHash: 'adapter:<subjectHash>'`\n- [ ] On failure, returns `{ success: false, error: <message>, deadLettered: false }` without throwing\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Adding deliverToAdapter private method",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1", "1.2"],
      "parallelWith": []
    },
    {
      "id": "1.4",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[relay-publish-pipeline-fix] [P1] Restructure publish() with unified fan-out — remove early return bug",
      "description": "This is the critical bug fix. Restructure the `publish()` method in `packages/relay/src/relay-core.ts` to remove the early return that skips adapter delivery when no Maildir endpoints match.\n\n**File: `packages/relay/src/relay-core.ts`**\n\nReplace the code from the comment `// 5. Find matching endpoints` through to the `return` statement at the end of `publish()` (approximately lines 304-355). The current code has an early return at lines 308-315 that dead-letters and returns when `matchingEndpoints.length === 0`, which means the adapter delivery code at lines 337-348 is never reached for adapter-only subjects.\n\n**Replace the current code (lines ~304-355):**\n\n```typescript\n// 5. Find matching endpoints\nconst matchingEndpoints = this.findMatchingEndpoints(subject);\n\n// 6. Deliver to each matching endpoint\nif (matchingEndpoints.length === 0) {\n  const { hashSubject } = await import('./endpoint-registry.js');\n  const subjectHash = hashSubject(subject);\n  await this.maildirStore.ensureMaildir(subjectHash);\n  await this.deadLetterQueue.reject(subjectHash, envelope, 'no matching endpoints');\n  return { messageId, deliveredTo: 0 };\n}\n\nlet deliveredTo = 0;\nconst rejected: PublishResult['rejected'] = [];\nconst mailboxPressure: Record<string, number> = {};\n\nfor (const endpoint of matchingEndpoints) {\n  const result = await this.deliverToEndpoint(endpoint, envelope);\n  if (result.delivered) deliveredTo++;\n  if (result.rejected) rejected.push(result.rejected);\n  if (result.pressure !== undefined) mailboxPressure[endpoint.hash] = result.pressure;\n}\n\n// 7. Deliver to matching external adapter (after Maildir endpoints)\nif (this.adapterRegistry) {\n  try {\n    const context = this.adapterContextBuilder?.(subject);\n    const adapterDelivered = await this.adapterRegistry.deliver(subject, envelope, context);\n    if (adapterDelivered) deliveredTo++;\n  } catch (err) {\n    console.warn('RelayCore: adapter delivery failed:', err instanceof Error ? err.message : err);\n  }\n}\n\nreturn {\n  messageId,\n  deliveredTo,\n  ...(rejected.length > 0 && { rejected }),\n  ...(Object.keys(mailboxPressure).length > 0 && { mailboxPressure }),\n};\n```\n\n**With this new code:**\n\n```typescript\n// 5. Find matching Maildir endpoints\nconst matchingEndpoints = this.findMatchingEndpoints(subject);\n\n// 6. Deliver to Maildir endpoints (may be empty — that's OK)\nlet deliveredTo = 0;\nconst rejected: PublishResult['rejected'] = [];\nconst mailboxPressure: Record<string, number> = {};\n\nfor (const endpoint of matchingEndpoints) {\n  const result = await this.deliverToEndpoint(endpoint, envelope);\n  if (result.delivered) deliveredTo++;\n  if (result.rejected) rejected.push(result.rejected);\n  if (result.pressure !== undefined) mailboxPressure[endpoint.hash] = result.pressure;\n}\n\n// 7. Deliver to matching adapter (unified fan-out — always attempted)\nlet adapterResult: DeliveryResult | null = null;\nif (this.adapterRegistry) {\n  adapterResult = await this.deliverToAdapter(subject, envelope);\n  if (adapterResult?.success) deliveredTo++;\n}\n\n// 8. Dead-letter only when NOTHING delivered\nif (deliveredTo === 0) {\n  const { hashSubject } = await import('./endpoint-registry.js');\n  const subjectHash = hashSubject(subject);\n  await this.maildirStore.ensureMaildir(subjectHash);\n\n  const reason = adapterResult?.error\n    ? `adapter delivery failed: ${adapterResult.error}`\n    : 'no matching endpoints or adapters';\n  await this.deadLetterQueue.reject(subjectHash, envelope, reason);\n}\n\nreturn {\n  messageId,\n  deliveredTo,\n  ...(rejected.length > 0 && { rejected }),\n  ...(Object.keys(mailboxPressure).length > 0 && { mailboxPressure }),\n  ...(adapterResult && { adapterResult }),\n};\n```\n\n**Key behavioral changes:**\n1. The early return for `matchingEndpoints.length === 0` is REMOVED — Maildir delivery and adapter delivery are both attempted unconditionally\n2. Adapter delivery uses the new `deliverToAdapter()` method (from task 1.3) instead of inline try/catch\n3. Dead-lettering happens ONLY when `deliveredTo === 0` after all delivery targets have been tried\n4. Dead-letter reason is descriptive: includes adapter error if one occurred, otherwise states 'no matching endpoints or adapters'\n5. The returned `PublishResult` includes `adapterResult` when an adapter was attempted\n6. Partial delivery (Maildir succeeds but adapter fails) does NOT dead-letter the message\n\n**Acceptance Criteria:**\n- [ ] The early return at the old lines 308-315 is completely removed\n- [ ] Adapter delivery is attempted even when `matchingEndpoints.length === 0`\n- [ ] Dead-lettering only happens when `deliveredTo === 0`\n- [ ] Dead-letter reason includes adapter error message when applicable\n- [ ] `PublishResult` returned includes `adapterResult` when adapter was tried\n- [ ] Partial delivery (Maildir succeeds, adapter fails) does NOT dead-letter\n- [ ] `pnpm typecheck` passes\n- [ ] Existing publish tests that don't involve adapters continue to pass",
      "activeForm": "Restructuring publish() with unified fan-out",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.3"],
      "parallelWith": []
    },
    {
      "id": "1.5",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[relay-publish-pipeline-fix] [P1] Update publishViaRelay() — real trace ID and improved error handling",
      "description": "Update the `publishViaRelay()` function in `apps/server/src/routes/sessions.ts` to return a real trace ID and improve console endpoint registration error handling.\n\n**File: `apps/server/src/routes/sessions.ts`**\n\n**Change 1: Real trace ID (around line 183-186)**\n\nReplace the hardcoded `'no-trace'` with the message ID:\n\n```typescript\n// Before:\nreturn {\n  messageId: publishResult.messageId,\n  traceId: 'no-trace',\n};\n\n// After:\nreturn {\n  messageId: publishResult.messageId,\n  traceId: publishResult.messageId,\n};\n```\n\nRationale: The envelope's ULID message ID is a natural trace correlation ID — unique per publish, usable to look up trace spans, SQLite index entries, and dead letters.\n\n**Change 2: Improved endpoint registration error handling (around line 163-167)**\n\nReplace the catch-all that silently swallows all errors:\n\n```typescript\n// Before:\ntry {\n  await relayCore.registerEndpoint(consoleEndpoint);\n} catch {\n  // Endpoint already registered — ignore\n}\n\n// After:\ntry {\n  await relayCore.registerEndpoint(consoleEndpoint);\n} catch (err) {\n  // Only ignore \"already registered\" — log real failures\n  const message = err instanceof Error ? err.message : String(err);\n  if (!message.includes('already registered')) {\n    console.error('publishViaRelay: failed to register console endpoint:', message);\n  }\n}\n```\n\nRationale: The current catch block masks real failures (disk errors, permission issues). The improved version only ignores the expected \"already registered\" case and logs unexpected errors.\n\n**Acceptance Criteria:**\n- [ ] `traceId` in the return value equals `publishResult.messageId` (not `'no-trace'`)\n- [ ] Non-duplicate registration errors are logged via `console.error`\n- [ ] Duplicate registration errors (containing 'already registered') are silently ignored\n- [ ] The publish flow still proceeds even if endpoint registration fails\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Updating publishViaRelay with real trace ID",
      "size": "small",
      "priority": "high",
      "dependencies": ["1.4"],
      "parallelWith": []
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "Test Coverage",
      "subject": "[relay-publish-pipeline-fix] [P2] Fix existing buggy test and add adapter integration tests to relay-core.test.ts",
      "description": "Update the existing relay-core test file at `packages/relay/src/__tests__/relay-core.test.ts` to fix the test that validates the buggy early-return behavior, and add comprehensive adapter integration tests.\n\nThe existing test file uses real filesystem temp directories with `beforeEach`/`afterEach` lifecycle. The `createRelay()` helper creates `RelayCore` instances with `{ dataDir: tmpDir, ... }`. Follow this same pattern but create new `RelayCore` instances that include an `adapterRegistry` option.\n\n**Fix 1: Update the existing buggy test**\n\nFind the test that asserts `deliveredTo === 0` for unmatched subjects (something like 'returns deliveredTo=0 when no endpoints match' or similar). Update it to verify dead-lettering:\n\n```typescript\nit('dead-letters when no endpoints or adapters match', async () => {\n  const result = await relay.publish('relay.nobody.here', { content: 'hello' }, { from: 'relay.test.sender' });\n  expect(result.deliveredTo).toBe(0);\n  // Verify DLQ was called\n  const deadLetters = await relay.listDeadLetters({ limit: 10 });\n  expect(deadLetters.some((d) => d.envelope.subject === 'relay.nobody.here')).toBe(true);\n});\n```\n\n**New test group: Add a `describe('adapter delivery')` block with these tests:**\n\n```typescript\ndescribe('adapter delivery', () => {\n  it('delivers to adapter when no Maildir endpoints match', async () => {\n    const mockAdapter: AdapterRegistryLike = {\n      setRelay: vi.fn(),\n      deliver: vi.fn().mockResolvedValue({ success: true, durationMs: 5 }),\n      shutdown: vi.fn(),\n    };\n    const relayWithAdapter = new RelayCore({\n      dataDir: tmpDir,\n      adapterRegistry: mockAdapter,\n    });\n\n    const result = await relayWithAdapter.publish(\n      'relay.agent.test-session',\n      { content: 'hello' },\n      { from: 'relay.test.sender' },\n    );\n\n    expect(result.deliveredTo).toBe(1);\n    expect(result.adapterResult).toEqual({ success: true, durationMs: 5 });\n    expect(mockAdapter.deliver).toHaveBeenCalledWith(\n      'relay.agent.test-session',\n      expect.objectContaining({ subject: 'relay.agent.test-session' }),\n      undefined,\n    );\n\n    await relayWithAdapter.close();\n  });\n\n  it('delivers to both Maildir endpoints and adapter', async () => {\n    const mockAdapter: AdapterRegistryLike = {\n      setRelay: vi.fn(),\n      deliver: vi.fn().mockResolvedValue({ success: true, durationMs: 3 }),\n      shutdown: vi.fn(),\n    };\n    const relayMixed = new RelayCore({\n      dataDir: tmpDir,\n      adapterRegistry: mockAdapter,\n    });\n    await relayMixed.registerEndpoint('relay.agent.test-session');\n\n    const result = await relayMixed.publish(\n      'relay.agent.test-session',\n      { content: 'hello' },\n      { from: 'relay.test.sender' },\n    );\n\n    expect(result.deliveredTo).toBe(2); // Maildir + adapter\n\n    await relayMixed.close();\n  });\n\n  it('dead-letters when adapter is sole target and fails', async () => {\n    const failingAdapter: AdapterRegistryLike = {\n      setRelay: vi.fn(),\n      deliver: vi.fn().mockResolvedValue({\n        success: false,\n        error: 'connection refused',\n      }),\n      shutdown: vi.fn(),\n    };\n    const relayFailing = new RelayCore({\n      dataDir: tmpDir,\n      adapterRegistry: failingAdapter,\n    });\n\n    const result = await relayFailing.publish(\n      'relay.agent.fail-session',\n      { content: 'hello' },\n      { from: 'relay.test.sender' },\n    );\n\n    expect(result.deliveredTo).toBe(0);\n    const dead = await relayFailing.listDeadLetters({ limit: 10 });\n    expect(dead.some((d) => d.reason.includes('adapter delivery failed'))).toBe(true);\n\n    await relayFailing.close();\n  });\n\n  it('handles adapter delivery timeout gracefully', async () => {\n    const slowAdapter: AdapterRegistryLike = {\n      setRelay: vi.fn(),\n      deliver: vi.fn().mockImplementation(\n        () => new Promise((resolve) => setTimeout(() => resolve({ success: true }), 60_000)),\n      ),\n      shutdown: vi.fn(),\n    };\n    const relaySlow = new RelayCore({\n      dataDir: tmpDir,\n      adapterRegistry: slowAdapter,\n    });\n\n    vi.useFakeTimers();\n    const publishPromise = relaySlow.publish(\n      'relay.agent.slow-session',\n      { content: 'hello' },\n      { from: 'relay.test.sender' },\n    );\n    vi.advanceTimersByTime(31_000);\n    const result = await publishPromise;\n    vi.useRealTimers();\n\n    expect(result.deliveredTo).toBe(0);\n    expect(result.adapterResult?.error).toContain('timeout');\n\n    await relaySlow.close();\n  });\n\n  it('does NOT dead-letter when Maildir delivered but adapter failed', async () => {\n    const failingAdapter: AdapterRegistryLike = {\n      setRelay: vi.fn(),\n      deliver: vi.fn().mockResolvedValue({ success: false, error: 'down' }),\n      shutdown: vi.fn(),\n    };\n    const relayPartial = new RelayCore({\n      dataDir: tmpDir,\n      adapterRegistry: failingAdapter,\n    });\n    await relayPartial.registerEndpoint('relay.agent.partial');\n\n    const result = await relayPartial.publish(\n      'relay.agent.partial',\n      { content: 'hello' },\n      { from: 'relay.test.sender' },\n    );\n\n    expect(result.deliveredTo).toBe(1); // Maildir succeeded\n    const dead = await relayPartial.listDeadLetters({ limit: 10 });\n    expect(dead.filter((d) => d.envelope.subject === 'relay.agent.partial')).toHaveLength(0);\n\n    await relayPartial.close();\n  });\n\n  it('passes adapter context through to adapter delivery', async () => {\n    const mockAdapter: AdapterRegistryLike = {\n      setRelay: vi.fn(),\n      deliver: vi.fn().mockResolvedValue({ success: true }),\n      shutdown: vi.fn(),\n    };\n    const mockContext: AdapterContext = {\n      agent: { directory: '/tmp/test', runtime: 'claude-code' },\n    };\n    const relayWithContext = new RelayCore({\n      dataDir: tmpDir,\n      adapterRegistry: mockAdapter,\n      adapterContextBuilder: () => mockContext,\n    });\n\n    await relayWithContext.publish('relay.agent.ctx', { content: 'hi' }, { from: 'relay.test.sender' });\n\n    expect(mockAdapter.deliver).toHaveBeenCalledWith(\n      'relay.agent.ctx',\n      expect.any(Object),\n      mockContext,\n    );\n\n    await relayWithContext.close();\n  });\n\n  it('returns adapterResult as null when no adapter registry configured', async () => {\n    const result = await relay.publish(\n      'relay.test.no-adapter',\n      { content: 'hello' },\n      { from: 'relay.test.sender' },\n    );\n\n    expect(result.adapterResult).toBeUndefined();\n  });\n});\n```\n\nNote: Import `vi` from vitest at the top of the file (it may already be imported). Also import `AdapterRegistryLike` and `AdapterContext` from `../types.js`.\n\n**Acceptance Criteria:**\n- [ ] The existing buggy test is updated to verify dead-letter behavior (not just `deliveredTo: 0`)\n- [ ] 7 new adapter delivery tests are added and passing\n- [ ] Test for adapter-only delivery verifies `deliveredTo: 1` and `adapterResult` presence\n- [ ] Test for mixed delivery verifies `deliveredTo: 2`\n- [ ] Test for adapter failure verifies dead-lettering with descriptive reason\n- [ ] Test for timeout verifies error message contains 'timeout' (uses fake timers)\n- [ ] Test for partial delivery verifies NO dead-lettering when Maildir succeeds\n- [ ] Test for context builder verifies context is passed through\n- [ ] All existing relay-core tests continue to pass\n- [ ] `pnpm vitest run packages/relay/src/__tests__/relay-core.test.ts` passes",
      "activeForm": "Adding adapter integration tests to relay-core",
      "size": "large",
      "priority": "high",
      "dependencies": ["1.4"],
      "parallelWith": ["2.2", "2.3"]
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "Test Coverage",
      "subject": "[relay-publish-pipeline-fix] [P2] Update adapter-registry.test.ts for DeliveryResult return type",
      "description": "Update the existing `packages/relay/src/__tests__/adapter-registry.test.ts` to reflect the new `DeliveryResult | null` return type from `deliver()`.\n\n**File: `packages/relay/src/__tests__/adapter-registry.test.ts`**\n\nThe existing tests at lines 129-146 need updates:\n\n**Update 1: deliver() routes test (around line 129)**\n\nThe mock adapter's `deliver` already returns `{ success: true, durationMs: 0 }` (line 19 of the mock helper), so the test just needs its assertion updated:\n\n```typescript\n// Before:\nit('deliver() routes to the correct adapter by subject prefix', async () => {\n  const adapter = createMockAdapter({ subjectPrefix: 'relay.human.telegram' });\n  await registry.register(adapter);\n\n  const envelope = createMockEnvelope();\n  const subject = 'relay.human.telegram.999';\n  const delivered = await registry.deliver(subject, { ...envelope, subject });\n\n  expect(delivered).toBe(true);\n  expect(adapter.deliver).toHaveBeenCalledWith(subject, expect.objectContaining({ subject }), undefined);\n});\n\n// After:\nit('deliver() routes to the correct adapter and returns DeliveryResult', async () => {\n  const adapter = createMockAdapter({ subjectPrefix: 'relay.human.telegram' });\n  await registry.register(adapter);\n\n  const envelope = createMockEnvelope();\n  const subject = 'relay.human.telegram.999';\n  const result = await registry.deliver(subject, { ...envelope, subject });\n\n  expect(result).toEqual({ success: true, durationMs: 0 });\n  expect(adapter.deliver).toHaveBeenCalledWith(subject, expect.objectContaining({ subject }), undefined);\n});\n```\n\n**Update 2: deliver() returns false test (around line 141)**\n\n```typescript\n// Before:\nit('deliver() returns false when no adapter matches', async () => {\n  const envelope = createMockEnvelope();\n  const result = await registry.deliver('relay.agent.backend', envelope);\n  expect(result).toBe(false);\n});\n\n// After:\nit('deliver() returns null when no adapter matches', async () => {\n  const envelope = createMockEnvelope();\n  const result = await registry.deliver('relay.agent.backend', envelope);\n  expect(result).toBeNull();\n});\n```\n\n**Add 3 new tests for DeliveryResult propagation:**\n\n```typescript\nit('deliver() propagates full DeliveryResult from adapter', async () => {\n  const richResult = {\n    success: true,\n    durationMs: 42,\n    responseMessageId: 'resp-123',\n  };\n  const adapter = createMockAdapter({\n    subjectPrefix: 'relay.human.telegram',\n    deliver: vi.fn().mockResolvedValue(richResult),\n  });\n  await registry.register(adapter);\n\n  const envelope = createMockEnvelope();\n  const result = await registry.deliver('relay.human.telegram.999', { ...envelope, subject: 'relay.human.telegram.999' });\n\n  expect(result).toEqual(richResult);\n});\n\nit('deliver() propagates failure DeliveryResult from adapter', async () => {\n  const failResult = {\n    success: false,\n    error: 'rate limited by Telegram',\n    deadLettered: false,\n  };\n  const adapter = createMockAdapter({\n    subjectPrefix: 'relay.human.telegram',\n    deliver: vi.fn().mockResolvedValue(failResult),\n  });\n  await registry.register(adapter);\n\n  const envelope = createMockEnvelope();\n  const result = await registry.deliver('relay.human.telegram.999', { ...envelope, subject: 'relay.human.telegram.999' });\n\n  expect(result).toEqual(failResult);\n  expect(result?.success).toBe(false);\n});\n\nit('deliver() passes context to matched adapter', async () => {\n  const adapter = createMockAdapter({ subjectPrefix: 'relay.test.ctx' });\n  await registry.register(adapter);\n\n  const envelope = createMockEnvelope();\n  const context = { agent: { directory: '/tmp/test', runtime: 'claude-code' as const } };\n  await registry.deliver('relay.test.ctx.event', { ...envelope, subject: 'relay.test.ctx.event' }, context);\n\n  expect(adapter.deliver).toHaveBeenCalledWith(\n    'relay.test.ctx.event',\n    expect.any(Object),\n    context,\n  );\n});\n```\n\n**Acceptance Criteria:**\n- [ ] Existing `deliver()` routing test asserts `DeliveryResult` object (not `true`)\n- [ ] Existing no-match test asserts `null` (not `false`)\n- [ ] New test verifies full `DeliveryResult` with `responseMessageId` is propagated\n- [ ] New test verifies failure `DeliveryResult` is propagated (not swallowed)\n- [ ] New test verifies context is passed through to matched adapter\n- [ ] `pnpm vitest run packages/relay/src/__tests__/adapter-registry.test.ts` passes",
      "activeForm": "Updating adapter-registry tests for DeliveryResult",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": ["2.1", "2.3"]
    },
    {
      "id": "2.3",
      "phase": 2,
      "phaseName": "Test Coverage",
      "subject": "[relay-publish-pipeline-fix] [P2] Update sessions-relay.test.ts — trace ID and error handling tests",
      "description": "Update the existing test file at `apps/server/src/routes/__tests__/sessions-relay.test.ts` to add tests for the real trace ID propagation and improved console endpoint registration error handling.\n\nFirst, read the existing file to understand its test structure and mocking patterns. Then add the following tests:\n\n**New test: real trace ID propagation**\n\n```typescript\nit('returns message ID as trace ID instead of no-trace', async () => {\n  // Mock relayCore.publish to return a known messageId\n  const mockMessageId = 'test-msg-01ABCDEF';\n  mockRelayCore.publish.mockResolvedValue({\n    messageId: mockMessageId,\n    deliveredTo: 1,\n  });\n\n  const response = await request(app)\n    .post(`/api/sessions/${testSessionId}/messages`)\n    .set('X-Client-Id', 'client-1')\n    .send({ content: 'hello' });\n\n  expect(response.status).toBe(202);\n  expect(response.body.traceId).toBe(mockMessageId);\n  expect(response.body.traceId).not.toBe('no-trace');\n});\n```\n\n**New test: console endpoint registration error handling**\n\n```typescript\nit('logs error when endpoint registration fails for non-duplicate reason', async () => {\n  const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});\n\n  mockRelayCore.registerEndpoint.mockRejectedValue(new Error('disk full'));\n  mockRelayCore.publish.mockResolvedValue({\n    messageId: 'msg-1',\n    deliveredTo: 1,\n  });\n\n  const response = await request(app)\n    .post(`/api/sessions/${testSessionId}/messages`)\n    .set('X-Client-Id', 'client-1')\n    .send({ content: 'hello' });\n\n  // Publish should still proceed\n  expect(response.status).toBe(202);\n  // Error should be logged\n  expect(consoleSpy).toHaveBeenCalledWith(\n    expect.stringContaining('publishViaRelay'),\n    expect.stringContaining('disk full'),\n  );\n\n  consoleSpy.mockRestore();\n});\n\nit('silently ignores already-registered endpoint errors', async () => {\n  const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});\n\n  mockRelayCore.registerEndpoint.mockRejectedValue(new Error('endpoint already registered'));\n  mockRelayCore.publish.mockResolvedValue({\n    messageId: 'msg-1',\n    deliveredTo: 1,\n  });\n\n  const response = await request(app)\n    .post(`/api/sessions/${testSessionId}/messages`)\n    .set('X-Client-Id', 'client-1')\n    .send({ content: 'hello' });\n\n  expect(response.status).toBe(202);\n  expect(consoleSpy).not.toHaveBeenCalled();\n\n  consoleSpy.mockRestore();\n});\n```\n\nNote: Adapt the mock names and setup to match the existing test file's patterns. The test file likely uses `supertest` (aliased as `request`) and has a mock `relayCore` object. Consult the existing test setup in the file to ensure consistent patterns.\n\n**Acceptance Criteria:**\n- [ ] Test verifies `traceId` equals `messageId` in 202 response (not `'no-trace'`)\n- [ ] Test verifies non-duplicate registration errors are logged via `console.error`\n- [ ] Test verifies duplicate registration errors ('already registered') are silently ignored\n- [ ] Test verifies publish proceeds even when endpoint registration fails\n- [ ] All existing sessions-relay tests continue to pass\n- [ ] `pnpm vitest run apps/server/src/routes/__tests__/sessions-relay.test.ts` passes",
      "activeForm": "Updating sessions-relay tests for trace ID and error handling",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["1.5"],
      "parallelWith": ["2.1", "2.2"]
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Documentation",
      "subject": "[relay-publish-pipeline-fix] [P3] Update architecture docs and changelog",
      "description": "Update `contributing/architecture.md` and `CHANGELOG.md` to document the unified fan-out pattern and the race condition edge case.\n\n**File 1: `contributing/architecture.md`**\n\nFind the Relay section (search for 'Relay' or 'relay-core') and add a subsection about the publish pipeline:\n\n```markdown\n### Relay Publish Pipeline — Unified Fan-Out\n\nThe `RelayCore.publish()` method uses a unified fan-out model: both Maildir endpoints and adapter delivery are attempted before any dead-letter decision is made. This ensures adapter-only subjects (like `relay.agent.*` handled by `ClaudeCodeAdapter`) receive messages even when no Maildir endpoints are registered.\n\nPipeline steps:\n1. Validate subject format\n2. Access control check\n3. Rate limit check (per-sender)\n4. Build envelope with budget\n5. Deliver to matching Maildir endpoints (may be zero)\n6. Deliver to matching adapter via `deliverToAdapter()` (timeout-protected, 30s)\n7. Dead-letter only when `deliveredTo === 0`\n\nAdapter delivery includes SQLite indexing (with `adapter:` prefixed endpoint hash) for audit trail completeness.\n\n**Known edge case — POST/SSE race:** When a client sends a message via POST and simultaneously establishes an SSE subscription, there is a window where the subscription may not yet be active when the response arrives. The subscription dispatch in `publish()` mitigates this for most cases, but it is not guaranteed for the very first message. This is a known limitation, not a bug.\n```\n\n**File 2: `CHANGELOG.md`**\n\nAdd an entry under `[Unreleased]` > `Fixed` (create the section if it does not exist):\n\n```markdown\n### Fixed\n\n- **relay**: Fix critical publish pipeline bug where adapter delivery was skipped when no Maildir endpoints matched the target subject. This blocked all Relay-routed chat messages and Pulse scheduled dispatches. The publish method now uses a unified fan-out model where both Maildir and adapter delivery are attempted before dead-lettering.\n- **relay**: Propagate rich `DeliveryResult` from adapters through the publish pipeline instead of discarding it as a boolean\n- **relay**: Add 30-second timeout protection for adapter delivery\n- **relay**: Index adapter-delivered messages in SQLite with `adapter:` prefix for audit trail completeness\n- **server**: Return real trace ID (message ULID) instead of hardcoded `'no-trace'` from `publishViaRelay()`\n- **server**: Improve console endpoint registration error handling — only ignore expected 'already registered' errors\n```\n\n**Acceptance Criteria:**\n- [ ] `contributing/architecture.md` documents the unified fan-out pattern\n- [ ] `contributing/architecture.md` documents the POST/SSE race condition as a known edge case\n- [ ] `CHANGELOG.md` has entries under `[Unreleased]` > `Fixed` for all changes\n- [ ] No new documentation files are created",
      "activeForm": "Updating architecture docs and changelog",
      "size": "small",
      "priority": "low",
      "dependencies": ["1.5"],
      "parallelWith": ["3.2"]
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "Documentation",
      "subject": "[relay-publish-pipeline-fix] [P3] Update spec manifest status",
      "description": "Update the spec status in `specs/manifest.json` and the spec frontmatter in `specs/relay-publish-pipeline-fix/02-specification.md`.\n\n**File 1: `specs/manifest.json`**\n\nFind the entry for `relay-publish-pipeline-fix` (number 70) and update its `status` field:\n\n```json\n{\n  \"number\": 70,\n  \"slug\": \"relay-publish-pipeline-fix\",\n  \"title\": \"Relay Publish Pipeline Fix & Adapter System Improvements\",\n  \"created\": \"2026-02-27\",\n  \"status\": \"in-progress\"\n}\n```\n\n**File 2: `specs/relay-publish-pipeline-fix/02-specification.md`**\n\nUpdate the frontmatter `status` from `draft` to `in-progress`:\n\n```yaml\n---\nslug: relay-publish-pipeline-fix\nnumber: 70\ncreated: 2026-02-27\nstatus: in-progress\n---\n```\n\nAlso update the `**Status:**` line in the body from `Draft` to `In Progress`.\n\n**Acceptance Criteria:**\n- [ ] `specs/manifest.json` entry for spec 70 has `status: 'in-progress'`\n- [ ] Spec frontmatter has `status: in-progress`\n- [ ] Spec body status line reads `In Progress`",
      "activeForm": "Updating spec manifest status",
      "size": "small",
      "priority": "low",
      "dependencies": [],
      "parallelWith": ["3.1"]
    }
  ]
}
