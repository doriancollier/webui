{
  "spec": "specs/server-review-remediation-r3/02-specification.md",
  "slug": "server-review-remediation-r3",
  "generatedAt": "2026-02-28T12:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Security",
      "subject": "[server-review-remediation-r3] [P1] Hide internal error messages in production (C1)",
      "description": "Fix the error handler middleware to suppress internal error details in production.\n\n**File:** `apps/server/src/middleware/error-handler.ts`\n\n**Change:** Modify the `errorHandler` function to check `NODE_ENV` and only expose the real error message in non-production environments. In production, return a generic \"Internal Server Error\" message.\n\n**Implementation:**\n\n```typescript\nexport function errorHandler(err: Error, _req: Request, res: Response, _next: NextFunction): void {\n  logger.error('[DorkOS Error]', err.message, err.stack);\n  const isDev = process.env.NODE_ENV !== 'production';\n  res.status(500).json({\n    error: isDev ? err.message : 'Internal Server Error',\n    code: 'INTERNAL_ERROR',\n  });\n}\n```\n\n**Key points:**\n- Always log the full error (message + stack) regardless of environment\n- Only expose `err.message` to clients when `NODE_ENV !== 'production'`\n- Include a stable `code: 'INTERNAL_ERROR'` field in all environments\n- This prevents leaking DB paths, stack traces, and internal details to production clients\n\n**Acceptance criteria:**\n- In production mode, error responses contain `\"Internal Server Error\"` not the actual error message\n- In development mode, error responses still contain the actual error message\n- The `code` field is always `'INTERNAL_ERROR'`\n- `pnpm typecheck` passes",
      "activeForm": "Hiding internal error messages in production",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.2", "1.3"]
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Security",
      "subject": "[server-review-remediation-r3] [P1] Add boundary checks to PATCH and stream routes (C2)",
      "description": "Add `assertBoundary` calls to two session routes that currently accept `cwd` query parameters without validating them against the configured directory boundary.\n\n**File:** `apps/server/src/routes/sessions.ts`\n\n**Change 1 — PATCH route (around line 133):** Add boundary validation before using the `cwd` parameter:\n\n```typescript\nrouter.patch('/:id', async (req, res) => {\n  // ... existing validation ...\n  const cwd = (req.query.cwd as string) || vaultRoot;\n  if (!(await assertBoundary(cwd, res))) return;  // ADD THIS LINE\n  const session = await transcriptReader.getSession(cwd, req.params.id);\n  // ... rest unchanged ...\n});\n```\n\n**Change 2 — Stream route (around line 313):** Make the handler async and add boundary validation:\n\n```typescript\nrouter.get('/:id/stream', async (req, res) => {  // Make async if not already\n  const sessionId = req.params.id;\n  const cwd = (req.query.cwd as string) || vaultRoot;\n  if (!(await assertBoundary(cwd, res))) return;  // ADD THIS LINE\n  // ... rest unchanged ...\n  sessionBroadcaster.registerClient(sessionId, cwd, res, clientId);\n});\n```\n\n**Key points:**\n- `assertBoundary` is already imported and used in other routes in this file — just add calls to these two missing routes\n- The stream route handler may need to be changed from sync to async to support the `await assertBoundary()` call\n- Without this fix, an attacker can read session data from arbitrary directories via `?cwd=/etc/passwd`\n\n**Acceptance criteria:**\n- PATCH `/:id` with `?cwd=/etc/passwd` returns 403\n- GET `/:id/stream` with `?cwd=/etc/passwd` returns 403\n- Normal requests with valid `cwd` values still work\n- `pnpm typecheck` passes",
      "activeForm": "Adding boundary checks to PATCH and stream routes",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1", "1.3"]
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Security",
      "subject": "[server-review-remediation-r3] [P1] Add prototype pollution guard to deepMerge (I4)",
      "description": "Add a guard against prototype pollution in the `deepMerge` function used by the config PATCH route.\n\n**File:** `apps/server/src/routes/config.ts` (around lines 20-47)\n\n**Implementation:** Add a `DANGEROUS_KEYS` set and filter at the top of the merge loop:\n\n```typescript\nconst DANGEROUS_KEYS = new Set(['__proto__', 'constructor', 'prototype']);\n\nfunction deepMerge(\n  target: Record<string, unknown>,\n  source: Record<string, unknown>\n): Record<string, unknown> {\n  const result = { ...target };\n  for (const [key, sourceValue] of Object.entries(source)) {\n    if (DANGEROUS_KEYS.has(key)) continue;  // ADD THIS LINE\n    // ... rest of the loop body unchanged ...\n  }\n  return result;\n}\n```\n\n**Key points:**\n- The `DANGEROUS_KEYS` set should be defined as a module-level constant outside the function\n- This prevents attackers from injecting `{\"__proto__\": {\"polluted\": true}}` via the config PATCH endpoint\n- `Object.entries()` will include `__proto__` if it's a regular own property on the parsed JSON object\n- The guard must filter all three dangerous keys: `__proto__`, `constructor`, `prototype`\n\n**Acceptance criteria:**\n- `deepMerge({}, JSON.parse('{\"__proto__\": {\"polluted\": true}}'))` does not pollute `Object.prototype`\n- `deepMerge({}, { constructor: { polluted: true } })` does not modify `Object.constructor`\n- Normal config merge operations still work correctly\n- `pnpm typecheck` passes",
      "activeForm": "Adding prototype pollution guard to deepMerge",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1", "1.2"]
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "File Splits",
      "subject": "[server-review-remediation-r3] [P2] Split mcp-tool-server.ts into domain modules (C3)",
      "description": "Split the 940-line `mcp-tool-server.ts` into 8 smaller domain-specific modules under a new `mcp-tools/` directory.\n\n**Current file:** `apps/server/src/services/core/mcp-tool-server.ts` (940 lines)\n\n**Target structure:**\n```\napps/server/src/services/core/mcp-tools/\n  index.ts           # createDorkOsToolServer() composition root (~80 lines)\n  types.ts           # McpToolDeps interface + shared types (~30 lines)\n  core-tools.ts      # ping, get_server_info, get_session_count (~60 lines)\n  pulse-tools.ts     # list/create/update/delete schedules, run history (~130 lines)\n  relay-tools.ts     # relay_send, relay_inbox, relay_list, relay_test (~120 lines)\n  binding-tools.ts   # binding_list, binding_create, binding_delete (~80 lines)\n  mesh-tools.ts      # discover, register, list, deny, unregister, status, inspect, topology (~200 lines)\n  agent-tools.ts     # agent_get_current, resolve, create, update (~100 lines)\n```\n\n**Step 1 — Create `types.ts`:** Extract the `McpToolDeps` interface and any shared type definitions from the current file.\n\n**Step 2 — Create domain modules:** Each module exports a single registration function:\n\n```typescript\n// Example: pulse-tools.ts\nimport { tool } from '@anthropic-ai/claude-agent-sdk';\nimport { z } from 'zod';\nimport type { McpToolDeps } from './types.js';\n\nexport function registerPulseTools(\n  server: ReturnType<typeof import('@anthropic-ai/claude-agent-sdk').createSdkMcpServer>,\n  deps: McpToolDeps,\n): void {\n  if (!deps.pulseStore) return;\n  // ... move all pulse tool registrations here ...\n}\n```\n\nApply the same pattern for: `registerCoreTools`, `registerRelayTools`, `registerBindingTools`, `registerMeshTools`, `registerAgentTools`.\n\n**Step 3 — Create composition root (`index.ts`):**\n\n```typescript\nimport { createSdkMcpServer } from '@anthropic-ai/claude-agent-sdk';\nimport type { McpToolDeps } from './types.js';\nimport { registerCoreTools } from './core-tools.js';\nimport { registerPulseTools } from './pulse-tools.js';\nimport { registerRelayTools } from './relay-tools.js';\nimport { registerBindingTools } from './binding-tools.js';\nimport { registerMeshTools } from './mesh-tools.js';\nimport { registerAgentTools } from './agent-tools.js';\n\nexport type { McpToolDeps } from './types.js';\n\nexport function createDorkOsToolServer(deps: McpToolDeps) {\n  const server = createSdkMcpServer({ name: 'dorkos-tools', version: '1.0.0' });\n\n  registerCoreTools(server, deps);\n  registerPulseTools(server, deps);\n  registerRelayTools(server, deps);\n  registerBindingTools(server, deps);\n  registerMeshTools(server, deps);\n  registerAgentTools(server, deps);\n\n  return server;\n}\n```\n\n**Step 4 — Update imports:** Find all files that import from `'../services/core/mcp-tool-server.js'` (or similar paths) and update them to import from `'../services/core/mcp-tools/index.js'`. Alternatively, create a barrel re-export at the old path.\n\n**Step 5 — Delete the old file:** Remove `mcp-tool-server.ts` after all imports are updated.\n\n**Acceptance criteria:**\n- No single file in `mcp-tools/` exceeds 500 lines\n- All imports of `createDorkOsToolServer` and `McpToolDeps` resolve correctly\n- `pnpm typecheck` passes\n- `pnpm test -- --run` passes (existing tests still work)\n- The old `mcp-tool-server.ts` is deleted",
      "activeForm": "Splitting mcp-tool-server.ts into domain modules",
      "size": "large",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["2.2"]
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "File Splits",
      "subject": "[server-review-remediation-r3] [P2] Extract adapter-error.ts and adapter-config.ts from adapter-manager.ts (C4)",
      "description": "Split the 957-line `adapter-manager.ts` by extracting error handling and config management into separate modules.\n\n**Current file:** `apps/server/src/services/relay/adapter-manager.ts` (957 lines)\n\n**Extract 1 — `adapter-error.ts` (~20 lines):**\n\nExtract the `AdapterError` class and any associated error code types:\n\n```typescript\n// apps/server/src/services/relay/adapter-error.ts\nexport class AdapterError extends Error {\n  // ... move class definition here with error codes type ...\n}\n```\n\n**Extract 2 — `adapter-config.ts` (~200 lines):**\n\nExtract config loading, validation, merge, and hot-reload logic:\n\n```typescript\n// apps/server/src/services/relay/adapter-config.ts\nexport function loadAdapterConfig(configPath: string) { /* ... */ }\nexport function mergeAdapterConfig(existing: unknown, incoming: unknown) { /* ... */ }\nexport function watchAdapterConfig(configPath: string, onChange: () => void) { /* ... */ }\nexport const AdapterConfigSchema = z.object({ /* ... */ });\n```\n\n**Update `adapter-manager.ts`:** Import from the new modules and delegate config operations. The main `AdapterManager` class stays in `adapter-manager.ts` but should shrink to under 450 lines.\n\n**Key points:**\n- Identify all config-related functions and the AdapterError class in the current file\n- Move them to the new files with proper exports\n- Update all internal references within adapter-manager.ts to import from the new modules\n- Check for any external imports of AdapterError or config functions and update those too\n\n**Acceptance criteria:**\n- `adapter-manager.ts` is under 500 lines (target: <450)\n- `adapter-error.ts` and `adapter-config.ts` exist with the extracted code\n- All imports resolve correctly\n- `pnpm typecheck` passes\n- `pnpm test -- --run` passes",
      "activeForm": "Extracting adapter-error.ts and adapter-config.ts from adapter-manager.ts",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["2.1"]
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Performance & Reliability",
      "subject": "[server-review-remediation-r3] [P3] Add session map cap with MAX_CONCURRENT (I1)",
      "description": "Add a maximum concurrent session limit to prevent unbounded memory growth from session creation.\n\n**File 1:** `apps/server/src/config/constants.ts`\n\nAdd `MAX_CONCURRENT` to the existing `SESSIONS` constant:\n\n```typescript\nexport const SESSIONS = {\n  TIMEOUT_MS: 30 * 60 * 1000,\n  HEALTH_CHECK_INTERVAL_MS: 5 * 60 * 1000,\n  MAX_CONCURRENT: 50,  // ADD THIS\n} as const;\n```\n\n**File 2:** `apps/server/src/services/core/agent-manager.ts`\n\nAdd a guard in `ensureSession()` (or the method that creates new sessions):\n\n```typescript\nensureSession(sessionId: string, opts: { ... }): void {\n  if (!this.sessions.has(sessionId)) {\n    if (this.sessions.size >= SESSIONS.MAX_CONCURRENT) {\n      throw new Error(`Maximum concurrent sessions (${SESSIONS.MAX_CONCURRENT}) reached`);\n    }\n    this.sessions.set(sessionId, { ... });\n  }\n}\n```\n\nMake sure `SESSIONS` is imported from `'../../config/constants.js'` (or the appropriate relative path).\n\n**File 3:** Route handler (likely `routes/sessions.ts`)\n\nThe route handler that calls `ensureSession` should catch the error and return 503:\n\n```typescript\ntry {\n  agentManager.ensureSession(sessionId, opts);\n} catch (err) {\n  if (err instanceof Error && err.message.includes('Maximum concurrent sessions')) {\n    res.status(503).json({ error: err.message, code: 'SESSION_LIMIT' });\n    return;\n  }\n  throw err;\n}\n```\n\n**Acceptance criteria:**\n- When 50 sessions exist, creating a 51st returns 503\n- Existing sessions are not affected\n- Sessions that expire via health check free up slots\n- `pnpm typecheck` passes",
      "activeForm": "Adding session map cap with MAX_CONCURRENT",
      "size": "small",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["3.2", "3.3", "3.4"]
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "Performance & Reliability",
      "subject": "[server-review-remediation-r3] [P3] Add reverse lookup index for findSession (I2)",
      "description": "Replace the O(n) linear scan in `findSession()` with an O(1) reverse lookup using a secondary Map.\n\n**File:** `apps/server/src/services/core/agent-manager.ts`\n\n**Step 1 — Add the reverse index map:**\n\n```typescript\nprivate sessions = new Map<string, AgentSession>();\nprivate sdkSessionIndex = new Map<string, string>(); // sdkSessionId -> sessionId\n```\n\n**Step 2 — Update `findSession()`:**\n\n```typescript\nprivate findSession(sessionId: string): AgentSession | undefined {\n  const direct = this.sessions.get(sessionId);\n  if (direct) return direct;\n  // O(1) reverse lookup instead of O(n) scan\n  const mappedId = this.sdkSessionIndex.get(sessionId);\n  return mappedId ? this.sessions.get(mappedId) : undefined;\n}\n```\n\n**Step 3 — Populate the index when SDK session ID is assigned:**\n\nFind where `session.sdkSessionId` is set (likely in the streaming/event mapping code) and add:\n\n```typescript\nsession.sdkSessionId = sdkId;\nthis.sdkSessionIndex.set(sdkId, sessionId);\n```\n\n**Step 4 — Clean up the index on session expiry:**\n\nIn `checkSessionHealth()` (or wherever sessions are deleted), add:\n\n```typescript\nif (session.sdkSessionId) {\n  this.sdkSessionIndex.delete(session.sdkSessionId);\n}\nthis.sessions.delete(id);\n```\n\n**Key points:**\n- The current `findSession()` likely does a `for...of` loop over `this.sessions` checking `sdkSessionId` — replace that with the Map lookup\n- Keep the direct lookup as the first check (most common case)\n- The reverse index must be maintained at every point where `sdkSessionId` changes or sessions are removed\n\n**Acceptance criteria:**\n- `findSession()` no longer iterates over all sessions\n- Tool approval and answer submission still work correctly\n- `pnpm typecheck` passes\n- `pnpm test -- --run` passes",
      "activeForm": "Adding reverse lookup index for findSession",
      "size": "small",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["3.1", "3.3", "3.4"]
    },
    {
      "id": "3.3",
      "phase": 3,
      "phaseName": "Performance & Reliability",
      "subject": "[server-review-remediation-r3] [P3] Add SSE connection limits (I5)",
      "description": "Add per-session and global SSE connection limits to prevent resource exhaustion.\n\n**File 1:** `apps/server/src/config/constants.ts`\n\nAdd a new `SSE` constant:\n\n```typescript\nexport const SSE = {\n  MAX_CLIENTS_PER_SESSION: 10,\n  MAX_TOTAL_CLIENTS: 500,\n} as const;\n```\n\n**File 2:** `apps/server/src/services/session/session-broadcaster.ts`\n\nAdd connection counting, a `getClientCount()` method, and limit enforcement in `registerClient()`:\n\n```typescript\nprivate totalClientCount = 0;\n\ngetClientCount(sessionId?: string): number {\n  if (sessionId) {\n    return this.clients.get(sessionId)?.size ?? 0;\n  }\n  return this.totalClientCount;\n}\n\nregisterClient(sessionId: string, vaultRoot: string, res: Response, clientId?: string): void {\n  if (this.totalClientCount >= SSE.MAX_TOTAL_CLIENTS) {\n    res.status(503).json({ error: 'SSE connection limit reached', code: 'SSE_LIMIT' });\n    return;\n  }\n  const sessionClients = this.clients.get(sessionId);\n  if (sessionClients && sessionClients.size >= SSE.MAX_CLIENTS_PER_SESSION) {\n    res.status(503).json({ error: 'Too many connections for this session', code: 'SSE_SESSION_LIMIT' });\n    return;\n  }\n  this.totalClientCount++;\n  res.on('close', () => { this.totalClientCount--; });\n  // ... existing registration logic ...\n}\n```\n\n**Key points:**\n- Import `SSE` from `'../../config/constants.js'`\n- The `totalClientCount` must be decremented in the `close` event handler — make sure this is wired up before the existing close handler or integrated into it\n- The `registerClient` method must send the error response and return early BEFORE setting up the SSE stream\n- The `getClientCount()` method is optional but useful for monitoring\n\n**Acceptance criteria:**\n- 11th connection to the same session returns 503 with code `SSE_SESSION_LIMIT`\n- 501st global connection returns 503 with code `SSE_LIMIT`\n- Disconnected clients properly decrement the counter\n- `pnpm typecheck` passes",
      "activeForm": "Adding SSE connection limits",
      "size": "small",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["3.1", "3.2", "3.4"]
    },
    {
      "id": "3.4",
      "phase": 3,
      "phaseName": "Performance & Reliability",
      "subject": "[server-review-remediation-r3] [P3] Fix SSE keepalive race condition (I6)",
      "description": "Fix a race condition where the keepalive interval can attempt to write to a closed SSE response.\n\n**File:** `apps/server/src/routes/relay.ts` (around lines 357-364)\n\nReplace the existing keepalive interval with a guarded version:\n\n```typescript\nconst keepalive = setInterval(() => {\n  if (res.writableEnded) {\n    clearInterval(keepalive);\n    return;\n  }\n  try {\n    res.write(`: keepalive\\n\\n`);\n  } catch {\n    clearInterval(keepalive);\n  }\n}, 15_000);\n```\n\n**Key points:**\n- Check `res.writableEnded` before attempting to write — this is the Node.js way to check if a writable stream has been closed\n- Wrap the `res.write()` in a try/catch to handle the case where the connection closes between the check and the write\n- Clear the interval in both the guard check and the catch block\n- Also ensure the interval is cleared in the `res.on('close')` handler if not already done\n\n**Acceptance criteria:**\n- No unhandled write errors when SSE clients disconnect during a keepalive cycle\n- Keepalive still works normally for active connections\n- `pnpm typecheck` passes",
      "activeForm": "Fixing SSE keepalive race condition",
      "size": "small",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["3.1", "3.2", "3.3"]
    },
    {
      "id": "4.1",
      "phase": 4,
      "phaseName": "Code Quality",
      "subject": "[server-review-remediation-r3] [P4] Centralize vault root resolution (I7 + M1)",
      "description": "Create a single source of truth for the default CWD / vault root resolution, eliminating duplicated `__dirname` + `path.resolve` logic across multiple route files.\n\n**Step 1 — Create `apps/server/src/lib/resolve-root.ts`:**\n\n```typescript\nimport { env } from '../env.js';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nconst thisDir = path.dirname(fileURLToPath(import.meta.url));\n\n/** Default CWD for the server -- prefers env var, falls back to repo root. */\nexport const DEFAULT_CWD: string = env.DORKOS_DEFAULT_CWD ?? path.resolve(thisDir, '../../../');\n```\n\n**Step 2 — Update consumers:**\n\n**`routes/sessions.ts`:** Replace the inline `vaultRoot` computation (which uses `__dirname` and `fileURLToPath`) with:\n```typescript\nimport { DEFAULT_CWD } from '../lib/resolve-root.js';\n// Remove: import { fileURLToPath } from 'node:url';\n// Remove: const __dirname = path.dirname(fileURLToPath(import.meta.url));\n// Remove: const vaultRoot = env.DORKOS_DEFAULT_CWD ?? path.resolve(__dirname, '../../../');\nconst vaultRoot = DEFAULT_CWD;\n```\nThis also fixes M1 (manual `__dirname` polyfill).\n\n**`routes/relay.ts`:** Replace inline `vaultRoot` computation with `DEFAULT_CWD` import.\n\n**`routes/commands.ts`:** Replace `defaultRoot` computation with `DEFAULT_CWD` import.\n\n**`services/core/agent-manager.ts`:** Use `DEFAULT_CWD` as the fallback in the constructor (if it has its own fallback logic).\n\n**Key points:**\n- The `resolve-root.ts` file must resolve the path relative to `lib/` (which is at `apps/server/src/lib/`), so `'../../../'` resolves up to the repo root from the compiled `dist/lib/` directory\n- The env var `DORKOS_DEFAULT_CWD` takes priority when set (used by CLI, Obsidian plugin)\n- After this change, there should be exactly ONE place that computes the default working directory\n\n**Acceptance criteria:**\n- `resolve-root.ts` exists and exports `DEFAULT_CWD`\n- No file in `routes/` or `services/` computes its own vault root / default CWD inline\n- No manual `__dirname` polyfill remains in `sessions.ts` (M1 fix)\n- `pnpm typecheck` passes\n- `pnpm test -- --run` passes",
      "activeForm": "Centralizing vault root resolution",
      "size": "medium",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": []
    },
    {
      "id": "4.2",
      "phase": 4,
      "phaseName": "Code Quality",
      "subject": "[server-review-remediation-r3] [P4] Add UUID validation and sendError helpers to route-utils.ts (M2 + M3)",
      "description": "Add a `parseSessionId` UUID validator and a `sendError` helper to the route utilities, then apply UUID validation to all session routes.\n\n**File:** `apps/server/src/lib/route-utils.ts` (add to existing file)\n\n**Add `parseSessionId`:**\n\n```typescript\nimport { z } from 'zod';\nimport type { Response } from 'express';\n\nconst uuidSchema = z.string().uuid();\n\n/**\n * Validates a route param as a UUID. Sends 400 and returns null if invalid.\n */\nexport function parseSessionId(value: string, res: Response): string | null {\n  const result = uuidSchema.safeParse(value);\n  if (!result.success) {\n    res.status(400).json({ error: 'Invalid session ID format', code: 'INVALID_ID' });\n    return null;\n  }\n  return result.data;\n}\n```\n\n**Add `sendError`:**\n\n```typescript\n/**\n * Sends a standardized JSON error response.\n */\nexport function sendError(\n  res: Response,\n  status: number,\n  error: string,\n  code: string,\n  extra?: Record<string, unknown>,\n): void {\n  res.status(status).json({ error, code, ...extra });\n}\n```\n\n**Apply `parseSessionId` in `routes/sessions.ts`** for all routes that accept `:id`:\n\n```typescript\nimport { parseSessionId } from '../lib/route-utils.js';\n\nrouter.get('/:id', async (req, res) => {\n  const sessionId = parseSessionId(req.params.id, res);\n  if (!sessionId) return;\n  // ... rest unchanged, use sessionId instead of req.params.id ...\n});\n```\n\nApply to these routes: `GET /:id`, `PATCH /:id`, `POST /:id/messages`, `POST /:id/approve`, `POST /:id/deny`, `POST /:id/submit-answers`, `GET /:id/stream`.\n\n**Apply `sendError` incrementally in `routes/sessions.ts`** to standardize error response shapes:\n\n```typescript\n// Before:\nres.status(404).json({ error: 'Session not found' });\n// After:\nsendError(res, 404, 'Session not found', 'SESSION_NOT_FOUND');\n```\n\nThis is a gradual migration. Focus on `sessions.ts` in this task. Other routes can be updated later.\n\n**Acceptance criteria:**\n- `parseSessionId` and `sendError` are exported from `route-utils.ts`\n- All 7 session routes with `:id` param use `parseSessionId` for validation\n- Invalid session IDs (non-UUID) return 400 with code `INVALID_ID`\n- At least the most inconsistent error responses in `sessions.ts` use `sendError`\n- `pnpm typecheck` passes",
      "activeForm": "Adding UUID validation and sendError helpers",
      "size": "medium",
      "priority": "low",
      "dependencies": ["4.1"],
      "parallelWith": []
    },
    {
      "id": "4.3",
      "phase": 4,
      "phaseName": "Code Quality",
      "subject": "[server-review-remediation-r3] [P4] Replace unsafe type assertions in index.ts with Zod parsing (M4)",
      "description": "Replace three `as` type assertions in the server entry point with Zod schema parsing for type-safe config extraction.\n\n**File:** `apps/server/src/index.ts`\n\n**Step 1 — Add config schemas near the top of the file:**\n\n```typescript\nimport { z } from 'zod';\n\nconst SchedulerConfigSchema = z.object({\n  enabled: z.boolean().default(false),\n  maxConcurrentRuns: z.number().default(5),\n  timezone: z.string().nullable().default(null),\n  retentionCount: z.number().default(100),\n}).default({});\n\nconst RelayConfigSchema = z.object({\n  enabled: z.boolean().default(false),\n  dataDir: z.string().nullable().optional(),\n}).default({});\n\nconst MeshConfigSchema = z.object({\n  enabled: z.boolean().default(false),\n}).default({});\n```\n\n**Step 2 — Replace the `as` casts:**\n\n```typescript\n// Before (unsafe):\n// const schedulerConfig = configManager.get('scheduler') as SchedulerConfig;\n// const relayConfig = configManager.get('relay') as RelayConfig;\n// const meshConfig = configManager.get('mesh') as MeshConfig;\n\n// After (safe):\nconst schedulerConfig = SchedulerConfigSchema.parse(configManager.get('scheduler') ?? {});\nconst relayConfig = RelayConfigSchema.parse(configManager.get('relay') ?? {});\nconst meshConfig = MeshConfigSchema.parse(configManager.get('mesh') ?? {});\n```\n\n**Key points:**\n- The `.default({})` on each schema means `parse(undefined)` will produce a valid default object\n- The `?? {}` is belt-and-suspenders for `null` returns from `configManager.get()`\n- If the config contains unexpected values, Zod will throw a descriptive error at startup rather than silently producing a wrongly-typed object\n- Remove any now-unused type imports (e.g., `SchedulerConfig`, `RelayConfig`, `MeshConfig` if they were only used for the casts)\n\n**Acceptance criteria:**\n- No `as` type assertions remain for scheduler, relay, or mesh config extraction\n- Server starts correctly with default config\n- Server starts correctly with populated config values\n- `pnpm typecheck` passes",
      "activeForm": "Replacing unsafe type assertions with Zod parsing",
      "size": "small",
      "priority": "low",
      "dependencies": [],
      "parallelWith": ["4.4", "4.5"]
    },
    {
      "id": "4.4",
      "phase": 4,
      "phaseName": "Code Quality",
      "subject": "[server-review-remediation-r3] [P4] Add API 404 catch-all before SPA (M6)",
      "description": "Add an API-specific 404 handler so that requests to nonexistent `/api/*` routes return a proper JSON error instead of falling through to the SPA catch-all.\n\n**File:** `apps/server/src/app.ts`\n\nAdd the API 404 handler after all `/api` routes are mounted but before the production SPA catch-all block:\n\n```typescript\n// API 404 -- must come after all /api routes, before SPA catch-all\napp.use('/api', (_req, res) => {\n  res.status(404).json({ error: 'Not found', code: 'API_NOT_FOUND' });\n});\n\n// In production, serve the built React app\nif (env.NODE_ENV === 'production') {\n  // ... existing SPA catch-all ...\n}\n```\n\n**Key points:**\n- This must be mounted unconditionally (both dev and production) so API 404s always return JSON\n- It must come AFTER all other `/api` route registrations\n- It must come BEFORE the SPA static file serving and wildcard route\n- Without this, requests like `GET /api/nonexistent` return the React SPA HTML in production (confusing for API consumers)\n- The handler uses `app.use('/api', ...)` which matches any method on any `/api/*` path\n\n**Acceptance criteria:**\n- `GET /api/nonexistent` returns 404 JSON with code `API_NOT_FOUND`\n- `POST /api/nonexistent` returns 404 JSON with code `API_NOT_FOUND`\n- Existing API routes still work normally\n- In production, non-API routes still serve the SPA\n- `pnpm typecheck` passes",
      "activeForm": "Adding API 404 catch-all before SPA",
      "size": "small",
      "priority": "low",
      "dependencies": [],
      "parallelWith": ["4.3", "4.5"]
    },
    {
      "id": "4.5",
      "phase": 4,
      "phaseName": "Code Quality",
      "subject": "[server-review-remediation-r3] [P4] Replace Record<string, unknown> casts in agent-manager.ts (M7)",
      "description": "Replace unsafe `as Record<string, unknown>` type assertions in `agent-manager.ts` with a type-safe approach using an interface.\n\n**File:** `apps/server/src/services/core/agent-manager.ts`\n\n**Step 1 — Define the extended options interface:**\n\n```typescript\ninterface ExtendedQueryOptions {\n  model?: string;\n  mcpServers?: Record<string, unknown>;\n}\n```\n\n**Step 2 — Replace the casts in `sendMessage()` (or wherever SDK query options are built):**\n\n```typescript\n// Before (unsafe):\n// const options = { ...baseOptions } as Record<string, unknown>;\n// if (session.model) (options as any).model = session.model;\n\n// After (safe):\nconst extendedOptions: ExtendedQueryOptions = {};\nif (session.model) {\n  extendedOptions.model = session.model;\n}\nif (Object.keys(this.mcpServers).length > 0) {\n  extendedOptions.mcpServers = this.mcpServers;\n}\n\nconst sdkOptions = {\n  ...baseOptions,\n  ...extendedOptions,\n};\n```\n\n**Key points:**\n- Find all instances of `as Record<string, unknown>` in the file and replace them\n- The `ExtendedQueryOptions` interface should match what the SDK's `query()` function actually accepts\n- If the SDK types are more specific, align the interface with those types\n- This eliminates the possibility of adding arbitrary untyped properties to the options object\n\n**Acceptance criteria:**\n- No `as Record<string, unknown>` casts remain in `agent-manager.ts`\n- Model selection and MCP server injection still work correctly\n- `pnpm typecheck` passes",
      "activeForm": "Replacing Record<string, unknown> casts in agent-manager",
      "size": "small",
      "priority": "low",
      "dependencies": [],
      "parallelWith": ["4.3", "4.4"]
    },
    {
      "id": "5.1",
      "phase": 5,
      "phaseName": "Testing",
      "subject": "[server-review-remediation-r3] [P5] Add error handler production mode test (M8-C1)",
      "description": "Add a test file verifying that the error handler hides internal error details in production mode.\n\n**File:** `apps/server/src/middleware/__tests__/error-handler-prod.test.ts`\n\n```typescript\nimport { describe, it, expect, vi, afterEach } from 'vitest';\nimport type { Request, Response, NextFunction } from 'express';\n\n// Import the error handler (adjust path based on actual export)\nimport { errorHandler } from '../error-handler.js';\n\nconst mockReq = {} as Request;\nconst mockNext = vi.fn() as NextFunction;\n\nfunction mockResponse() {\n  const res = {\n    status: vi.fn().mockReturnThis(),\n    json: vi.fn().mockReturnThis(),\n  } as unknown as Response;\n  return res;\n}\n\ndescribe('errorHandler in production', () => {\n  const originalEnv = process.env.NODE_ENV;\n\n  afterEach(() => {\n    process.env.NODE_ENV = originalEnv;\n  });\n\n  it('hides error message in production', () => {\n    process.env.NODE_ENV = 'production';\n    const res = mockResponse();\n    errorHandler(new Error('DB connection failed at /internal/path'), mockReq, res, mockNext);\n    expect(res.json).toHaveBeenCalledWith({\n      error: 'Internal Server Error',\n      code: 'INTERNAL_ERROR',\n    });\n  });\n\n  it('shows error message in development', () => {\n    process.env.NODE_ENV = 'development';\n    const res = mockResponse();\n    errorHandler(new Error('Specific error'), mockReq, res, mockNext);\n    expect(res.json).toHaveBeenCalledWith({\n      error: 'Specific error',\n      code: 'INTERNAL_ERROR',\n    });\n  });\n});\n```\n\n**Key points:**\n- Mock `console.error` or the logger if the error handler logs (spy and restore)\n- Restore `process.env.NODE_ENV` in `afterEach` to avoid polluting other tests\n- The test verifies both production (hidden) and development (visible) behavior\n- Create the `__tests__/` directory under `middleware/` if it does not exist\n\n**Acceptance criteria:**\n- Test file exists and both tests pass\n- `pnpm vitest run apps/server/src/middleware/__tests__/error-handler-prod.test.ts` passes",
      "activeForm": "Adding error handler production mode test",
      "size": "small",
      "priority": "low",
      "dependencies": ["1.1"],
      "parallelWith": ["5.2", "5.3", "5.4"]
    },
    {
      "id": "5.2",
      "phase": 5,
      "phaseName": "Testing",
      "subject": "[server-review-remediation-r3] [P5] Add boundary validation tests for PATCH and stream routes (M8-C2)",
      "description": "Add tests verifying that PATCH and stream session routes reject `cwd` values outside the configured boundary.\n\n**File:** `apps/server/src/routes/__tests__/sessions-boundary.test.ts`\n\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport request from 'supertest';\n// Import or build the Express app with session routes mounted\n\ndescribe('session routes boundary validation', () => {\n  it('PATCH /:id rejects cwd outside boundary', async () => {\n    const res = await request(app)\n      .patch('/api/sessions/test-id?cwd=/etc/passwd')\n      .send({ permissionMode: 'default' });\n    expect(res.status).toBe(403);\n  });\n\n  it('GET /:id/stream rejects cwd outside boundary', async () => {\n    const res = await request(app)\n      .get('/api/sessions/test-id/stream?cwd=/etc/passwd');\n    expect(res.status).toBe(403);\n  });\n});\n```\n\n**Key points:**\n- You may need to set up a test Express app with the session routes mounted and a boundary configured\n- If the existing test infrastructure already has an app setup, reuse that pattern\n- The boundary validation returns 403, so check for that status code\n- The exact test setup depends on how `assertBoundary` and the boundary config work — check existing boundary tests in the codebase for the pattern to follow\n- If supertest is not available, use the same HTTP testing approach used by other route tests\n\n**Acceptance criteria:**\n- Both tests pass\n- Tests verify 403 responses for out-of-boundary `cwd` values\n- `pnpm vitest run apps/server/src/routes/__tests__/sessions-boundary.test.ts` passes",
      "activeForm": "Adding boundary validation tests for session routes",
      "size": "small",
      "priority": "low",
      "dependencies": ["1.2"],
      "parallelWith": ["5.1", "5.3", "5.4"]
    },
    {
      "id": "5.3",
      "phase": 5,
      "phaseName": "Testing",
      "subject": "[server-review-remediation-r3] [P5] Add prototype pollution prevention test (M8-I4)",
      "description": "Add a test verifying that the `deepMerge` function filters out prototype pollution keys.\n\n**File:** `apps/server/src/routes/__tests__/config-deepmerge.test.ts`\n\nNote: `deepMerge` is a private function in `config.ts`. You may need to either: (a) export it for testing, (b) test via the PATCH `/api/config` endpoint using supertest, or (c) extract it to a utility file. Choose the approach that fits the codebase best.\n\n**If testing the function directly (after exporting):**\n\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { deepMerge } from '../config.js'; // if exported\n\ndescribe('deepMerge prototype pollution', () => {\n  it('ignores __proto__ keys', () => {\n    const target = { a: 1 };\n    const source = JSON.parse('{\"__proto__\": {\"polluted\": true}}');\n    const result = deepMerge(target, source);\n    expect(({} as any).polluted).toBeUndefined();\n    expect(result).not.toHaveProperty('__proto__');\n  });\n\n  it('ignores constructor keys', () => {\n    const result = deepMerge({}, { constructor: { polluted: true } } as any);\n    expect(({} as any).polluted).toBeUndefined();\n  });\n\n  it('ignores prototype keys', () => {\n    const result = deepMerge({}, { prototype: { polluted: true } } as any);\n    expect(({} as any).polluted).toBeUndefined();\n  });\n\n  it('preserves normal keys', () => {\n    const result = deepMerge({ a: 1 }, { b: 2 });\n    expect(result).toEqual({ a: 1, b: 2 });\n  });\n});\n```\n\n**Key points:**\n- If `deepMerge` is not exported, consider adding a named export for testing (`export { deepMerge as _deepMerge_forTesting }`) or export it normally since it's a pure function\n- The `JSON.parse` approach is important for the `__proto__` test because `{ __proto__: ... }` in source code sets the prototype rather than creating an own property\n- Verify that `Object.prototype` is not polluted after each test\n\n**Acceptance criteria:**\n- All tests pass\n- Prototype pollution is prevented for `__proto__`, `constructor`, and `prototype` keys\n- Normal merge operations still work\n- `pnpm vitest run apps/server/src/routes/__tests__/config-deepmerge.test.ts` passes",
      "activeForm": "Adding prototype pollution prevention test",
      "size": "small",
      "priority": "low",
      "dependencies": ["1.3"],
      "parallelWith": ["5.1", "5.2", "5.4"]
    },
    {
      "id": "5.4",
      "phase": 5,
      "phaseName": "Testing",
      "subject": "[server-review-remediation-r3] [P5] Add UUID validation test (M8-M2)",
      "description": "Add a test verifying the `parseSessionId` UUID validation helper.\n\n**File:** `apps/server/src/lib/__tests__/route-utils.test.ts`\n\n```typescript\nimport { describe, it, expect, vi } from 'vitest';\nimport type { Response } from 'express';\nimport { parseSessionId } from '../route-utils.js';\n\nfunction mockResponse() {\n  const res = {\n    status: vi.fn().mockReturnThis(),\n    json: vi.fn().mockReturnThis(),\n  } as unknown as Response;\n  return res;\n}\n\ndescribe('parseSessionId', () => {\n  it('accepts valid UUID', () => {\n    const res = mockResponse();\n    const result = parseSessionId('550e8400-e29b-41d4-a716-446655440000', res);\n    expect(result).toBe('550e8400-e29b-41d4-a716-446655440000');\n    expect(res.status).not.toHaveBeenCalled();\n  });\n\n  it('rejects non-UUID string', () => {\n    const res = mockResponse();\n    const result = parseSessionId('../../etc/passwd', res);\n    expect(result).toBeNull();\n    expect(res.status).toHaveBeenCalledWith(400);\n    expect(res.json).toHaveBeenCalledWith({\n      error: 'Invalid session ID format',\n      code: 'INVALID_ID',\n    });\n  });\n\n  it('rejects empty string', () => {\n    const res = mockResponse();\n    const result = parseSessionId('', res);\n    expect(result).toBeNull();\n  });\n\n  it('rejects numeric string', () => {\n    const res = mockResponse();\n    const result = parseSessionId('12345', res);\n    expect(result).toBeNull();\n    expect(res.status).toHaveBeenCalledWith(400);\n  });\n});\n```\n\n**Key points:**\n- Create the `__tests__/` directory under `lib/` if it does not exist\n- The mock response must support method chaining (`status` returns `this` so `.json()` can be called)\n- Test edge cases: valid UUID, path traversal attempt, empty string, numeric string\n- If `route-utils.ts` already has tests, add to the existing test file instead of creating a new one\n\n**Acceptance criteria:**\n- All tests pass\n- Valid UUIDs are accepted, invalid strings are rejected with 400\n- `pnpm vitest run apps/server/src/lib/__tests__/route-utils.test.ts` passes",
      "activeForm": "Adding UUID validation test",
      "size": "small",
      "priority": "low",
      "dependencies": ["4.2"],
      "parallelWith": ["5.1", "5.2", "5.3"]
    }
  ]
}
