{
  "spec": "specs/agents-first-class-entity/02-specification.md",
  "slug": "agents-first-class-entity",
  "generatedAt": "2026-02-26T22:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[agents-first-class-entity] [P1] Extend AgentManifestSchema with persona, color, and icon fields",
      "description": "Add four new optional fields to `AgentManifestSchema` in `packages/shared/src/mesh-schemas.ts` and extend `UpdateAgentRequestSchema` with the same fields. Also add three new request/response schemas for the agent identity API.\n\n**Files to modify:**\n- `packages/shared/src/mesh-schemas.ts`\n\n**Implementation Steps:**\n\n1. Add four new fields to `AgentManifestSchema` (after the existing `registeredBy` field):\n\n```typescript\nexport const AgentManifestSchema = z\n  .object({\n    // ... existing fields (id, name, description, runtime, capabilities, behavior, budget, namespace, registeredAt, registeredBy)\n    persona: z.string().max(4000).optional().openapi({\n      description: 'System prompt persona text injected into Claude sessions',\n      example: 'You are backend-bot, an expert in REST API design...',\n    }),\n    personaEnabled: z.boolean().default(true).openapi({\n      description: 'Whether persona text is injected into system prompt',\n    }),\n    color: z.string().optional().openapi({\n      description: 'CSS color override for visual identity (e.g., \"#6366f1\")',\n      example: '#6366f1',\n    }),\n    icon: z.string().optional().openapi({\n      description: 'Emoji override for visual identity',\n      example: '\\u{1F916}',\n    }),\n  })\n  .openapi('AgentManifest');\n```\n\n2. Extend `UpdateAgentRequestSchema` with the new fields:\n\n```typescript\nexport const UpdateAgentRequestSchema = z\n  .object({\n    name: z.string().min(1).optional(),\n    description: z.string().optional(),\n    capabilities: z.array(z.string()).optional(),\n    persona: z.string().max(4000).optional(),\n    personaEnabled: z.boolean().optional(),\n    color: z.string().optional(),\n    icon: z.string().optional(),\n  })\n  .openapi('UpdateAgentRequest');\n```\n\n3. Add three new schemas for the agent identity API endpoints:\n\n```typescript\nexport const ResolveAgentsRequestSchema = z.object({\n  paths: z.array(z.string().min(1)).min(1).max(20),\n}).openapi('ResolveAgentsRequest');\n\nexport const ResolveAgentsResponseSchema = z.object({\n  agents: z.record(z.string(), AgentManifestSchema.nullable()),\n}).openapi('ResolveAgentsResponse');\n\nexport const CreateAgentRequestSchema = z.object({\n  path: z.string().min(1),\n  name: z.string().min(1).optional(),\n  description: z.string().optional(),\n  runtime: AgentRuntimeSchema.optional().default('claude-code'),\n}).openapi('CreateAgentRequest');\n```\n\n4. Export all new types:\n\n```typescript\nexport type ResolveAgentsRequest = z.infer<typeof ResolveAgentsRequestSchema>;\nexport type ResolveAgentsResponse = z.infer<typeof ResolveAgentsResponseSchema>;\nexport type CreateAgentRequest = z.infer<typeof CreateAgentRequestSchema>;\n```\n\n**Unit Tests** (`packages/shared/src/__tests__/mesh-schemas.test.ts`):\n- Test that `persona` field accepts strings up to 4000 chars and rejects longer\n- Test that `personaEnabled` defaults to `true` when omitted\n- Test that `color` and `icon` are optional and accept arbitrary strings\n- Test that `UpdateAgentRequestSchema` accepts partial updates with new fields\n- Test that `ResolveAgentsRequestSchema` validates paths array (min 1, max 20)\n- Test that `CreateAgentRequestSchema` defaults runtime to 'claude-code'\n\n**Acceptance Criteria:**\n- [ ] `AgentManifestSchema` includes `persona`, `personaEnabled`, `color`, `icon` fields\n- [ ] `UpdateAgentRequestSchema` includes `persona`, `personaEnabled`, `color`, `icon` fields\n- [ ] `ResolveAgentsRequestSchema`, `ResolveAgentsResponseSchema`, `CreateAgentRequestSchema` are exported\n- [ ] All new types are exported\n- [ ] Existing schema tests still pass\n- [ ] New schema unit tests written and passing\n- [ ] `pnpm typecheck` passes across the monorepo",
      "activeForm": "Extending agent manifest schema with persona and visual identity fields",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.2"]
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[agents-first-class-entity] [P1] Extract manifest I/O to @dorkos/shared package",
      "description": "Move `readManifest()`, `writeManifest()`, `removeManifest()` and constants from `packages/mesh/src/manifest.ts` to `packages/shared/src/manifest.ts`. This decouples manifest file I/O from the Mesh subsystem so the server can read/write agent manifests without depending on `@dorkos/mesh`.\n\n**Current location:** `packages/mesh/src/manifest.ts` (71 lines)\n**New location:** `packages/shared/src/manifest.ts`\n\n**Implementation Steps:**\n\n1. Create `packages/shared/src/manifest.ts` with the exact same implementation currently in `packages/mesh/src/manifest.ts`:\n\n```typescript\n/**\n * Manifest reader/writer for agent `.dork/agent.json` files.\n *\n * Provides atomic file writing (temp file + rename) and Zod-validated\n * reading of agent manifests stored in project directories.\n *\n * @module shared/manifest\n */\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { randomUUID } from 'crypto';\nimport { AgentManifestSchema } from './mesh-schemas.js';\nimport type { AgentManifest } from './mesh-schemas.js';\n\nexport const MANIFEST_DIR = '.dork';\nexport const MANIFEST_FILE = 'agent.json';\n\n/**\n * Read and validate an agent manifest from a project directory.\n *\n * @param projectDir - Project directory containing `.dork/agent.json`\n * @returns Parsed manifest, or `null` if the file doesn't exist or fails validation\n */\nexport async function readManifest(projectDir: string): Promise<AgentManifest | null> {\n  const manifestPath = path.join(projectDir, MANIFEST_DIR, MANIFEST_FILE);\n  try {\n    const content = await fs.readFile(manifestPath, 'utf-8');\n    const parsed = JSON.parse(content) as unknown;\n    const result = AgentManifestSchema.safeParse(parsed);\n    return result.success ? result.data : null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Write an agent manifest to a project directory atomically.\n *\n * Creates the `.dork/` directory if it doesn't exist. Writes to a temp\n * file first, then atomically renames to `agent.json` to prevent partial\n * writes from corrupting the manifest.\n *\n * @param projectDir - Project directory to write `.dork/agent.json` into\n * @param manifest - The agent manifest to write\n */\nexport async function writeManifest(projectDir: string, manifest: AgentManifest): Promise<void> {\n  const dorkDir = path.join(projectDir, MANIFEST_DIR);\n  await fs.mkdir(dorkDir, { recursive: true });\n\n  const manifestPath = path.join(dorkDir, MANIFEST_FILE);\n  const tempPath = path.join(dorkDir, `.agent-${randomUUID()}.tmp`);\n\n  const content = JSON.stringify(manifest, null, 2) + '\\n';\n  await fs.writeFile(tempPath, content, 'utf-8');\n  await fs.rename(tempPath, manifestPath);\n}\n\n/**\n * Remove the agent manifest file from a project directory.\n *\n * @param projectPath - Absolute path to the agent's project directory\n */\nexport async function removeManifest(projectPath: string): Promise<void> {\n  try {\n    await fs.unlink(path.join(projectPath, MANIFEST_DIR, MANIFEST_FILE));\n  } catch {\n    // Best-effort cleanup — ignore if file already gone\n  }\n}\n```\n\n2. Add the new export to `packages/shared/package.json`:\n\n```json\n{\n  \"exports\": {\n    \"./manifest\": {\n      \"types\": \"./src/manifest.ts\",\n      \"default\": \"./dist/manifest.js\"\n    }\n  }\n}\n```\n\n3. Update `packages/mesh/src/manifest.ts` to re-export from shared:\n\n```typescript\n/**\n * Re-export manifest I/O from @dorkos/shared.\n *\n * This preserves all existing Mesh imports while the canonical\n * implementation now lives in the shared package.\n *\n * @module mesh/manifest\n */\nexport { readManifest, writeManifest, removeManifest, MANIFEST_DIR, MANIFEST_FILE } from '@dorkos/shared/manifest';\n```\n\n4. Add `@dorkos/shared` as a workspace dependency of `packages/mesh` if not already present (check `packages/mesh/package.json`).\n\n**Unit Tests** (`packages/shared/src/__tests__/manifest.test.ts`):\n- Test `readManifest` returns null for missing file (mock `fs.readFile` to throw ENOENT)\n- Test `readManifest` returns null for invalid JSON\n- Test `readManifest` returns null for JSON that fails Zod validation\n- Test `readManifest` returns parsed manifest for valid file\n- Test `writeManifest` creates `.dork` directory if needed (mock `fs.mkdir`)\n- Test `writeManifest` uses atomic temp-file + rename pattern\n- Test `removeManifest` is best-effort (doesn't throw on missing file)\n- Test round-trip: writeManifest then readManifest returns same data (including new fields: persona, color, icon)\n\n**Acceptance Criteria:**\n- [ ] `packages/shared/src/manifest.ts` contains `readManifest`, `writeManifest`, `removeManifest`, `MANIFEST_DIR`, `MANIFEST_FILE`\n- [ ] `packages/shared/package.json` exports `./manifest`\n- [ ] `packages/mesh/src/manifest.ts` re-exports from `@dorkos/shared/manifest`\n- [ ] All existing Mesh tests that import from `packages/mesh/src/manifest.ts` still pass\n- [ ] New unit tests in `packages/shared` written and passing\n- [ ] `pnpm typecheck` passes across the monorepo\n- [ ] `pnpm build` passes (shared package builds the new module)",
      "activeForm": "Extracting manifest I/O to shared package",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1"]
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[agents-first-class-entity] [P1] Create /api/agents routes for agent identity CRUD",
      "description": "Create a new route file `apps/server/src/routes/agents.ts` that provides agent identity CRUD endpoints. This route operates independently of Mesh — it is always mounted, not behind any feature flag. It reads/writes `.dork/agent.json` files directly via the shared manifest module.\n\n**Files to create:**\n- `apps/server/src/routes/agents.ts`\n\n**Files to modify:**\n- `apps/server/src/app.ts` (mount the new router)\n\n**Implementation:**\n\n```typescript\n/**\n * Agent identity routes — always available, independent of Mesh.\n *\n * Provides CRUD for `.dork/agent.json` files via the shared manifest module.\n * All path parameters are boundary-validated.\n *\n * @module routes/agents\n */\nimport { Router } from 'express';\nimport { readManifest, writeManifest } from '@dorkos/shared/manifest';\nimport { ulid } from 'ulid';\nimport path from 'path';\nimport {\n  ResolveAgentsRequestSchema,\n  CreateAgentRequestSchema,\n  UpdateAgentRequestSchema,\n} from '@dorkos/shared/mesh-schemas';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\nimport { validateBoundary } from '../lib/boundary.js';\nimport { logger } from '../lib/logger.js';\n\nexport function createAgentsRouter(): Router {\n  const router = Router();\n\n  // GET /api/agents/current?path=/path/to/project\n  // Returns the agent manifest for the given directory, or 404\n  router.get('/current', async (req, res) => {\n    try {\n      const agentPath = req.query.path as string;\n      if (!agentPath) {\n        return res.status(400).json({ error: 'path query parameter required' });\n      }\n      validateBoundary(agentPath, res);\n      const manifest = await readManifest(agentPath);\n      if (!manifest) {\n        return res.status(404).json({ error: 'No agent registered at this path' });\n      }\n      return res.json(manifest);\n    } catch (err) {\n      logger.error('[agents] GET /current failed', { err });\n      return res.status(500).json({ error: 'Internal server error' });\n    }\n  });\n\n  // POST /api/agents/resolve\n  // Batch resolve agents for multiple paths (avoids N+1 in DirectoryPicker)\n  router.post('/resolve', async (req, res) => {\n    try {\n      const result = ResolveAgentsRequestSchema.safeParse(req.body);\n      if (!result.success) {\n        return res.status(400).json({ error: 'Validation failed', details: result.error.flatten() });\n      }\n      const agents: Record<string, AgentManifest | null> = {};\n      await Promise.all(\n        result.data.paths.map(async (p) => {\n          try {\n            validateBoundary(p, res);\n            agents[p] = await readManifest(p);\n          } catch {\n            agents[p] = null;\n          }\n        })\n      );\n      return res.json({ agents });\n    } catch (err) {\n      logger.error('[agents] POST /resolve failed', { err });\n      return res.status(500).json({ error: 'Internal server error' });\n    }\n  });\n\n  // POST /api/agents\n  // Create a new agent (writes .dork/agent.json)\n  router.post('/', async (req, res) => {\n    try {\n      const result = CreateAgentRequestSchema.safeParse(req.body);\n      if (!result.success) {\n        return res.status(400).json({ error: 'Validation failed', details: result.error.flatten() });\n      }\n      const { path: agentPath, name, description, runtime } = result.data;\n      validateBoundary(agentPath, res);\n\n      // Check if agent already exists\n      const existing = await readManifest(agentPath);\n      if (existing) {\n        return res.status(409).json({ error: 'Agent already exists at this path', agent: existing });\n      }\n\n      const manifest: AgentManifest = {\n        id: ulid(),\n        name: name ?? path.basename(agentPath),\n        description: description ?? '',\n        runtime: runtime ?? 'claude-code',\n        capabilities: [],\n        behavior: { responseMode: 'always' },\n        budget: { maxHopsPerMessage: 5, maxCallsPerHour: 100 },\n        registeredAt: new Date().toISOString(),\n        registeredBy: 'dorkos-ui',\n        personaEnabled: true,\n      };\n\n      await writeManifest(agentPath, manifest);\n      return res.status(201).json(manifest);\n    } catch (err) {\n      logger.error('[agents] POST / failed', { err });\n      return res.status(500).json({ error: 'Internal server error' });\n    }\n  });\n\n  // PATCH /api/agents/current?path=/path/to/project\n  // Update agent fields by path\n  router.patch('/current', async (req, res) => {\n    try {\n      const agentPath = req.query.path as string;\n      if (!agentPath) {\n        return res.status(400).json({ error: 'path query parameter required' });\n      }\n      validateBoundary(agentPath, res);\n\n      const result = UpdateAgentRequestSchema.safeParse(req.body);\n      if (!result.success) {\n        return res.status(400).json({ error: 'Validation failed', details: result.error.flatten() });\n      }\n\n      const existing = await readManifest(agentPath);\n      if (!existing) {\n        return res.status(404).json({ error: 'No agent registered at this path' });\n      }\n\n      const updated: AgentManifest = { ...existing, ...result.data };\n      await writeManifest(agentPath, updated);\n      return res.json(updated);\n    } catch (err) {\n      logger.error('[agents] PATCH /current failed', { err });\n      return res.status(500).json({ error: 'Internal server error' });\n    }\n  });\n\n  return router;\n}\n```\n\n**Mount in `apps/server/src/app.ts`:**\n\nFind where other routers are mounted (look for `app.use('/api/...')` calls) and add:\n\n```typescript\nimport { createAgentsRouter } from './routes/agents.js';\n\n// Always mounted — not behind any feature flag\napp.use('/api/agents', createAgentsRouter());\n```\n\n**Note on `ulid` dependency:** Check if `ulid` is already available in the server package. If not, install it: `pnpm --filter=@dorkos/server add ulid`. Alternatively, use the pattern already used in the codebase for generating IDs.\n\n**Unit Tests** (`apps/server/src/routes/__tests__/agents.test.ts`):\n\nMock `readManifest` and `writeManifest` from `@dorkos/shared/manifest` and `validateBoundary` from `../lib/boundary.js`.\n\n- Test GET /current returns 400 when path query missing\n- Test GET /current returns 404 when no manifest found\n- Test GET /current returns 200 with manifest when found\n- Test POST /resolve returns agents map for mixed registered/unregistered paths\n- Test POST /resolve validates request body (returns 400 for invalid)\n- Test POST / creates agent with defaults (name from basename, ULID id)\n- Test POST / returns 409 when agent already exists\n- Test PATCH /current returns 404 for unregistered path\n- Test PATCH /current merges updates into existing manifest\n- Test all endpoints validate boundary (mock validateBoundary to throw for out-of-bounds)\n\n**Acceptance Criteria:**\n- [ ] `GET /api/agents/current?path=...` returns agent manifest or 404\n- [ ] `POST /api/agents/resolve` batch-resolves agents for up to 20 paths\n- [ ] `POST /api/agents` creates a new agent with ULID id and writes `.dork/agent.json`\n- [ ] `PATCH /api/agents/current?path=...` updates existing agent fields\n- [ ] All endpoints enforce directory boundary validation\n- [ ] Route is always mounted (no feature flag)\n- [ ] Unit tests written and passing\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Creating agent identity API routes",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1", "1.2"],
      "parallelWith": ["1.4"]
    },
    {
      "id": "1.4",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[agents-first-class-entity] [P1] Add agent identity methods to Transport interface and adapters",
      "description": "Extend the `Transport` interface with four new methods for agent identity, then implement them in both `HttpTransport` and `DirectTransport` adapters.\n\n**Files to modify:**\n- `packages/shared/src/transport.ts` (interface definition)\n- `apps/client/src/layers/shared/lib/http-transport.ts` (HTTP adapter)\n- `apps/obsidian-plugin/src/direct-transport.ts` (Direct adapter, if it exists)\n\n**1. Transport interface extension** (`packages/shared/src/transport.ts`):\n\nAdd a new section after the Mesh Topology methods:\n\n```typescript\nexport interface Transport {\n  // ... existing methods ...\n\n  // --- Agent Identity (always available, no feature flag) ---\n\n  /** Get the agent manifest for a working directory. Returns null if no agent registered. */\n  getAgentByPath(path: string): Promise<AgentManifest | null>;\n  /** Batch resolve agents for multiple paths. Returns a map of path -> manifest|null. */\n  resolveAgents(paths: string[]): Promise<Record<string, AgentManifest | null>>;\n  /** Create a new agent at the given path. Returns the created manifest. */\n  createAgent(path: string, name?: string, description?: string, runtime?: string): Promise<AgentManifest>;\n  /** Update an agent's fields by path. Returns the updated manifest. */\n  updateAgentByPath(path: string, updates: Partial<AgentManifest>): Promise<AgentManifest>;\n}\n```\n\nMake sure to import `AgentManifest` if not already imported (it's already imported from `./mesh-schemas.js`).\n\n**2. HttpTransport implementation:**\n\nFind the HttpTransport class (likely in `apps/client/src/layers/shared/lib/http-transport.ts` or similar). Add the four methods:\n\n```typescript\nasync getAgentByPath(path: string): Promise<AgentManifest | null> {\n  const res = await fetch(`${this.baseUrl}/api/agents/current?path=${encodeURIComponent(path)}`);\n  if (res.status === 404) return null;\n  if (!res.ok) throw new Error(`Failed to get agent: ${res.statusText}`);\n  return res.json();\n}\n\nasync resolveAgents(paths: string[]): Promise<Record<string, AgentManifest | null>> {\n  const res = await fetch(`${this.baseUrl}/api/agents/resolve`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ paths }),\n  });\n  if (!res.ok) throw new Error(`Failed to resolve agents: ${res.statusText}`);\n  const data = await res.json();\n  return data.agents;\n}\n\nasync createAgent(\n  path: string,\n  name?: string,\n  description?: string,\n  runtime?: string\n): Promise<AgentManifest> {\n  const res = await fetch(`${this.baseUrl}/api/agents`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ path, name, description, runtime }),\n  });\n  if (!res.ok) throw new Error(`Failed to create agent: ${res.statusText}`);\n  return res.json();\n}\n\nasync updateAgentByPath(\n  path: string,\n  updates: Partial<AgentManifest>\n): Promise<AgentManifest> {\n  const res = await fetch(`${this.baseUrl}/api/agents/current?path=${encodeURIComponent(path)}`, {\n    method: 'PATCH',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(updates),\n  });\n  if (!res.ok) throw new Error(`Failed to update agent: ${res.statusText}`);\n  return res.json();\n}\n```\n\n**3. DirectTransport implementation:**\n\nThe DirectTransport (used in Obsidian plugin) calls manifest I/O directly:\n\n```typescript\nimport { readManifest, writeManifest } from '@dorkos/shared/manifest';\nimport { ulid } from 'ulid';\nimport nodePath from 'path';\n\nasync getAgentByPath(path: string): Promise<AgentManifest | null> {\n  return readManifest(path);\n}\n\nasync resolveAgents(paths: string[]): Promise<Record<string, AgentManifest | null>> {\n  const result: Record<string, AgentManifest | null> = {};\n  await Promise.all(paths.map(async (p) => {\n    result[p] = await readManifest(p);\n  }));\n  return result;\n}\n\nasync createAgent(\n  agentPath: string,\n  name?: string,\n  description?: string,\n  runtime?: string\n): Promise<AgentManifest> {\n  const manifest: AgentManifest = {\n    id: ulid(),\n    name: name ?? nodePath.basename(agentPath),\n    description: description ?? '',\n    runtime: runtime ?? 'claude-code',\n    capabilities: [],\n    behavior: { responseMode: 'always' },\n    budget: { maxHopsPerMessage: 5, maxCallsPerHour: 100 },\n    registeredAt: new Date().toISOString(),\n    registeredBy: 'dorkos-obsidian',\n    personaEnabled: true,\n  };\n  await writeManifest(agentPath, manifest);\n  return manifest;\n}\n\nasync updateAgentByPath(\n  agentPath: string,\n  updates: Partial<AgentManifest>\n): Promise<AgentManifest> {\n  const existing = await readManifest(agentPath);\n  if (!existing) throw new Error('No agent registered at this path');\n  const updated = { ...existing, ...updates };\n  await writeManifest(agentPath, updated);\n  return updated;\n}\n```\n\n**4. Update mock transport** in `packages/test-utils/`:\n\nAdd the four new methods to `createMockTransport()` factory:\n\n```typescript\ngetAgentByPath: vi.fn().mockResolvedValue(null),\nresolveAgents: vi.fn().mockResolvedValue({}),\ncreateAgent: vi.fn().mockResolvedValue(mockAgent),\nupdateAgentByPath: vi.fn().mockResolvedValue(mockAgent),\n```\n\n**Acceptance Criteria:**\n- [ ] `Transport` interface includes `getAgentByPath`, `resolveAgents`, `createAgent`, `updateAgentByPath`\n- [ ] `HttpTransport` implements all four methods with correct HTTP calls\n- [ ] `DirectTransport` implements all four methods with direct manifest I/O\n- [ ] Mock transport in test-utils includes the new methods\n- [ ] `pnpm typecheck` passes across the monorepo\n- [ ] Existing transport tests still pass",
      "activeForm": "Adding agent identity methods to Transport interface",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1", "1.2"],
      "parallelWith": ["1.3"]
    },
    {
      "id": "1.5",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[agents-first-class-entity] [P1] Add persona injection to context-builder",
      "description": "Add a `buildAgentBlock()` function to the context builder that injects `<agent_identity>` and `<agent_persona>` XML blocks into Claude's system prompt when a `.dork/agent.json` exists in the working directory.\n\n**File to modify:** `apps/server/src/services/core/context-builder.ts`\n\n**Implementation:**\n\n1. Add import for `readManifest`:\n\n```typescript\nimport { readManifest } from '@dorkos/shared/manifest';\n```\n\n2. Update `buildSystemPromptAppend` to include agent block:\n\n```typescript\nexport async function buildSystemPromptAppend(cwd: string): Promise<string> {\n  const [envResult, gitResult, agentResult] = await Promise.allSettled([\n    buildEnvBlock(cwd),\n    buildGitBlock(cwd),\n    buildAgentBlock(cwd),\n  ]);\n\n  return [\n    envResult.status === 'fulfilled' ? envResult.value : '',\n    gitResult.status === 'fulfilled' ? gitResult.value : '',\n    agentResult.status === 'fulfilled' ? agentResult.value : '',\n  ]\n    .filter(Boolean)\n    .join('\\n\\n');\n}\n```\n\n3. Add the `buildAgentBlock` function:\n\n```typescript\n/**\n * Build agent identity and persona blocks from `.dork/agent.json`.\n *\n * When a manifest exists, always includes `<agent_identity>` (informational).\n * Includes `<agent_persona>` only when `personaEnabled` is true and `persona`\n * text is non-empty.\n *\n * @param cwd - Working directory to check for agent manifest\n * @returns XML block string, or empty string if no manifest\n */\nasync function buildAgentBlock(cwd: string): Promise<string> {\n  const manifest = await readManifest(cwd);\n  if (!manifest) return '';\n\n  const identityLines = [\n    `Name: ${manifest.name}`,\n    `ID: ${manifest.id}`,\n    manifest.description && `Description: ${manifest.description}`,\n    manifest.capabilities.length > 0 && `Capabilities: ${manifest.capabilities.join(', ')}`,\n  ].filter(Boolean);\n\n  const blocks = [`<agent_identity>\\n${identityLines.join('\\n')}\\n</agent_identity>`];\n\n  if (manifest.personaEnabled !== false && manifest.persona) {\n    blocks.push(`<agent_persona>\\n${manifest.persona}\\n</agent_persona>`);\n  }\n\n  return blocks.join('\\n\\n');\n}\n```\n\n**Key behaviors:**\n- `<agent_identity>` is ALWAYS included when a manifest exists (name, id, description, capabilities)\n- `<agent_persona>` is ONLY included when `personaEnabled` is true (default) AND `persona` is non-empty\n- Uses `readManifest` from `@dorkos/shared/manifest` — no Mesh dependency\n- Never throws (consistent with existing context-builder pattern — uses Promise.allSettled)\n- The description line is omitted if description is empty string\n- The capabilities line is omitted if capabilities array is empty\n\n**Unit Tests** (`apps/server/src/services/core/__tests__/context-builder.test.ts`):\n\nMock `readManifest` from `@dorkos/shared/manifest`:\n\n```typescript\nvi.mock('@dorkos/shared/manifest', () => ({\n  readManifest: vi.fn(),\n}));\n```\n\nTest cases:\n- Test `buildAgentBlock` returns empty string when `readManifest` returns null\n- Test `buildAgentBlock` includes `<agent_identity>` with name and id when manifest exists\n- Test `buildAgentBlock` includes description in identity block when non-empty\n- Test `buildAgentBlock` includes capabilities in identity block when non-empty array\n- Test `buildAgentBlock` omits description line when description is empty string\n- Test `buildAgentBlock` omits capabilities line when capabilities is empty array\n- Test `buildAgentBlock` includes `<agent_persona>` when personaEnabled is true and persona is non-empty\n- Test `buildAgentBlock` excludes `<agent_persona>` when personaEnabled is false\n- Test `buildAgentBlock` excludes `<agent_persona>` when persona is undefined/empty\n- Test `buildAgentBlock` excludes `<agent_persona>` when personaEnabled is undefined (defaults to true) but persona is empty\n- Test `buildSystemPromptAppend` includes agent block alongside env and git blocks\n- Test `buildSystemPromptAppend` gracefully handles agent block failure (Promise.allSettled)\n\nNote: Export `buildAgentBlock` with `@internal` tag for testing:\n\n```typescript\n/** @internal Exported for testing only. */\nexport { buildAgentBlock as _buildAgentBlock };\n```\n\n**Acceptance Criteria:**\n- [ ] `buildAgentBlock` reads manifest from cwd and produces correct XML\n- [ ] Identity block always included when manifest exists\n- [ ] Persona block only included when enabled AND non-empty\n- [ ] `buildSystemPromptAppend` runs agent block in parallel with env/git blocks\n- [ ] Never throws (consistent with existing pattern)\n- [ ] Unit tests written and passing\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Adding persona injection to context builder",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.2"],
      "parallelWith": ["1.3", "1.4", "1.6"]
    },
    {
      "id": "1.6",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[agents-first-class-entity] [P1] Add agent_get_current MCP tool",
      "description": "Add a new MCP tool `agent_get_current` to the MCP tool server so Claude sessions can query their own agent identity. This tool is always available (not guarded by any feature flag like `requireMesh`).\n\n**File to modify:** `apps/server/src/services/core/mcp-tool-server.ts`\n\n**Implementation:**\n\nAdd the following tool registration in the `createDorkOsToolServer` function, in the section with other always-available tools (near `ping`, `get_server_info`, `get_session_count`):\n\n```typescript\nimport { readManifest } from '@dorkos/shared/manifest';\n\n// Inside createDorkOsToolServer():\ntool('agent_get_current', {\n  description: 'Get the agent identity for the current working directory. Returns the agent manifest from .dork/agent.json if one exists, or null if no agent is registered.',\n  parameters: z.object({}),\n  execute: async () => {\n    const manifest = await readManifest(deps.defaultCwd);\n    if (!manifest) {\n      return jsonContent({ agent: null, message: 'No agent registered for current directory' });\n    }\n    return jsonContent({ agent: manifest });\n  },\n});\n```\n\nWhere `jsonContent` is the existing helper pattern used in other tools (wraps JSON as MCP text content):\n\n```typescript\nfunction jsonContent(data: unknown) {\n  return {\n    content: [\n      {\n        type: 'text' as const,\n        text: JSON.stringify(data, null, 2),\n      },\n    ],\n  };\n}\n```\n\nCheck if `jsonContent` or a similar helper already exists in the file. If not, extract it as a local utility.\n\n**Key behaviors:**\n- Tool is ALWAYS available — not behind `requireMesh` or any other feature flag guard\n- Uses `deps.defaultCwd` (injected at server startup) as the working directory\n- Returns `{ agent: null, message: '...' }` when no manifest found\n- Returns `{ agent: <full manifest> }` when manifest exists\n- Tool has no parameters (reads CWD from deps)\n\n**Acceptance Criteria:**\n- [ ] `agent_get_current` tool is registered in MCP tool server\n- [ ] Tool is not guarded by `requireMesh` or any feature flag\n- [ ] Returns null with message when no agent manifest exists\n- [ ] Returns full agent manifest when one exists\n- [ ] `pnpm typecheck` passes\n- [ ] Existing MCP tool tests still pass",
      "activeForm": "Adding agent_get_current MCP tool",
      "size": "small",
      "priority": "medium",
      "dependencies": ["1.2"],
      "parallelWith": ["1.3", "1.4", "1.5"]
    },
    {
      "id": "1.7",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[agents-first-class-entity] [P1] Add database migration for new agent manifest fields",
      "description": "Create a new Drizzle migration to add `persona`, `persona_enabled`, `color`, and `icon` columns to the `agents` table in the consolidated database. Update the Drizzle schema definition and the `AgentRegistry` methods to handle the new fields.\n\n**Note:** This task is only needed if DorkOS uses a consolidated Drizzle DB for agents. Check if `packages/db/src/schema/` contains a mesh schema. If agents are stored ONLY in `.dork/agent.json` files (file-first architecture per ADR-0043), this migration may only be needed for the Mesh registry's cached copy. Implement accordingly.\n\n**Files to modify:**\n- `packages/db/src/schema/mesh.ts` (add columns to agents table)\n- `packages/db/src/migrations/` (new migration file)\n- `packages/mesh/src/agent-registry.ts` (handle new fields in upsert/update/get/list)\n\n**1. Schema update** (`packages/db/src/schema/mesh.ts`):\n\n```typescript\nexport const agents = sqliteTable('agents', {\n  // ... existing columns\n  persona: text('persona'),\n  personaEnabled: integer('persona_enabled', { mode: 'boolean' }).notNull().default(true),\n  color: text('color'),\n  icon: text('icon'),\n});\n```\n\n**2. Migration** (new file, e.g., `0004_add_agent_identity_fields.sql`):\n\n```sql\nALTER TABLE agents ADD COLUMN persona TEXT;\nALTER TABLE agents ADD COLUMN persona_enabled INTEGER NOT NULL DEFAULT 1;\nALTER TABLE agents ADD COLUMN color TEXT;\nALTER TABLE agents ADD COLUMN icon TEXT;\n```\n\nThe migration uses `ALTER TABLE ADD COLUMN` with defaults so existing rows are unaffected. SQLite requires one ALTER TABLE per column.\n\n**3. AgentRegistry updates** (`packages/mesh/src/agent-registry.ts`):\n\nUpdate the `upsert`, `update`, `get`, and `list` methods to include the new fields. The reconciler already reads from `.dork/agent.json` and upserts — it will naturally pick up the new fields once the schema and registry handle them.\n\nFor `upsert` — include `persona`, `personaEnabled`, `color`, `icon` from the manifest data.\nFor `update` — accept and merge the new fields.\nFor `get`/`list` — return the new fields in query results.\n\n**Acceptance Criteria:**\n- [ ] `agents` table schema includes `persona`, `persona_enabled`, `color`, `icon` columns\n- [ ] Migration file created and runs without error on existing databases\n- [ ] AgentRegistry `upsert` stores new fields from manifest\n- [ ] AgentRegistry `update` accepts and merges new fields\n- [ ] AgentRegistry `get`/`list` return new fields\n- [ ] Existing Mesh tests still pass\n- [ ] `pnpm typecheck` passes\n- [ ] `pnpm build` passes",
      "activeForm": "Adding database migration for agent identity fields",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["1.1"],
      "parallelWith": ["1.2", "1.3"]
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "Entity Layer & Sidebar",
      "subject": "[agents-first-class-entity] [P2] Create entities/agent FSD layer with query hooks",
      "description": "Create the new FSD entity layer `entities/agent/` in the client app with TanStack Query hooks for agent CRUD operations and visual identity.\n\n**Directory structure:**\n```\napps/client/src/layers/entities/agent/\n├── model/\n│   ├── use-current-agent.ts\n│   ├── use-create-agent.ts\n│   ├── use-update-agent.ts\n│   ├── use-resolved-agents.ts\n│   └── use-agent-visual.ts\n├── api/\n│   └── queries.ts\n└── index.ts\n```\n\n**1. `api/queries.ts`** — Query key factory:\n\n```typescript\n/**\n * TanStack Query key factory for agent identity queries.\n *\n * @module entities/agent/api\n */\nexport const agentKeys = {\n  all: ['agents'] as const,\n  byPath: (path: string) => ['agents', 'byPath', path] as const,\n  resolved: (paths: string[]) => ['agents', 'resolved', ...paths] as const,\n};\n```\n\n**2. `model/use-current-agent.ts`**:\n\n```typescript\nimport { useQuery } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\nimport { agentKeys } from '../api/queries';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\n/**\n * Fetch the agent manifest for a working directory.\n *\n * Returns `null` when no agent is registered at the given path.\n * Uses a 60-second stale time since agent config changes infrequently.\n *\n * @param cwd - Working directory path to look up\n */\nexport function useCurrentAgent(cwd: string | null) {\n  const transport = useTransport();\n  return useQuery<AgentManifest | null>({\n    queryKey: agentKeys.byPath(cwd ?? ''),\n    queryFn: () => transport.getAgentByPath(cwd!),\n    enabled: !!cwd,\n    staleTime: 60_000,\n    gcTime: 5 * 60_000,\n  });\n}\n```\n\n**3. `model/use-create-agent.ts`**:\n\n```typescript\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\nimport { agentKeys } from '../api/queries';\n\n/**\n * Mutation hook to create a new agent at a directory path.\n * Invalidates the byPath query on success.\n */\nexport function useCreateAgent() {\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (opts: { path: string; name?: string; description?: string; runtime?: string }) =>\n      transport.createAgent(opts.path, opts.name, opts.description, opts.runtime),\n    onSuccess: (_data, variables) => {\n      queryClient.invalidateQueries({ queryKey: agentKeys.byPath(variables.path) });\n      queryClient.invalidateQueries({ queryKey: agentKeys.all });\n    },\n  });\n}\n```\n\n**4. `model/use-update-agent.ts`**:\n\n```typescript\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\nimport { agentKeys } from '../api/queries';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\n/**\n * Mutation hook to update an agent's fields with optimistic updates.\n * Reverts to previous data on error.\n */\nexport function useUpdateAgent() {\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (opts: { path: string; updates: Partial<AgentManifest> }) =>\n      transport.updateAgentByPath(opts.path, opts.updates),\n    onMutate: async ({ path, updates }) => {\n      await queryClient.cancelQueries({ queryKey: agentKeys.byPath(path) });\n      const previous = queryClient.getQueryData<AgentManifest | null>(agentKeys.byPath(path));\n      if (previous) {\n        queryClient.setQueryData(agentKeys.byPath(path), { ...previous, ...updates });\n      }\n      return { previous };\n    },\n    onError: (_err, { path }, context) => {\n      if (context?.previous) {\n        queryClient.setQueryData(agentKeys.byPath(path), context.previous);\n      }\n    },\n    onSettled: (_data, _err, { path }) => {\n      queryClient.invalidateQueries({ queryKey: agentKeys.byPath(path) });\n    },\n  });\n}\n```\n\n**5. `model/use-resolved-agents.ts`**:\n\n```typescript\nimport { useQuery } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\nimport { agentKeys } from '../api/queries';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\n/**\n * Batch resolve agents for multiple paths.\n * Used by DirectoryPicker to show agent names in the recents list.\n *\n * @param paths - Array of directory paths to resolve\n */\nexport function useResolvedAgents(paths: string[]) {\n  const transport = useTransport();\n  return useQuery<Record<string, AgentManifest | null>>({\n    queryKey: agentKeys.resolved(paths),\n    queryFn: () => transport.resolveAgents(paths),\n    enabled: paths.length > 0,\n    staleTime: 60_000,\n  });\n}\n```\n\n**6. `model/use-agent-visual.ts`**:\n\n```typescript\nimport { useMemo } from 'react';\nimport { hashToHslColor, hashToEmoji } from '@/layers/shared/lib/favicon-utils';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\nexport interface AgentVisual {\n  /** CSS color string (HSL or user override) */\n  color: string;\n  /** Single emoji character */\n  emoji: string;\n}\n\n/**\n * Single source of truth for agent visual identity.\n *\n * Priority:\n * 1. Agent has color/icon override -> use override\n * 2. Agent exists (no override) -> hash from agent.id (stable across CWD renames)\n * 3. No agent -> hash from CWD (current behavior, unchanged)\n *\n * @param agent - Agent manifest, or null/undefined if unregistered directory\n * @param cwd - Current working directory (fallback hash source)\n */\nexport function useAgentVisual(agent: AgentManifest | null | undefined, cwd: string): AgentVisual {\n  return useMemo(() => {\n    if (agent) {\n      const hashSource = agent.id;\n      return {\n        color: agent.color ?? hashToHslColor(hashSource),\n        emoji: agent.icon ?? hashToEmoji(hashSource),\n      };\n    }\n    return {\n      color: hashToHslColor(cwd),\n      emoji: hashToEmoji(cwd),\n    };\n  }, [agent, cwd]);\n}\n```\n\n**7. `index.ts`** — Barrel exports:\n\n```typescript\n/**\n * Agent entity — domain hooks for agent identity, visual identity, and CRUD.\n * Works independently of Mesh — reads .dork/agent.json directly.\n *\n * @module entities/agent\n */\nexport { useCurrentAgent } from './model/use-current-agent';\nexport { useCreateAgent } from './model/use-create-agent';\nexport { useUpdateAgent } from './model/use-update-agent';\nexport { useResolvedAgents } from './model/use-resolved-agents';\nexport { useAgentVisual } from './model/use-agent-visual';\nexport type { AgentVisual } from './model/use-agent-visual';\n```\n\n**Acceptance Criteria:**\n- [ ] `entities/agent/` directory created with all files\n- [ ] `useCurrentAgent` fetches agent by path with 60s stale time\n- [ ] `useCreateAgent` creates agent and invalidates queries\n- [ ] `useUpdateAgent` performs optimistic updates with rollback on error\n- [ ] `useResolvedAgents` batch-resolves agents for multiple paths\n- [ ] `useAgentVisual` implements the 3-tier priority (override > hash from id > hash from cwd)\n- [ ] All hooks follow existing TanStack Query patterns in the codebase\n- [ ] Barrel exports all public hooks and types\n- [ ] `pnpm typecheck` passes\n- [ ] FSD layer rules respected (entities only imports from shared)",
      "activeForm": "Creating agent entity FSD layer with query hooks",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.3", "1.4"],
      "parallelWith": []
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "Entity Layer & Sidebar",
      "subject": "[agents-first-class-entity] [P2] Create AgentHeader component for sidebar",
      "description": "Create the `AgentHeader` component that replaces the current directory breadcrumb area in `SessionSidebar`. When an agent is registered for the CWD, it shows the agent's colored dot, emoji, name, and description. When no agent exists, it shows the current folder icon + path breadcrumb plus a subtle '+ Agent' CTA.\n\n**Files to create:**\n- `apps/client/src/layers/features/session-list/ui/AgentHeader.tsx`\n\n**Files to modify:**\n- `apps/client/src/layers/features/session-list/ui/SessionSidebar.tsx` (replace breadcrumb area with AgentHeader)\n- `apps/client/src/layers/features/session-list/index.ts` (export AgentHeader if needed)\n\n**Implementation of AgentHeader.tsx:**\n\n```typescript\nimport { useCurrentAgent, useCreateAgent, useAgentVisual } from '@/layers/entities/agent';\nimport { Button } from '@/layers/shared/ui';\nimport { Skeleton } from '@/layers/shared/ui';\nimport { Settings, FolderOpen } from 'lucide-react';\n\ninterface AgentHeaderProps {\n  /** Current working directory */\n  cwd: string;\n  /** Callback to open the directory picker */\n  onOpenPicker: () => void;\n  /** Callback to open the Agent Settings Dialog */\n  onOpenAgentDialog: () => void;\n}\n\n/**\n * Sidebar header showing agent identity or directory path.\n *\n * When an agent is registered: colored dot + emoji + name + description + gear icon.\n * When no agent: folder icon + path breadcrumb + '+ Agent' CTA.\n */\nexport function AgentHeader({ cwd, onOpenPicker, onOpenAgentDialog }: AgentHeaderProps) {\n  const { data: agent, isLoading } = useCurrentAgent(cwd);\n  const createAgent = useCreateAgent();\n  const visual = useAgentVisual(agent ?? null, cwd);\n\n  const handleQuickCreate = async () => {\n    try {\n      await createAgent.mutateAsync({ path: cwd });\n      onOpenAgentDialog();\n    } catch {\n      // Toast error handled by mutation\n    }\n  };\n\n  if (isLoading) {\n    return <Skeleton className=\"h-10 w-full\" />;\n  }\n\n  if (agent) {\n    return (\n      <div className=\"flex flex-col gap-0.5\">\n        <div className=\"flex min-w-0 items-start gap-2 px-2 py-1.5\">\n          {/* Colored dot */}\n          <span\n            className=\"mt-1 size-2.5 flex-shrink-0 rounded-full\"\n            style={{ backgroundColor: visual.color }}\n          />\n          {/* Agent info — clickable to open dialog */}\n          <button\n            onClick={onOpenAgentDialog}\n            className=\"hover:bg-accent min-w-0 flex-1 rounded-md px-1 py-0.5 text-left\"\n          >\n            <div className=\"flex items-center gap-1\">\n              <span className=\"text-sm\">{visual.emoji}</span>\n              <span className=\"truncate text-sm font-semibold\">{agent.name}</span>\n            </div>\n            {agent.description && (\n              <p className=\"text-muted-foreground truncate text-xs\">{agent.description}</p>\n            )}\n          </button>\n          {/* Settings gear */}\n          <Button\n            variant=\"ghost\"\n            size=\"icon-sm\"\n            onClick={onOpenAgentDialog}\n            aria-label=\"Agent settings\"\n          >\n            <Settings className=\"size-(--size-icon-sm)\" />\n          </Button>\n        </div>\n        {/* Secondary path line */}\n        <button\n          onClick={onOpenPicker}\n          className=\"text-muted-foreground hover:text-foreground truncate px-2 text-xs\"\n          title={cwd}\n        >\n          {/* Use PathBreadcrumb or shortenHomePath — match existing pattern */}\n          {cwd}\n        </button>\n      </div>\n    );\n  }\n\n  // Unregistered directory: current behavior + subtle CTA\n  return (\n    <div className=\"flex min-w-0 items-center gap-1 px-2 py-1.5\">\n      <button\n        onClick={onOpenPicker}\n        className=\"hover:bg-accent flex min-w-0 flex-1 items-center gap-1 rounded-md px-1 py-0.5\"\n        title={cwd}\n      >\n        <FolderOpen className=\"size-(--size-icon-sm) flex-shrink-0\" />\n        {/* Use PathBreadcrumb component — match existing pattern */}\n        <span className=\"truncate text-sm\">{cwd}</span>\n      </button>\n      <button\n        onClick={handleQuickCreate}\n        className=\"text-muted-foreground hover:text-foreground text-xs whitespace-nowrap\"\n      >\n        + Agent\n      </button>\n    </div>\n  );\n}\n```\n\n**Integration in SessionSidebar.tsx:**\n\nLocate the current directory breadcrumb area (look for `FolderOpen`, `PathBreadcrumb`, or directory display). Replace it with:\n\n```typescript\nimport { AgentHeader } from './AgentHeader';\n\n// Inside the sidebar render:\n<AgentHeader\n  cwd={currentCwd}\n  onOpenPicker={() => setDirectoryPickerOpen(true)}\n  onOpenAgentDialog={() => setAgentDialogOpen(true)}\n/>\n```\n\nAdd state for the agent dialog:\n```typescript\nconst [agentDialogOpen, setAgentDialogOpen] = useState(false);\n```\n\nThe AgentDialog component will be created in task 3.1 — for now, the callback can be a no-op or console.log placeholder. Wire it up properly when the dialog is available.\n\n**Quick create flow:**\n1. User clicks '+ Agent' button\n2. `createAgent.mutateAsync({ path: cwd })` is called with defaults (name = directory basename)\n3. On success, `onOpenAgentDialog()` is called to open the Agent Settings Dialog for customization\n4. On error, the mutation's error handling shows a toast\n\n**Component Tests** (`apps/client/src/layers/features/session-list/ui/__tests__/AgentHeader.test.tsx`):\n\nTest cases (use mock transport, provide TransportProvider + QueryClientProvider wrappers):\n- Test renders agent name, emoji, and colored dot when agent exists\n- Test renders description when agent has one\n- Test renders folder icon and path when no agent\n- Test renders '+ Agent' button for unregistered directories\n- Test clicking agent name area calls `onOpenAgentDialog`\n- Test clicking gear icon calls `onOpenAgentDialog`\n- Test clicking '+ Agent' calls createAgent mutation\n- Test loading state shows Skeleton\n- Test clicking path area calls `onOpenPicker`\n\n**Acceptance Criteria:**\n- [ ] `AgentHeader` component created with full implementation\n- [ ] Shows agent identity (dot, emoji, name, description) when agent registered\n- [ ] Shows folder + path + '+ Agent' when no agent\n- [ ] Quick create flow works (creates agent then opens dialog)\n- [ ] Integrated into `SessionSidebar` replacing the old breadcrumb area\n- [ ] Component tests written and passing\n- [ ] `pnpm typecheck` passes\n- [ ] FSD layer rules respected (features imports from entities and shared only)",
      "activeForm": "Creating AgentHeader component for sidebar",
      "size": "medium",
      "priority": "high",
      "dependencies": ["2.1"],
      "parallelWith": ["2.3"]
    },
    {
      "id": "2.3",
      "phase": 2,
      "phaseName": "Entity Layer & Sidebar",
      "subject": "[agents-first-class-entity] [P2] Integrate agent identity into favicon and tab title",
      "description": "Update the favicon and tab title system to reflect agent identity when available. Currently, `hashToHslColor(cwd)` and `hashToEmoji(cwd)` hash from the CWD string. With agents, the visual identity priority is handled by `useAgentVisual` — this task wires that hook into the existing favicon/title system.\n\n**Files to modify:**\n- The component that currently manages favicon and tab title (likely in `App.tsx` or a dedicated hook). Search for usage of `hashToHslColor`, `generateCircleFavicon`, `setFavicon`, and `updateTabBadge`.\n\n**Implementation:**\n\nFind where the favicon color and tab title are set (search for `hashToHslColor` usage in the client). Update to use `useAgentVisual`:\n\n```typescript\nimport { useCurrentAgent, useAgentVisual } from '@/layers/entities/agent';\n\n// Inside the component/hook that manages favicon:\nconst { data: agent } = useCurrentAgent(cwd);\nconst visual = useAgentVisual(agent ?? null, cwd);\n\n// Favicon: use visual.color instead of hashToHslColor(cwd)\nuseEffect(() => {\n  const faviconDataUrl = generateCircleFavicon(visual.color);\n  setFavicon(faviconDataUrl);\n}, [visual.color]);\n```\n\n**Tab title update:**\n\nCurrently `updateTabBadge()` sets title to `(N) DorkOS`. With an agent, change the format:\n\n```typescript\nfunction updateTabTitle(agent: AgentManifest | null | undefined, visual: AgentVisual, badgeCount: number) {\n  const base = agent\n    ? `${visual.emoji} ${agent.name} — DorkOS`\n    : 'DorkOS';\n  document.title = badgeCount > 0 ? `(${badgeCount}) ${base}` : base;\n}\n```\n\nModify `updateTabBadge` (or the component calling it) to accept agent info, or create a new `useTabTitle` hook that combines badge count with agent identity:\n\n```typescript\n// In the component managing the title:\nuseEffect(() => {\n  const base = agent\n    ? `${visual.emoji} ${agent.name} — DorkOS`\n    : 'DorkOS';\n  // If there's a badge count mechanism, integrate with it\n  document.title = base;\n}, [agent, visual.emoji]);\n```\n\n**Key behaviors:**\n- When agent exists with color override: favicon uses the override color\n- When agent exists without color override: favicon uses hash of agent.id (not CWD)\n- When no agent: favicon uses hash of CWD (unchanged from current behavior)\n- Tab title shows `[emoji] AgentName — DorkOS` when agent exists\n- Tab title shows `DorkOS` when no agent (unchanged)\n- Badge count prefix `(N)` is preserved in both cases\n\n**No changes to `favicon-utils.ts` functions** — they remain pure hash utilities. The agent-aware logic is in `useAgentVisual` which is consumed here.\n\n**Acceptance Criteria:**\n- [ ] Favicon reflects agent color (override or hash from agent.id) when agent exists\n- [ ] Favicon uses CWD hash when no agent (unchanged behavior)\n- [ ] Tab title shows agent emoji + name when agent exists\n- [ ] Tab title shows 'DorkOS' when no agent\n- [ ] Badge count prefix preserved in both cases\n- [ ] Switching directories updates favicon and title\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Integrating agent identity into favicon and tab title",
      "size": "small",
      "priority": "medium",
      "dependencies": ["2.1"],
      "parallelWith": ["2.2"]
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Agent Dialog",
      "subject": "[agents-first-class-entity] [P3] Create AgentDialog shell with Identity tab",
      "description": "Create the `features/agent-settings/` FSD feature with the main dialog shell and the first tab (Identity). The dialog uses `ResponsiveDialog` + `Tabs` following the same pattern as the existing `SettingsDialog`.\n\n**Directory structure:**\n```\napps/client/src/layers/features/agent-settings/\n├── ui/\n│   ├── AgentDialog.tsx\n│   └── IdentityTab.tsx\n├── model/\n│   └── use-agent-dialog.ts\n└── index.ts\n```\n\n**1. `model/use-agent-dialog.ts`** — Dialog state:\n\n```typescript\nimport { create } from 'zustand';\n\ninterface AgentDialogState {\n  open: boolean;\n  agentPath: string | null;\n  openDialog: (path: string) => void;\n  closeDialog: () => void;\n}\n\nexport const useAgentDialog = create<AgentDialogState>((set) => ({\n  open: false,\n  agentPath: null,\n  openDialog: (path: string) => set({ open: true, agentPath: path }),\n  closeDialog: () => set({ open: false, agentPath: null }),\n}));\n```\n\n**2. `ui/AgentDialog.tsx`** — Main dialog shell:\n\n```typescript\nimport { useState } from 'react';\nimport { useCurrentAgent, useUpdateAgent } from '@/layers/entities/agent';\nimport {\n  ResponsiveDialog,\n  ResponsiveDialogContent,\n  ResponsiveDialogHeader,\n  ResponsiveDialogTitle,\n  ResponsiveDialogDescription,\n  ResponsiveDialogBody,\n  ResponsiveDialogFullscreenToggle,\n} from '@/layers/shared/ui';\nimport { Tabs, TabsList, TabsTrigger, TabsContent } from '@/layers/shared/ui';\nimport { IdentityTab } from './IdentityTab';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\ninterface AgentDialogProps {\n  agentPath: string;\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n}\n\nexport function AgentDialog({ agentPath, open, onOpenChange }: AgentDialogProps) {\n  const { data: agent } = useCurrentAgent(agentPath);\n  const updateAgent = useUpdateAgent();\n  const [activeTab, setActiveTab] = useState('identity');\n\n  if (!agent) return null;\n\n  const handleUpdate = (updates: Partial<AgentManifest>) => {\n    updateAgent.mutate({ path: agentPath, updates });\n  };\n\n  return (\n    <ResponsiveDialog open={open} onOpenChange={onOpenChange}>\n      <ResponsiveDialogContent className=\"sm:max-w-[540px]\">\n        <ResponsiveDialogHeader>\n          <ResponsiveDialogTitle>{agent.name}</ResponsiveDialogTitle>\n          <ResponsiveDialogDescription>Agent configuration</ResponsiveDialogDescription>\n          <ResponsiveDialogFullscreenToggle />\n        </ResponsiveDialogHeader>\n\n        <ResponsiveDialogBody>\n          <Tabs value={activeTab} onValueChange={setActiveTab}>\n            <TabsList className=\"grid w-full grid-cols-4\">\n              <TabsTrigger value=\"identity\">Identity</TabsTrigger>\n              <TabsTrigger value=\"persona\">Persona</TabsTrigger>\n              <TabsTrigger value=\"capabilities\">Capabilities</TabsTrigger>\n              <TabsTrigger value=\"connections\">Connections</TabsTrigger>\n            </TabsList>\n\n            <TabsContent value=\"identity\">\n              <IdentityTab agent={agent} onUpdate={handleUpdate} />\n            </TabsContent>\n            <TabsContent value=\"persona\">\n              <div className=\"text-muted-foreground py-8 text-center text-sm\">Persona tab — coming soon</div>\n            </TabsContent>\n            <TabsContent value=\"capabilities\">\n              <div className=\"text-muted-foreground py-8 text-center text-sm\">Capabilities tab — coming soon</div>\n            </TabsContent>\n            <TabsContent value=\"connections\">\n              <div className=\"text-muted-foreground py-8 text-center text-sm\">Connections tab — coming soon</div>\n            </TabsContent>\n          </Tabs>\n        </ResponsiveDialogBody>\n      </ResponsiveDialogContent>\n    </ResponsiveDialog>\n  );\n}\n```\n\n**3. `ui/IdentityTab.tsx`** — Identity form:\n\n```typescript\nimport { useState, useCallback } from 'react';\nimport { Input } from '@/layers/shared/ui';\nimport { Textarea } from '@/layers/shared/ui';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/layers/shared/ui';\nimport { Button } from '@/layers/shared/ui';\nimport { useAgentVisual } from '@/layers/entities/agent';\nimport { EMOJI_SET } from '@/layers/shared/lib/favicon-utils';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\ninterface IdentityTabProps {\n  agent: AgentManifest;\n  onUpdate: (updates: Partial<AgentManifest>) => void;\n}\n\nexport function IdentityTab({ agent, onUpdate }: IdentityTabProps) {\n  const visual = useAgentVisual(agent, '');\n\n  // Color palette presets\n  const COLOR_PRESETS = [\n    '#ef4444', '#f97316', '#eab308', '#22c55e',\n    '#06b6d4', '#3b82f6', '#6366f1', '#a855f7',\n    '#ec4899', '#78716c',\n  ];\n\n  return (\n    <div className=\"space-y-4 pt-4\">\n      {/* Name */}\n      <div className=\"space-y-2\">\n        <label className=\"text-sm font-medium\">Name</label>\n        <Input\n          value={agent.name}\n          onChange={(e) => onUpdate({ name: e.target.value })}\n          placeholder=\"Agent name\"\n        />\n      </div>\n\n      {/* Description */}\n      <div className=\"space-y-2\">\n        <label className=\"text-sm font-medium\">Description</label>\n        <Textarea\n          value={agent.description ?? ''}\n          onChange={(e) => onUpdate({ description: e.target.value })}\n          placeholder=\"Brief description of what this agent does\"\n          rows={2}\n        />\n      </div>\n\n      {/* Color */}\n      <div className=\"space-y-2\">\n        <label className=\"text-sm font-medium\">Color</label>\n        <div className=\"flex flex-wrap items-center gap-2\">\n          {COLOR_PRESETS.map((c) => (\n            <button\n              key={c}\n              onClick={() => onUpdate({ color: c })}\n              className=\"size-6 rounded-full border-2 transition-transform hover:scale-110\"\n              style={{\n                backgroundColor: c,\n                borderColor: agent.color === c ? 'var(--foreground)' : 'transparent',\n              }}\n              aria-label={`Select color ${c}`}\n            />\n          ))}\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={() => onUpdate({ color: undefined })}\n            className=\"text-xs\"\n          >\n            Reset\n          </Button>\n        </div>\n      </div>\n\n      {/* Emoji */}\n      <div className=\"space-y-2\">\n        <label className=\"text-sm font-medium\">Emoji</label>\n        <div className=\"flex flex-wrap gap-1\">\n          {EMOJI_SET.map((emoji) => (\n            <button\n              key={emoji}\n              onClick={() => onUpdate({ icon: emoji })}\n              className=\"hover:bg-accent rounded-md p-1 text-lg transition-colors\"\n              style={{\n                outline: agent.icon === emoji ? '2px solid var(--foreground)' : 'none',\n              }}\n            >\n              {emoji}\n            </button>\n          ))}\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={() => onUpdate({ icon: undefined })}\n            className=\"text-xs\"\n          >\n            Reset\n          </Button>\n        </div>\n      </div>\n\n      {/* Runtime */}\n      <div className=\"space-y-2\">\n        <label className=\"text-sm font-medium\">Runtime</label>\n        <Select value={agent.runtime} onValueChange={(v) => onUpdate({ runtime: v as AgentManifest['runtime'] })}>\n          <SelectTrigger>\n            <SelectValue />\n          </SelectTrigger>\n          <SelectContent>\n            <SelectItem value=\"claude-code\">Claude Code</SelectItem>\n            <SelectItem value=\"cursor\">Cursor</SelectItem>\n            <SelectItem value=\"codex\">Codex</SelectItem>\n            <SelectItem value=\"other\">Other</SelectItem>\n          </SelectContent>\n        </Select>\n      </div>\n\n      {/* Working Directory (read-only) */}\n      <div className=\"space-y-2\">\n        <label className=\"text-sm font-medium\">Working Directory</label>\n        <div className=\"bg-muted text-muted-foreground flex items-center rounded-md px-3 py-2 text-sm\">\n          {/* Display CWD — read only, with copy button */}\n          <span className=\"flex-1 truncate\">{/* CWD passed from parent */}</span>\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n**Note:** The `EMOJI_SET` constant needs to be exported from `favicon-utils.ts`. If it's not currently exported, add the export.\n\n**4. `index.ts`** — Barrel exports:\n\n```typescript\n/**\n * Agent settings feature — dialog for configuring agent identity, persona, and capabilities.\n *\n * @module features/agent-settings\n */\nexport { AgentDialog } from './ui/AgentDialog';\nexport { useAgentDialog } from './model/use-agent-dialog';\n```\n\n**Component Tests** (`apps/client/src/layers/features/agent-settings/ui/__tests__/AgentDialog.test.tsx`):\n- Test dialog renders when open=true and agent exists\n- Test dialog doesn't render when agent is null\n- Test all 4 tab triggers are visible\n- Test switching tabs changes content\n- Test Identity tab fields are populated from agent data\n- Test name input triggers onUpdate with new name\n- Test color palette shows presets and selection triggers onUpdate\n- Test emoji grid shows EMOJI_SET and selection triggers onUpdate\n- Test Reset buttons clear color/icon overrides\n- Test runtime dropdown shows all 4 options\n\n**Acceptance Criteria:**\n- [ ] `features/agent-settings/` directory created with all files\n- [ ] AgentDialog renders with 4 tabs using ResponsiveDialog pattern\n- [ ] Identity tab has working Name, Description, Color, Emoji, Runtime, Working Directory fields\n- [ ] Color picker shows 10 presets + Reset button\n- [ ] Emoji picker shows 30-emoji grid from EMOJI_SET + Reset button\n- [ ] Field changes trigger optimistic PATCH via useUpdateAgent\n- [ ] Zustand store manages dialog open/close state\n- [ ] Component tests written and passing\n- [ ] `pnpm typecheck` passes\n- [ ] FSD layer rules respected",
      "activeForm": "Creating AgentDialog with Identity tab",
      "size": "large",
      "priority": "high",
      "dependencies": ["2.1", "2.2"],
      "parallelWith": []
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "Agent Dialog",
      "subject": "[agents-first-class-entity] [P3] Implement Persona tab with live preview",
      "description": "Add the Persona tab to the Agent Dialog. This tab provides a textarea for persona text, an enabled toggle, and a live preview of the XML blocks that will be injected into Claude's system prompt.\n\n**File to create:**\n- `apps/client/src/layers/features/agent-settings/ui/PersonaTab.tsx`\n\n**File to modify:**\n- `apps/client/src/layers/features/agent-settings/ui/AgentDialog.tsx` (replace placeholder with PersonaTab)\n\n**Implementation of PersonaTab.tsx:**\n\n```typescript\nimport { Switch } from '@/layers/shared/ui';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\ninterface PersonaTabProps {\n  agent: AgentManifest;\n  onUpdate: (updates: Partial<AgentManifest>) => void;\n}\n\n/**\n * Persona tab — textarea for system prompt persona text with live XML preview.\n */\nexport function PersonaTab({ agent, onUpdate }: PersonaTabProps) {\n  const personaEnabled = agent.personaEnabled !== false; // defaults to true\n\n  // Build the preview XML matching context-builder output\n  const buildPreview = (): string => {\n    const identityLines = [\n      `Name: ${agent.name}`,\n      `ID: ${agent.id}`,\n      agent.description && `Description: ${agent.description}`,\n      agent.capabilities.length > 0 && `Capabilities: ${agent.capabilities.join(', ')}`,\n    ].filter(Boolean);\n\n    const blocks = [`<agent_identity>\\n${identityLines.join('\\n')}\\n</agent_identity>`];\n\n    if (personaEnabled && agent.persona) {\n      blocks.push(`<agent_persona>\\n${agent.persona}\\n</agent_persona>`);\n    }\n\n    return blocks.join('\\n\\n');\n  };\n\n  return (\n    <div className=\"space-y-4 pt-4\">\n      {/* Guidance text */}\n      <p className=\"text-muted-foreground text-sm\">\n        This text is appended to Claude Code's system prompt for every session in this directory.\n        Use it to define the agent's expertise, constraints, and personality.\n      </p>\n\n      {/* Enabled toggle */}\n      <div className=\"flex items-center justify-between\">\n        <label className=\"text-sm font-medium\">Inject persona into sessions</label>\n        <Switch\n          checked={personaEnabled}\n          onCheckedChange={(checked) => onUpdate({ personaEnabled: checked })}\n        />\n      </div>\n\n      {/* Persona textarea */}\n      <div className=\"space-y-2\">\n        <label className=\"text-sm font-medium\">Persona</label>\n        <textarea\n          value={agent.persona ?? ''}\n          onChange={(e) => onUpdate({ persona: e.target.value })}\n          placeholder=\"You are backend-bot, an expert in REST API design...\"\n          rows={8}\n          maxLength={4000}\n          className=\"border-input bg-background placeholder:text-muted-foreground w-full rounded-md border px-3 py-2 font-mono text-sm focus:outline-none focus:ring-2\"\n          disabled={!personaEnabled}\n        />\n        <div className=\"text-muted-foreground text-right text-xs\">\n          {(agent.persona?.length ?? 0).toLocaleString()} / 4,000\n        </div>\n      </div>\n\n      {/* Live preview */}\n      <div className=\"space-y-2\">\n        <label className=\"text-sm font-medium\">Preview (injected into system prompt)</label>\n        <pre className=\"bg-muted max-h-48 overflow-auto rounded-md p-3 text-xs\">\n          <code>{buildPreview()}</code>\n        </pre>\n      </div>\n    </div>\n  );\n}\n```\n\n**Update AgentDialog.tsx:**\n\nReplace the Persona placeholder:\n\n```typescript\nimport { PersonaTab } from './PersonaTab';\n\n// In the Tabs content:\n<TabsContent value=\"persona\">\n  <PersonaTab agent={agent} onUpdate={handleUpdate} />\n</TabsContent>\n```\n\n**Key behaviors:**\n- Persona textarea is disabled when the toggle is off\n- Character count shows current length vs 4000 max\n- Preview shows the exact XML that `buildAgentBlock` in context-builder will produce\n- Preview updates live as the user types\n- Identity block is always shown in preview (informational)\n- Persona block in preview appears/disappears based on toggle and text content\n\n**Component Tests:**\n- Test toggle controls personaEnabled state\n- Test textarea is disabled when toggle is off\n- Test character count updates as user types\n- Test preview shows `<agent_identity>` block\n- Test preview shows `<agent_persona>` when enabled and text is non-empty\n- Test preview hides `<agent_persona>` when toggle is off\n- Test preview hides `<agent_persona>` when text is empty\n\n**Acceptance Criteria:**\n- [ ] PersonaTab renders with guidance text, toggle, textarea, character count, and preview\n- [ ] Toggle controls `personaEnabled` field\n- [ ] Textarea disabled when toggle is off\n- [ ] Live preview matches context-builder XML output\n- [ ] Character count shows persona length vs 4000 max\n- [ ] Integrated into AgentDialog\n- [ ] Component tests written and passing",
      "activeForm": "Implementing Persona tab with live preview",
      "size": "medium",
      "priority": "high",
      "dependencies": ["3.1"],
      "parallelWith": ["3.3"]
    },
    {
      "id": "3.3",
      "phase": 3,
      "phaseName": "Agent Dialog",
      "subject": "[agents-first-class-entity] [P3] Implement Capabilities and Connections tabs",
      "description": "Add the Capabilities tab and Connections tab to the Agent Dialog. The Capabilities tab surfaces Mesh-related configuration in agent-centric language. The Connections tab is a read-mostly view linking to Pulse, Relay, and Mesh subsystems.\n\n**Files to create:**\n- `apps/client/src/layers/features/agent-settings/ui/CapabilitiesTab.tsx`\n- `apps/client/src/layers/features/agent-settings/ui/ConnectionsTab.tsx`\n\n**File to modify:**\n- `apps/client/src/layers/features/agent-settings/ui/AgentDialog.tsx` (replace placeholders)\n\n**1. CapabilitiesTab.tsx:**\n\n```typescript\nimport { useState } from 'react';\nimport { Input } from '@/layers/shared/ui';\nimport { Badge } from '@/layers/shared/ui';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/layers/shared/ui';\nimport { X } from 'lucide-react';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\ninterface CapabilitiesTabProps {\n  agent: AgentManifest;\n  onUpdate: (updates: Partial<AgentManifest>) => void;\n}\n\nexport function CapabilitiesTab({ agent, onUpdate }: CapabilitiesTabProps) {\n  const [capInput, setCapInput] = useState('');\n\n  const addCapability = () => {\n    const trimmed = capInput.trim();\n    if (!trimmed || agent.capabilities.includes(trimmed)) return;\n    onUpdate({ capabilities: [...agent.capabilities, trimmed] });\n    setCapInput('');\n  };\n\n  const removeCapability = (cap: string) => {\n    onUpdate({ capabilities: agent.capabilities.filter((c) => c !== cap) });\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' || e.key === ',') {\n      e.preventDefault();\n      addCapability();\n    }\n  };\n\n  return (\n    <div className=\"space-y-4 pt-4\">\n      {/* Capabilities */}\n      <div className=\"space-y-2\">\n        <label className=\"text-sm font-medium\">Capabilities</label>\n        <p className=\"text-muted-foreground text-xs\">Tags describing what this agent can do. Press Enter or comma to add.</p>\n        <div className=\"flex gap-2\">\n          <Input\n            value={capInput}\n            onChange={(e) => setCapInput(e.target.value)}\n            onKeyDown={handleKeyDown}\n            placeholder=\"e.g., code-review, testing, deployment\"\n            className=\"flex-1\"\n          />\n        </div>\n        {agent.capabilities.length > 0 && (\n          <div className=\"flex flex-wrap gap-1 pt-1\">\n            {agent.capabilities.map((cap) => (\n              <Badge key={cap} variant=\"secondary\" className=\"gap-1\">\n                {cap}\n                <button onClick={() => removeCapability(cap)} className=\"hover:text-foreground\">\n                  <X className=\"size-3\" />\n                </button>\n              </Badge>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Namespace */}\n      <div className=\"space-y-2\">\n        <label className=\"text-sm font-medium\">Namespace</label>\n        <p className=\"text-muted-foreground text-xs\">Optional grouping for agent organization.</p>\n        <Input\n          value={agent.namespace ?? ''}\n          onChange={(e) => onUpdate({ namespace: e.target.value || undefined })}\n          placeholder=\"e.g., backend, frontend, devops\"\n        />\n      </div>\n\n      {/* Response Mode */}\n      <div className=\"space-y-2\">\n        <label className=\"text-sm font-medium\">Response Mode</label>\n        <Select\n          value={agent.behavior?.responseMode ?? 'always'}\n          onValueChange={(v) => onUpdate({ behavior: { ...agent.behavior, responseMode: v as 'always' | 'direct-only' | 'mention-only' | 'silent' } })}\n        >\n          <SelectTrigger>\n            <SelectValue />\n          </SelectTrigger>\n          <SelectContent>\n            <SelectItem value=\"always\">Always respond</SelectItem>\n            <SelectItem value=\"direct-only\">Direct messages only</SelectItem>\n            <SelectItem value=\"mention-only\">Mentions only</SelectItem>\n            <SelectItem value=\"silent\">Silent</SelectItem>\n          </SelectContent>\n        </Select>\n      </div>\n\n      {/* Budget: Max Hops */}\n      <div className=\"grid grid-cols-2 gap-4\">\n        <div className=\"space-y-2\">\n          <label className=\"text-sm font-medium\">Max Hops / Message</label>\n          <Input\n            type=\"number\"\n            min={1}\n            value={agent.budget?.maxHopsPerMessage ?? 5}\n            onChange={(e) => onUpdate({ budget: { ...agent.budget, maxHopsPerMessage: parseInt(e.target.value) || 5 } })}\n          />\n        </div>\n        <div className=\"space-y-2\">\n          <label className=\"text-sm font-medium\">Max Calls / Hour</label>\n          <Input\n            type=\"number\"\n            min={1}\n            value={agent.budget?.maxCallsPerHour ?? 100}\n            onChange={(e) => onUpdate({ budget: { ...agent.budget, maxCallsPerHour: parseInt(e.target.value) || 100 } })}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n**2. ConnectionsTab.tsx:**\n\n```typescript\nimport { usePulseEnabled, useSchedules } from '@/layers/entities/pulse';\nimport { useRelayEnabled, useRelayEndpoints } from '@/layers/entities/relay';\nimport { useMeshEnabled, useMeshAgentHealth } from '@/layers/entities/mesh';\nimport { Badge } from '@/layers/shared/ui';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\ninterface ConnectionsTabProps {\n  agent: AgentManifest;\n}\n\nexport function ConnectionsTab({ agent }: ConnectionsTabProps) {\n  const pulseEnabled = usePulseEnabled();\n  const relayEnabled = useRelayEnabled();\n  const meshEnabled = useMeshEnabled();\n\n  return (\n    <div className=\"space-y-6 pt-4\">\n      {/* Pulse Schedules */}\n      {pulseEnabled && <PulseSection agentId={agent.id} />}\n      {!pulseEnabled && (\n        <EmptySection\n          title=\"Pulse Schedules\"\n          description=\"Enable Pulse to schedule automated agent runs.\"\n        />\n      )}\n\n      {/* Relay Endpoints */}\n      {relayEnabled && <RelaySection agentId={agent.id} />}\n      {!relayEnabled && (\n        <EmptySection\n          title=\"Relay Endpoints\"\n          description=\"Enable Relay for inter-agent messaging.\"\n        />\n      )}\n\n      {/* Mesh Health */}\n      {meshEnabled && <MeshSection agentId={agent.id} />}\n      {!meshEnabled && (\n        <EmptySection\n          title=\"Mesh Health\"\n          description=\"Enable Mesh for agent discovery and registry.\"\n        />\n      )}\n    </div>\n  );\n}\n\nfunction EmptySection({ title, description }: { title: string; description: string }) {\n  return (\n    <div className=\"space-y-1\">\n      <h3 className=\"text-sm font-medium\">{title}</h3>\n      <p className=\"text-muted-foreground text-xs\">{description}</p>\n    </div>\n  );\n}\n\nfunction PulseSection({ agentId }: { agentId: string }) {\n  // Use existing useSchedules hook, filter by agent's CWD\n  // Show list of matching schedules with name and cron expression\n  return (\n    <div className=\"space-y-2\">\n      <h3 className=\"text-sm font-medium\">Pulse Schedules</h3>\n      <p className=\"text-muted-foreground text-xs\">No schedules linked to this agent.</p>\n    </div>\n  );\n}\n\nfunction RelaySection({ agentId }: { agentId: string }) {\n  // Use existing useRelayEndpoints hook, filter by agent\n  return (\n    <div className=\"space-y-2\">\n      <h3 className=\"text-sm font-medium\">Relay Endpoints</h3>\n      <p className=\"text-muted-foreground text-xs\">No relay endpoints registered.</p>\n    </div>\n  );\n}\n\nfunction MeshSection({ agentId }: { agentId: string }) {\n  const { data: health } = useMeshAgentHealth(agentId);\n  return (\n    <div className=\"space-y-2\">\n      <h3 className=\"text-sm font-medium\">Mesh Health</h3>\n      {health ? (\n        <div className=\"flex items-center gap-2\">\n          <Badge variant={health.status === 'active' ? 'default' : 'secondary'}>\n            {health.status}\n          </Badge>\n          {health.lastSeenAt && (\n            <span className=\"text-muted-foreground text-xs\">Last seen: {health.lastSeenAt}</span>\n          )}\n        </div>\n      ) : (\n        <p className=\"text-muted-foreground text-xs\">Agent not registered in Mesh.</p>\n      )}\n    </div>\n  );\n}\n```\n\n**Update AgentDialog.tsx:**\n\n```typescript\nimport { CapabilitiesTab } from './CapabilitiesTab';\nimport { ConnectionsTab } from './ConnectionsTab';\n\n// Replace placeholders:\n<TabsContent value=\"capabilities\">\n  <CapabilitiesTab agent={agent} onUpdate={handleUpdate} />\n</TabsContent>\n<TabsContent value=\"connections\">\n  <ConnectionsTab agent={agent} />\n</TabsContent>\n```\n\n**Key behaviors:**\n- Capabilities tab uses Enter/comma to add tags, X button to remove\n- Namespace, response mode, and budget fields are editable\n- Connections tab gracefully hides sections when subsystems are disabled\n- Connections tab shows empty states with helpful descriptions\n- Pulse section filters schedules by agent's CWD\n- Mesh section shows health badge from existing `useMeshAgentHealth` hook\n\n**Note on FSD cross-feature imports:** The ConnectionsTab imports from `entities/pulse`, `entities/relay`, and `entities/mesh` — this is valid since features can import from entities. It does NOT import from other features (e.g., it doesn't import PulsePanel or RelayPanel).\n\n**Component Tests:**\n- Test CapabilitiesTab renders existing capabilities as badges\n- Test adding a capability via Enter key\n- Test removing a capability via X button\n- Test namespace input updates\n- Test response mode dropdown shows all 4 options\n- Test ConnectionsTab renders empty states when subsystems disabled\n- Test ConnectionsTab renders Mesh health badge when available\n\n**Acceptance Criteria:**\n- [ ] CapabilitiesTab renders with tag input, namespace, response mode, budget fields\n- [ ] Tag input supports Enter/comma to add, X to remove\n- [ ] ConnectionsTab shows Pulse, Relay, Mesh sections\n- [ ] Subsystem sections hide when disabled\n- [ ] Empty states show helpful descriptions\n- [ ] Integrated into AgentDialog replacing placeholders\n- [ ] Component tests written and passing\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Implementing Capabilities and Connections tabs",
      "size": "large",
      "priority": "medium",
      "dependencies": ["3.1"],
      "parallelWith": ["3.2"]
    },
    {
      "id": "4.1",
      "phase": 4,
      "phaseName": "Surface Integration",
      "subject": "[agents-first-class-entity] [P4] Enhance DirectoryPicker to show agent identity in recents",
      "description": "Update the DirectoryPicker to display agent names, colored dots, and emojis for recently-used directories that have registered agents. Since DirectoryPicker is in `shared/ui/`, it cannot import from `entities/agent/` (FSD layer violation). Instead, the parent component resolves agents and passes them as a prop.\n\n**Files to modify:**\n- `apps/client/src/layers/shared/ui/DirectoryPicker.tsx` (accept and render resolvedAgents prop)\n- The parent component that renders DirectoryPicker (likely in `features/session-list/` or `features/chat/`) — add agent resolution logic\n\n**1. DirectoryPicker prop extension:**\n\nAdd an optional `resolvedAgents` prop to the DirectoryPicker:\n\n```typescript\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\ninterface DirectoryPickerProps {\n  // ... existing props\n  /** Map of directory path -> agent manifest for rendering agent identity in recents */\n  resolvedAgents?: Record<string, AgentManifest | null>;\n}\n```\n\n**2. Update recent items rendering:**\n\nFind the section that renders recent CWDs (look for `recentCwds.slice(0, 10).map(...)` or similar). Update to show agent identity when available:\n\n```typescript\nimport { hashToHslColor, hashToEmoji } from '@/layers/shared/lib/favicon-utils';\n\n// Inside the recents map:\n{recentCwds.slice(0, 10).map((recent) => {\n  const agent = resolvedAgents?.[recent.path] ?? null;\n\n  // Compute visual from agent or path\n  const color = agent?.color ?? hashToHslColor(agent?.id ?? recent.path);\n  const emoji = agent?.icon ?? hashToEmoji(agent?.id ?? recent.path);\n\n  return (\n    <button\n      key={recent.path}\n      onClick={() => handleRecentSelect(recent.path)}\n      className=\"hover:bg-accent flex w-full items-center gap-2 rounded-md px-2 py-1.5 text-left\"\n    >\n      {agent ? (\n        <>\n          <span\n            className=\"size-2 flex-shrink-0 rounded-full\"\n            style={{ backgroundColor: color }}\n          />\n          <span className=\"text-sm\">{emoji}</span>\n          <span className=\"min-w-0 flex-1 truncate text-sm font-medium\">{agent.name}</span>\n          <span className=\"text-muted-foreground truncate text-xs\">{shortenHomePath(recent.path)}</span>\n        </>\n      ) : (\n        <>\n          <FolderOpen className=\"size-4 flex-shrink-0\" />\n          <span className=\"min-w-0 flex-1 truncate text-sm\">{shortenHomePath(recent.path)}</span>\n        </>\n      )}\n      <span className=\"text-muted-foreground text-xs\">{formatRelativeTime(recent.accessedAt)}</span>\n    </button>\n  );\n})}\n```\n\n**3. Parent component integration:**\n\nIn the feature-layer component that renders DirectoryPicker, add agent resolution:\n\n```typescript\nimport { useResolvedAgents } from '@/layers/entities/agent';\n\n// Get recent paths\nconst recentPaths = recentCwds.map((r) => r.path);\nconst { data: resolvedAgents } = useResolvedAgents(recentPaths);\n\n// Pass to DirectoryPicker\n<DirectoryPicker\n  // ... existing props\n  resolvedAgents={resolvedAgents}\n/>\n```\n\n**Key behaviors:**\n- Batch resolution: `POST /api/agents/resolve` resolves all recent paths in one request\n- Agent identity shown: colored dot + emoji + agent name + shortened path (as secondary)\n- Plain directories: folder icon + path (unchanged behavior)\n- `resolvedAgents` prop is optional — DirectoryPicker works exactly as before when not provided\n- The visual identity computation uses the same priority as `useAgentVisual` but inlined (since DirectoryPicker is in shared/ and can't use the hook)\n\n**Component Tests** (`apps/client/src/layers/shared/ui/__tests__/DirectoryPicker.test.tsx`):\n- Test recent items show agent name when resolvedAgents provided for that path\n- Test recent items show folder icon when resolvedAgents has null for that path\n- Test recent items show folder icon when resolvedAgents prop is undefined\n- Test mixed list (some agents, some plain dirs) renders correctly\n- Test agent color dot uses agent.color override when set\n- Test agent color dot uses hash from agent.id when no color override\n\n**Acceptance Criteria:**\n- [ ] DirectoryPicker accepts optional `resolvedAgents` prop\n- [ ] Recent items show agent identity (dot, emoji, name) for registered dirs\n- [ ] Recent items show folder icon + path for unregistered dirs\n- [ ] Batch resolution via `useResolvedAgents` hook in parent component\n- [ ] No FSD layer violations (shared/ui doesn't import from entities)\n- [ ] Existing DirectoryPicker behavior unchanged when prop not provided\n- [ ] Component tests written and passing\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Enhancing DirectoryPicker with agent identity in recents",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["2.1"],
      "parallelWith": ["4.2"]
    },
    {
      "id": "4.2",
      "phase": 4,
      "phaseName": "Surface Integration",
      "subject": "[agents-first-class-entity] [P4] Add agent identity display to Pulse schedule rows",
      "description": "Update the Pulse schedule UI to show agent identity instead of raw paths when a schedule's CWD has a registered agent.\n\n**Files to modify:**\n- `apps/client/src/layers/features/pulse/ui/ScheduleRow.tsx`\n- `apps/client/src/layers/features/pulse/ui/PulsePanel.tsx` (resolve agents for schedule CWDs)\n- `apps/client/src/layers/features/pulse/ui/CreateScheduleDialog.tsx`\n\n**1. PulsePanel agent resolution:**\n\nIn PulsePanel (or whichever component renders the schedule list), resolve agents for all schedule CWDs:\n\n```typescript\nimport { useResolvedAgents } from '@/layers/entities/agent';\n\n// Inside PulsePanel:\nconst { data: schedules } = useSchedules();\nconst schedulePaths = (schedules ?? []).map((s) => s.cwd).filter(Boolean);\nconst uniquePaths = [...new Set(schedulePaths)];\nconst { data: resolvedAgents } = useResolvedAgents(uniquePaths);\n\n// Pass to each ScheduleRow:\n<ScheduleRow\n  schedule={schedule}\n  agent={resolvedAgents?.[schedule.cwd] ?? null}\n/>\n```\n\n**2. ScheduleRow enhancement:**\n\nAdd agent prop and display agent identity:\n\n```typescript\nimport { hashToHslColor, hashToEmoji } from '@/layers/shared/lib/favicon-utils';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\ninterface ScheduleRowProps {\n  schedule: PulseSchedule;\n  agent?: AgentManifest | null;\n}\n\n// In the row display, find where the CWD/path is shown and replace with:\n{agent ? (\n  <div className=\"flex items-center gap-1\">\n    <span\n      className=\"size-2 rounded-full\"\n      style={{ backgroundColor: agent.color ?? hashToHslColor(agent.id) }}\n    />\n    <span className=\"text-xs\">{agent.icon ?? hashToEmoji(agent.id)}</span>\n    <span className=\"text-sm font-medium\">{agent.name}</span>\n  </div>\n) : (\n  <span className=\"text-muted-foreground text-xs\">{shortenHomePath(schedule.cwd)}</span>\n)}\n```\n\n**3. CreateScheduleDialog enhancement:**\n\nAfter the user selects a CWD via DirectoryPicker, if that CWD has a registered agent, show the agent name prominently above the path:\n\n```typescript\nimport { useCurrentAgent, useAgentVisual } from '@/layers/entities/agent';\n\n// Inside CreateScheduleDialog, after CWD selection:\nconst { data: selectedAgent } = useCurrentAgent(selectedCwd);\nconst visual = useAgentVisual(selectedAgent ?? null, selectedCwd ?? '');\n\n// In the form, after the directory picker:\n{selectedAgent && selectedCwd && (\n  <div className=\"flex items-center gap-2 rounded-md bg-accent/50 px-3 py-2\">\n    <span\n      className=\"size-2.5 rounded-full\"\n      style={{ backgroundColor: visual.color }}\n    />\n    <span>{visual.emoji}</span>\n    <span className=\"font-medium\">{selectedAgent.name}</span>\n  </div>\n)}\n```\n\n**Key behaviors:**\n- PulsePanel batch-resolves agents for all schedule CWDs (single request)\n- ScheduleRow shows agent identity when available, path when not\n- CreateScheduleDialog shows agent identity after CWD selection\n- No changes to schedule data model — display-only enhancement\n\n**Acceptance Criteria:**\n- [ ] ScheduleRow shows agent name, dot, emoji when agent exists for CWD\n- [ ] ScheduleRow shows shortened path when no agent\n- [ ] PulsePanel batch-resolves agents for all schedule CWDs\n- [ ] CreateScheduleDialog shows agent identity after CWD selection\n- [ ] Existing Pulse functionality unchanged\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Adding agent identity to Pulse schedule rows",
      "size": "small",
      "priority": "low",
      "dependencies": ["2.1"],
      "parallelWith": ["4.1"]
    },
    {
      "id": "4.3",
      "phase": 4,
      "phaseName": "Surface Integration",
      "subject": "[agents-first-class-entity] [P4] Update documentation for agent identity feature",
      "description": "Update internal documentation to reflect the new agent identity feature, including FSD layer tables, data fetching patterns, and API reference.\n\n**Files to modify:**\n- `contributing/architecture.md` — Add Agent entity layer to the FSD layer table; document `/api/agents` endpoints in the route groups section\n- `contributing/data-fetching.md` — Add agent query key patterns following existing patterns\n- `CLAUDE.md` — Update the FSD layers table to include `entities/agent/`; update route count and descriptions; update service descriptions; add Transport methods\n\n**1. `contributing/architecture.md` updates:**\n\nIn the FSD Layers table, add the agent entity:\n\n```\n| `entities/agent/`    | useCurrentAgent, useCreateAgent, useUpdateAgent, useResolvedAgents, useAgentVisual | Agent identity domain hooks |\n```\n\nIn the features table, add agent-settings:\n\n```\n| `features/agent-settings/` | AgentDialog, IdentityTab, PersonaTab, CapabilitiesTab, ConnectionsTab | Agent settings dialog |\n```\n\nIn the route groups section, add the agents routes:\n\n```\n- **`routes/agents.ts`** — Agent identity CRUD (GET/POST/PATCH current, POST resolve). Always mounted, no feature flag. Reads/writes .dork/agent.json via shared manifest module.\n```\n\n**2. `contributing/data-fetching.md` updates:**\n\nAdd agent query key patterns:\n\n```typescript\n// Agent entity query keys\nexport const agentKeys = {\n  all: ['agents'] as const,\n  byPath: (path: string) => ['agents', 'byPath', path] as const,\n  resolved: (paths: string[]) => ['agents', 'resolved', ...paths] as const,\n};\n```\n\nDocument the optimistic update pattern used by `useUpdateAgent`.\n\n**3. `CLAUDE.md` updates:**\n\nUpdate the FSD layers table in the Client section to include `entities/agent/` and `features/agent-settings/`.\n\nUpdate the server route groups to include `routes/agents.ts`.\n\nUpdate the Transport interface section to mention the four new agent methods.\n\nUpdate the services section to mention the manifest module in shared.\n\n**Acceptance Criteria:**\n- [ ] `contributing/architecture.md` includes agent entity layer and agent-settings feature\n- [ ] `contributing/data-fetching.md` includes agent query key patterns\n- [ ] `CLAUDE.md` FSD table includes new agent modules\n- [ ] `CLAUDE.md` route groups include agents routes\n- [ ] `CLAUDE.md` Transport interface mentions agent methods\n- [ ] All documentation changes are accurate and consistent with implementation",
      "activeForm": "Updating documentation for agent identity feature",
      "size": "small",
      "priority": "low",
      "dependencies": ["3.1", "3.2", "3.3", "4.1", "4.2"],
      "parallelWith": []
    }
  ]
}
