{
  "spec": "specs/browser-testing-system/02-specification.md",
  "slug": "browser-testing-system",
  "generatedAt": "2026-02-25T12:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[browser-testing-system] [P1] Create apps/e2e workspace with Playwright config",
      "description": "Create the `apps/e2e/` directory as a new Turborepo workspace with Playwright Test.\n\n## Steps\n\n### 1. Create `apps/e2e/package.json`\n\n```json\n{\n  \"name\": \"@dorkos/e2e\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"type\": \"module\",\n  \"scripts\": {\n    \"e2e\": \"playwright test\",\n    \"e2e:ui\": \"playwright test --ui\"\n  },\n  \"devDependencies\": {\n    \"@playwright/test\": \"^1.51.0\",\n    \"@dorkos/typescript-config\": \"*\"\n  }\n}\n```\n\n### 2. Create `apps/e2e/tsconfig.json`\n\n```json\n{\n  \"extends\": \"@dorkos/typescript-config/base.json\",\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"bundler\",\n    \"types\": []\n  },\n  \"include\": [\"**/*.ts\"]\n}\n```\n\n### 3. Create `apps/e2e/playwright.config.ts`\n\n```typescript\nimport { defineConfig, devices } from '@playwright/test';\n\nconst CI = !!process.env.CI;\nconst PORT = process.env.DORKOS_PORT || '4242';\nconst VITE_PORT = process.env.VITE_PORT || '4241';\n\nexport default defineConfig({\n  testDir: './tests',\n  fullyParallel: true,\n  forbidOnly: CI,\n  retries: CI ? 2 : 0,\n  workers: CI ? 1 : undefined,\n  timeout: 30_000,\n\n  reporter: [\n    ['html', { open: 'never', outputFolder: 'playwright-report' }],\n    ['json', { outputFile: 'test-results/results.json' }],\n    CI ? ['github'] : ['list'],\n    ['./reporters/manifest-reporter.ts'],\n  ],\n\n  use: {\n    baseURL: `http://localhost:${VITE_PORT}`,\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure',\n    video: 'retain-on-failure',\n  },\n\n  webServer: [\n    {\n      command: 'dotenv -- turbo dev --filter=@dorkos/server',\n      url: `http://localhost:${PORT}/api/health`,\n      name: 'Express API',\n      timeout: 120_000,\n      reuseExistingServer: !CI,\n      stdout: 'pipe',\n      stderr: 'pipe',\n    },\n    {\n      command: 'dotenv -- turbo dev --filter=@dorkos/client',\n      url: `http://localhost:${VITE_PORT}`,\n      name: 'Vite Client',\n      timeout: 120_000,\n      reuseExistingServer: !CI,\n      stdout: 'pipe',\n    },\n  ],\n\n  projects: [\n    {\n      name: 'chromium',\n      use: { ...devices['Desktop Chrome'] },\n    },\n  ],\n});\n```\n\n### 4. Create `apps/e2e/.gitignore`\n\n```\nplaywright-report/\ntest-results/\nblob-report/\nplaywright/.cache/\nplaywright/.auth/\n```\n\n### 5. Create empty directory structure\n\nCreate these empty directories with `.gitkeep` files:\n- `apps/e2e/tests/`\n- `apps/e2e/fixtures/`\n- `apps/e2e/pages/`\n- `apps/e2e/reporters/`\n\n### 6. Initialize `apps/e2e/manifest.json`\n\n```json\n{\n  \"version\": 1,\n  \"tests\": {},\n  \"runHistory\": []\n}\n```\n\n### 7. Install dependencies\n\nRun `npm install` from the repo root to link the new workspace, then `npx playwright install chromium` from `apps/e2e/`.\n\n## Acceptance Criteria\n\n- `apps/e2e/package.json` exists and is recognized as a workspace (`npm ls @dorkos/e2e` succeeds)\n- `apps/e2e/playwright.config.ts` exists with multi-server webServer config\n- `apps/e2e/.gitignore` excludes playwright-report/, test-results/, blob-report/, playwright/.cache/, playwright/.auth/\n- `apps/e2e/manifest.json` is initialized with `{ version: 1, tests: {}, runHistory: [] }`\n- `npx playwright --version` works from within apps/e2e/\n- Chromium browser is installed via `npx playwright install chromium`",
      "activeForm": "Creating apps/e2e workspace with Playwright config",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.2"]
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[browser-testing-system] [P1] Add turbo tasks and npm scripts for E2E",
      "description": "Add Turborepo task definitions and root npm scripts for running browser tests.\n\n## Steps\n\n### 1. Add tasks to `turbo.json`\n\nAdd two new task entries to the `tasks` object in `turbo.json`:\n\n```json\n\"e2e\": {\n  \"dependsOn\": [\"^build\"],\n  \"cache\": false,\n  \"passThroughEnv\": [\n    \"PLAYWRIGHT_BROWSERS_PATH\",\n    \"PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD\",\n    \"CI\",\n    \"PWDEBUG\",\n    \"ANTHROPIC_API_KEY\"\n  ]\n},\n\"e2e:ui\": {\n  \"cache\": false,\n  \"persistent\": true\n}\n```\n\nKey design decisions:\n- `cache: false` because browser tests have external side effects (real servers, real browsers), caching produces false positives\n- `passThroughEnv` includes `ANTHROPIC_API_KEY` for `@integration` tests that call the real Agent SDK\n- `passThroughEnv` includes `CI` for conditional behavior (retries, workers, reporter selection)\n- `passThroughEnv` includes `PWDEBUG` for interactive debug mode\n- `e2e:ui` is `persistent: true` because Playwright UI mode is a long-running interactive process\n- Both tasks inherit `globalPassThroughEnv` (DORKOS_PORT etc.) from the existing turbo.json config\n\n### 2. Add scripts to root `package.json`\n\nAdd to the `scripts` object:\n\n```json\n\"test:browser\": \"turbo run e2e --filter=@dorkos/e2e --only\",\n\"test:browser:ui\": \"turbo run e2e:ui --filter=@dorkos/e2e --only\"\n```\n\nThe `--only` flag bypasses the `^build` dependency graph when dev servers are already running, giving faster feedback loops during development.\n\n## Acceptance Criteria\n\n- `turbo.json` contains `e2e` task with `cache: false` and the five `passThroughEnv` entries\n- `turbo.json` contains `e2e:ui` task with `cache: false` and `persistent: true`\n- Root `package.json` has `test:browser` and `test:browser:ui` scripts\n- `npm run test:browser` attempts to run Playwright (may fail if no tests exist yet, but the turbo pipeline should resolve correctly)\n- `DORKOS_PORT` and `VITE_PORT` are available to the e2e task (inherited from `globalPassThroughEnv` — add `VITE_PORT` to `globalPassThroughEnv` if not already present)",
      "activeForm": "Adding turbo tasks and npm scripts for E2E",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1"]
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[browser-testing-system] [P1] Create Page Object Models and fixtures",
      "description": "Create the four Page Object Models (BasePage, ChatPage, SessionSidebarPage, SettingsPage) and the extended Playwright fixture that injects them.\n\n## Steps\n\n### 1. Create `apps/e2e/pages/BasePage.ts`\n\n```typescript\nimport type { Page } from '@playwright/test';\n\nexport class BasePage {\n  constructor(readonly page: Page) {}\n\n  async goto(path = '/') {\n    await this.page.goto(path);\n  }\n\n  async waitForAppReady() {\n    // Wait for the main app shell to render\n    await this.page.waitForSelector('[data-testid=\"app-shell\"]', { timeout: 10_000 });\n  }\n}\n```\n\n### 2. Create `apps/e2e/pages/ChatPage.ts`\n\n```typescript\nimport type { Page, Locator } from '@playwright/test';\n\nexport class ChatPage {\n  readonly page: Page;\n  readonly input: Locator;\n  readonly sendButton: Locator;\n  readonly messageList: Locator;\n\n  constructor(page: Page) {\n    this.page = page;\n    this.input = page.getByRole('textbox', { name: /message/i });\n    this.sendButton = page.getByRole('button', { name: /send/i });\n    this.messageList = page.locator('[data-testid=\"message-list\"]');\n  }\n\n  async goto(sessionId?: string) {\n    const url = sessionId ? `/?session=${sessionId}` : '/';\n    await this.page.goto(url);\n    await this.page.waitForSelector('[data-testid=\"chat-panel\"]', { timeout: 10_000 });\n  }\n\n  async sendMessage(text: string) {\n    await this.input.fill(text);\n    await this.sendButton.click();\n  }\n\n  async waitForResponse(timeoutMs = 60_000) {\n    // Wait for inference indicator to appear then disappear (streaming complete)\n    await this.page.locator('[data-testid=\"inference-indicator\"]')\n      .waitFor({ state: 'visible', timeout: 10_000 }).catch(() => {});\n    await this.page.locator('[data-testid=\"inference-indicator\"]')\n      .waitFor({ state: 'hidden', timeout: timeoutMs });\n  }\n\n  async getMessages(): Promise<Locator> {\n    return this.messageList.locator('[data-testid=\"message-item\"]');\n  }\n\n  async lastAssistantMessage(): Promise<Locator> {\n    return this.messageList.locator('[data-testid=\"message-item\"][data-role=\"assistant\"]').last();\n  }\n}\n```\n\n### 3. Create `apps/e2e/pages/SessionSidebarPage.ts`\n\n```typescript\nimport type { Page, Locator } from '@playwright/test';\n\nexport class SessionSidebarPage {\n  readonly page: Page;\n  readonly newChatButton: Locator;\n  readonly sessionList: Locator;\n\n  constructor(page: Page) {\n    this.page = page;\n    this.newChatButton = page.getByRole('button', { name: /new chat/i });\n    this.sessionList = page.locator('[data-testid=\"session-list\"]');\n  }\n\n  async createNewSession() {\n    await this.newChatButton.click();\n  }\n\n  async selectSession(index: number) {\n    const sessions = this.sessionList.locator('[data-testid=\"session-item\"]');\n    await sessions.nth(index).click();\n  }\n\n  async getSessionCount(): Promise<number> {\n    return this.sessionList.locator('[data-testid=\"session-item\"]').count();\n  }\n}\n```\n\n### 4. Create `apps/e2e/pages/SettingsPage.ts`\n\n```typescript\nimport type { Page, Locator } from '@playwright/test';\n\nexport class SettingsPage {\n  readonly page: Page;\n  readonly dialog: Locator;\n\n  constructor(page: Page) {\n    this.page = page;\n    this.dialog = page.locator('[data-testid=\"settings-dialog\"]');\n  }\n\n  async open() {\n    await this.page.getByRole('button', { name: /settings/i }).click();\n    await this.dialog.waitFor({ state: 'visible' });\n  }\n\n  async close() {\n    await this.page.keyboard.press('Escape');\n    await this.dialog.waitFor({ state: 'hidden' });\n  }\n\n  async switchTab(tabName: string) {\n    await this.dialog.getByRole('tab', { name: new RegExp(tabName, 'i') }).click();\n  }\n}\n```\n\n### 5. Create `apps/e2e/fixtures/index.ts`\n\n```typescript\nimport { test as base } from '@playwright/test';\nimport { ChatPage } from '../pages/ChatPage';\nimport { SessionSidebarPage } from '../pages/SessionSidebarPage';\nimport { SettingsPage } from '../pages/SettingsPage';\nimport { BasePage } from '../pages/BasePage';\n\ntype DorkOSFixtures = {\n  basePage: BasePage;\n  chatPage: ChatPage;\n  sessionSidebar: SessionSidebarPage;\n  settingsPage: SettingsPage;\n};\n\nexport const test = base.extend<DorkOSFixtures>({\n  basePage: async ({ page }, use) => {\n    await use(new BasePage(page));\n  },\n  chatPage: async ({ page }, use) => {\n    const chatPage = new ChatPage(page);\n    await chatPage.goto();\n    await use(chatPage);\n  },\n  sessionSidebar: async ({ page }, use) => {\n    await use(new SessionSidebarPage(page));\n  },\n  settingsPage: async ({ page }, use) => {\n    await use(new SettingsPage(page));\n  },\n});\n\nexport { expect } from '@playwright/test';\n```\n\nThis fixture setup uses `test.extend()` to inject POMs as fixtures, eliminating repetitive `beforeEach` boilerplate. The `chatPage` fixture automatically navigates to the app on creation. Other fixtures are lazy (no auto-navigation).\n\n## Acceptance Criteria\n\n- All four POM files exist in `apps/e2e/pages/`\n- `apps/e2e/fixtures/index.ts` exists and exports `test` and `expect`\n- POMs use `getByRole` as the primary selector strategy, `data-testid` as fallback\n- `ChatPage.waitForResponse()` uses inference indicator visibility state (not arbitrary timeouts)\n- TypeScript compiles without errors (`npx tsc --noEmit` from apps/e2e/)\n- The `chatPage` fixture auto-navigates to `/` and waits for `[data-testid=\"chat-panel\"]`",
      "activeForm": "Creating Page Object Models and fixtures",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": ["1.4"]
    },
    {
      "id": "1.4",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[browser-testing-system] [P1] Add data-testid attributes to client components",
      "description": "Add `data-testid` attributes to 10 client components for stable E2E selectors. These attributes are required by the Page Object Models.\n\n## Component Mapping\n\nEach entry lists the file path, the element to target, and the exact attribute to add:\n\n### 1. App shell wrapper\n- **File**: `apps/client/src/App.tsx`\n- **Attribute**: `data-testid=\"app-shell\"`\n- **Target**: The outermost wrapper div of the app (likely the root `<div>` or `<main>` element)\n\n### 2. Chat panel\n- **File**: `apps/client/src/layers/features/chat/ui/ChatPanel.tsx`\n- **Attribute**: `data-testid=\"chat-panel\"`\n- **Target**: The root element of the ChatPanel component\n\n### 3. Message list\n- **File**: `apps/client/src/layers/features/chat/ui/MessageList.tsx`\n- **Attribute**: `data-testid=\"message-list\"`\n- **Target**: The scrollable container that holds all messages\n\n### 4. Message item\n- **File**: `apps/client/src/layers/features/chat/ui/MessageItem.tsx`\n- **Attribute**: `data-testid=\"message-item\"` AND `data-role=\"user\"` or `data-role=\"assistant\"`\n- **Target**: The root element of each message. The `data-role` attribute should reflect the message's role (user or assistant), derived from the message data prop.\n\n### 5. Session sidebar\n- **File**: `apps/client/src/layers/features/session-list/ui/SessionSidebar.tsx`\n- **Attribute**: `data-testid=\"session-sidebar\"`\n- **Target**: The root element of the sidebar component\n\n### 6. Session list\n- **File**: `apps/client/src/layers/features/session-list/ui/SessionSidebar.tsx`\n- **Attribute**: `data-testid=\"session-list\"`\n- **Target**: The container element that wraps the list of session items (not the sidebar root, but the inner list)\n\n### 7. Session item\n- **File**: `apps/client/src/layers/features/session-list/ui/SessionItem.tsx`\n- **Attribute**: `data-testid=\"session-item\"`\n- **Target**: The root element of each session item\n\n### 8. Status line\n- **File**: `apps/client/src/layers/features/status/ui/StatusLine.tsx`\n- **Attribute**: `data-testid=\"status-line\"`\n- **Target**: The root element of the status line component\n\n### 9. Settings dialog\n- **File**: `apps/client/src/layers/features/settings/ui/SettingsDialog.tsx`\n- **Attribute**: `data-testid=\"settings-dialog\"`\n- **Target**: The Dialog content element (not the trigger button, but the dialog panel itself)\n\n### 10. Inference indicator\n- **File**: `apps/client/src/layers/features/chat/ui/InferenceIndicator.tsx`\n- **Current attribute**: `data-testid=\"inference-indicator-streaming\"` (may already exist)\n- **New attribute**: Rename to `data-testid=\"inference-indicator\"`\n- **Target**: The visible indicator element shown during streaming\n\n## Implementation Notes\n\n- Add attributes directly to JSX elements, not via spread or utility functions\n- For components using `forwardRef`, add to the forwarded element\n- For components using `motion.*` wrappers, add to the motion element\n- Do NOT add data-testid to elements that are conditionally rendered and might break the attribute chain\n- Update any existing tests that reference the old `inference-indicator-streaming` testid\n\n## Acceptance Criteria\n\n- All 10 `data-testid` attributes are present in the correct component files\n- `MessageItem` has both `data-testid=\"message-item\"` and `data-role` based on message role\n- `InferenceIndicator` uses `data-testid=\"inference-indicator\"` (not `inference-indicator-streaming`)\n- Existing Vitest unit tests still pass (update any that reference the old testid)\n- No TypeScript errors introduced\n- `npm run typecheck` passes",
      "activeForm": "Adding data-testid attributes to client components",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.3"]
    },
    {
      "id": "1.5",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[browser-testing-system] [P1] Create custom manifest reporter",
      "description": "Create the custom Playwright reporter that updates `manifest.json` after each test run for AI health tracking.\n\n## Steps\n\n### 1. Create `apps/e2e/reporters/manifest-reporter.ts`\n\n```typescript\nimport type {\n  Reporter, TestCase, TestResult, FullResult, Suite,\n} from '@playwright/test/reporter';\nimport fs from 'node:fs';\nimport path from 'node:path';\n\ninterface TestEntry {\n  specFile: string;\n  feature: string;\n  description: string;\n  lastRun: string;\n  lastStatus: string;\n  runCount: number;\n  passCount: number;\n  failCount: number;\n}\n\ninterface Manifest {\n  version: number;\n  tests: Record<string, TestEntry>;\n  runHistory: Array<{\n    id: string;\n    timestamp: string;\n    total: number;\n    passed: number;\n    failed: number;\n    skipped: number;\n    duration: number;\n  }>;\n}\n\nclass ManifestReporter implements Reporter {\n  private manifestPath: string;\n  private manifest: Manifest;\n  private runResults: { title: string; status: string; file: string; duration: number }[] = [];\n  private startTime = Date.now();\n\n  constructor() {\n    this.manifestPath = path.resolve(__dirname, '..', 'manifest.json');\n    this.manifest = this.loadManifest();\n  }\n\n  private loadManifest(): Manifest {\n    try {\n      return JSON.parse(fs.readFileSync(this.manifestPath, 'utf-8'));\n    } catch {\n      return { version: 1, tests: {}, runHistory: [] };\n    }\n  }\n\n  onTestEnd(test: TestCase, result: TestResult) {\n    const relativeFile = path.relative(\n      path.resolve(__dirname, '..', 'tests'),\n      test.location.file,\n    );\n    const feature = relativeFile.split(path.sep)[0] || 'unknown';\n    const testKey = path.basename(test.location.file, '.spec.ts');\n\n    // Update test entry\n    const existing = this.manifest.tests[testKey] || {\n      specFile: `tests/${relativeFile}`,\n      feature,\n      description: test.title,\n      lastRun: '',\n      lastStatus: '',\n      runCount: 0,\n      passCount: 0,\n      failCount: 0,\n    };\n\n    existing.lastRun = new Date().toISOString();\n    existing.lastStatus = result.status;\n    existing.runCount++;\n    if (result.status === 'passed') existing.passCount++;\n    if (result.status === 'failed') existing.failCount++;\n    this.manifest.tests[testKey] = existing;\n\n    this.runResults.push({\n      title: test.title,\n      status: result.status,\n      file: relativeFile,\n      duration: result.duration,\n    });\n  }\n\n  onEnd(result: FullResult) {\n    const now = new Date();\n    const runId = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);\n\n    // Add run to history (keep last 100)\n    this.manifest.runHistory.push({\n      id: runId,\n      timestamp: now.toISOString(),\n      total: this.runResults.length,\n      passed: this.runResults.filter(r => r.status === 'passed').length,\n      failed: this.runResults.filter(r => r.status === 'failed').length,\n      skipped: this.runResults.filter(r => r.status === 'skipped').length,\n      duration: Date.now() - this.startTime,\n    });\n    if (this.manifest.runHistory.length > 100) {\n      this.manifest.runHistory = this.manifest.runHistory.slice(-100);\n    }\n\n    fs.writeFileSync(this.manifestPath, JSON.stringify(this.manifest, null, 2));\n  }\n}\n\nexport default ManifestReporter;\n```\n\n### Key Design Decisions\n\n- **Synchronous write at end of run**: The `onEnd` method writes the manifest synchronously after all tests complete. No impact during test execution.\n- **Last 100 runs retained**: `runHistory` is capped at 100 entries to keep the manifest file manageable.\n- **Test keyed by filename**: Each test is keyed by the spec filename (without extension), e.g., `send-message`. This means one entry per spec file, not per `test()` call.\n- **Feature derived from directory**: The first path segment of the relative file path becomes the feature name (e.g., `chat`, `smoke`, `settings`).\n- **Graceful fallback**: If `manifest.json` doesn't exist or is corrupt, a fresh manifest is created.\n\n## Acceptance Criteria\n\n- `apps/e2e/reporters/manifest-reporter.ts` exists and compiles without errors\n- Reporter is referenced in `playwright.config.ts` as `['./reporters/manifest-reporter.ts']`\n- After running tests, `manifest.json` is updated with test entries and run history\n- Each test entry has `specFile`, `feature`, `description`, `lastRun`, `lastStatus`, `runCount`, `passCount`, `failCount`\n- Run history entries have `id`, `timestamp`, `total`, `passed`, `failed`, `skipped`, `duration`\n- Run history is capped at 100 entries\n- If `manifest.json` is missing or corrupt, the reporter creates a fresh one",
      "activeForm": "Creating custom manifest reporter",
      "size": "small",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": ["1.3", "1.4"]
    },
    {
      "id": "1.6",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[browser-testing-system] [P1] Write seed tests for smoke, chat, sessions, and settings",
      "description": "Write the four seed test files that validate the Playwright infrastructure works end-to-end.\n\n## Steps\n\n### 1. Create `apps/e2e/tests/smoke/app-loads.spec.ts`\n\n```typescript\nimport { test, expect } from '../../fixtures';\n\ntest.describe('Smoke — App Loading @smoke', () => {\n  test('renders the app shell with sidebar and chat panel', async ({ basePage }) => {\n    await basePage.goto();\n    await basePage.waitForAppReady();\n\n    await expect(basePage.page.locator('[data-testid=\"session-sidebar\"]')).toBeVisible();\n    await expect(basePage.page.locator('[data-testid=\"chat-panel\"]')).toBeVisible();\n  });\n\n  test('displays the status line', async ({ basePage }) => {\n    await basePage.goto();\n    await basePage.waitForAppReady();\n\n    await expect(basePage.page.locator('[data-testid=\"status-line\"]')).toBeVisible();\n  });\n});\n```\n\nThis smoke test validates: Playwright config works, webServer starts both servers, fixtures inject correctly, app renders its core layout.\n\n### 2. Create `apps/e2e/tests/chat/send-message.spec.ts`\n\n```typescript\nimport { test, expect } from '../../fixtures';\n\ntest.describe('Chat — Send Message @integration', () => {\n  test('sends a message and receives a response', async ({ chatPage }) => {\n    await chatPage.sendMessage('Respond with exactly: hello world');\n    await chatPage.waitForResponse();\n\n    const lastMessage = await chatPage.lastAssistantMessage();\n    await expect(lastMessage).toContainText('hello world');\n  });\n\n  test('shows inference indicator while streaming', async ({ chatPage }) => {\n    await chatPage.sendMessage('Count from 1 to 5');\n\n    // Inference indicator should appear during streaming\n    await expect(chatPage.page.locator('[data-testid=\"inference-indicator\"]'))\n      .toBeVisible({ timeout: 10_000 });\n  });\n});\n```\n\nTagged `@integration` because these tests call the real Agent SDK and require `ANTHROPIC_API_KEY`. They prove the full stack works: client POST -> server -> Agent SDK -> SSE streaming -> client renders response.\n\n### 3. Create `apps/e2e/tests/session-list/session-management.spec.ts`\n\n```typescript\nimport { test, expect } from '../../fixtures';\n\ntest.describe('Session List — Management @smoke', () => {\n  test('creates a new chat session', async ({ chatPage, sessionSidebar }) => {\n    const initialCount = await sessionSidebar.getSessionCount();\n    await sessionSidebar.createNewSession();\n\n    // URL should update with new session ID\n    await expect(chatPage.page).toHaveURL(/session=/);\n  });\n});\n```\n\n### 4. Create `apps/e2e/tests/settings/settings-dialog.spec.ts`\n\n```typescript\nimport { test, expect } from '../../fixtures';\n\ntest.describe('Settings — Dialog @smoke', () => {\n  test('opens and closes the settings dialog', async ({ basePage, settingsPage }) => {\n    await basePage.goto();\n    await basePage.waitForAppReady();\n\n    await settingsPage.open();\n    await expect(settingsPage.dialog).toBeVisible();\n\n    await settingsPage.close();\n    await expect(settingsPage.dialog).toBeHidden();\n  });\n\n  test('switches between settings tabs', async ({ basePage, settingsPage }) => {\n    await basePage.goto();\n    await basePage.waitForAppReady();\n\n    await settingsPage.open();\n    await settingsPage.switchTab('Server');\n\n    await expect(settingsPage.dialog.getByRole('tabpanel')).toBeVisible();\n  });\n});\n```\n\n## Test Tagging Strategy\n\n- `@smoke` — Critical path tests that don't require Agent SDK. Fast to run, good for pre-commit checks. Run with `--grep @smoke`.\n- `@integration` — Tests that call the real Agent SDK via the Express server. Require `ANTHROPIC_API_KEY`. Slower (10-60s per test). Run with `--grep @integration`.\n\n## Acceptance Criteria\n\n- All four test files exist in the correct directories under `apps/e2e/tests/`\n- Tests import from `../../fixtures` (the custom fixture file, not `@playwright/test` directly)\n- Tests use POM methods (not raw locator calls) for primary interactions\n- `@smoke` tests do NOT depend on Agent SDK or ANTHROPIC_API_KEY\n- `@integration` tests are tagged and clearly documented as SDK-dependent\n- Running `npx playwright test --grep @smoke` from `apps/e2e/` executes only smoke tests\n- After running tests, `manifest.json` is updated by the manifest reporter",
      "activeForm": "Writing seed tests for smoke, chat, sessions, and settings",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.3", "1.4", "1.5"],
      "parallelWith": []
    },
    {
      "id": "1.7",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[browser-testing-system] [P1] Write contributing/browser-testing.md guide",
      "description": "Create the developer guide for the browser testing system covering all aspects of writing, running, and maintaining browser tests.\n\n## File: `contributing/browser-testing.md`\n\n## Required Sections\n\n### 1. Quick Start\n\nHow to run browser tests:\n```bash\n# Run all browser tests (reuses running dev server)\nnpm run test:browser\n\n# Run specific feature\ncd apps/e2e && npx playwright test tests/chat/\n\n# Run smoke suite only (fast, no SDK dependency)\ncd apps/e2e && npx playwright test --grep @smoke\n\n# Interactive UI mode\nnpm run test:browser:ui\n\n# Debug mode (opens browser inspector)\ncd apps/e2e && PWDEBUG=1 npx playwright test tests/chat/send-message.spec.ts\n```\n\nPrerequisites:\n- Chromium browser installed: `cd apps/e2e && npx playwright install chromium`\n- For `@integration` tests: `ANTHROPIC_API_KEY` must be set in `.env`\n- Dev servers running (auto-started if not): `npm run dev`\n\n### 2. Architecture\n\nExplain the two-layer system:\n- **Layer 1: Standard Playwright Test suite** — deterministic `.spec.ts` files, CI-friendly, no AI dependency. Lives in `apps/e2e/tests/`.\n- **Layer 2: AI orchestration layer** — `.claude/commands/browsertest.md` and `.claude/skills/browser-testing/` that use the Playwright MCP server to write, debug, and maintain tests.\n\nDirectory structure diagram matching the spec's `apps/e2e/` layout.\n\n### 3. Writing Tests\n\nPOM patterns and fixture usage:\n- Import `test` and `expect` from `../../fixtures` (never directly from `@playwright/test`)\n- Use POM methods for all interactions (never raw page.locator in test bodies)\n- Selector strategy priority: `getByRole` > `data-testid` > CSS class\n- Wait strategy: use locator visibility states, never `setTimeout` or `page.waitForTimeout`\n- Test tagging: `@smoke` for critical path, `@integration` for SDK-dependent\n\n### 4. Running Tests\n\nFull reference for npm scripts, Playwright CLI options, UI mode, debug mode, grep filtering, and the relationship between turbo tasks and Playwright.\n\n### 5. AI Commands\n\nUsage reference for `/browsertest` with all subcommands: `run`, `debug`, `maintain`, `report`, `create`.\n\n### 6. Manifest\n\nExplain `manifest.json` structure, how the custom reporter updates it, and how AI commands read it for health tracking.\n\n### 7. Adding New Tests\n\nStep-by-step guide:\n1. Create a new POM if the feature needs one (in `pages/`)\n2. Register the POM as a fixture in `fixtures/index.ts`\n3. Create the test file in the appropriate `tests/<feature>/` directory\n4. Run the test to verify it passes\n5. Manifest is auto-updated by the reporter\n\n### 8. Debugging\n\nInterpreting failures, using Playwright traces (`trace: 'on-first-retry'`), HTML reports, and MCP-assisted debugging.\n\n### 9. Maintenance\n\nStale test detection, the audit workflow via `/browsertest maintain`, and how the manifest tracks test health over time.\n\n## Acceptance Criteria\n\n- `contributing/browser-testing.md` exists with all 9 sections\n- Quick start commands are accurate and tested\n- Architecture section explains the two-layer system\n- Guide references actual file paths in the `apps/e2e/` directory\n- No broken links to other contributing guides\n- Follows the style and formatting conventions of existing guides in `contributing/`",
      "activeForm": "Writing contributing/browser-testing.md guide",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["1.6"],
      "parallelWith": []
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "AI Commands",
      "subject": "[browser-testing-system] [P2] Create /browsertest command with smart routing",
      "description": "Create the `/browsertest` Claude Code command with smart routing logic that dispatches to run, debug, maintain, report, or create subcommands.\n\n## File: `.claude/commands/browsertest.md`\n\n### Frontmatter\n\n```yaml\n---\ndescription: Run, create, debug, and maintain browser tests\nallowed-tools: Read, Write, Edit, Grep, Glob, Bash, Task, TaskOutput, AskUserQuestion\nargument-hint: '<run|debug|maintain|report|create> [feature] [description]'\ncategory: testing\n---\n```\n\n### Command Body\n\nThe command body should contain the full routing logic as instructions for Claude Code. It must handle these usage patterns:\n\n| Usage | Behavior |\n|---|---|\n| `/browsertest run` | Run entire suite: `npx playwright test` from `apps/e2e/` |\n| `/browsertest run chat` | Run feature subset: `npx playwright test tests/chat/` |\n| `/browsertest chat messaging` | Find matching test in manifest OR create new one |\n| `/browsertest debug chat-messaging` | Diagnose failing test with Playwright MCP |\n| `/browsertest maintain` | Delegates to `/browsertest:maintain` |\n| `/browsertest report` | Show health dashboard from manifest.json |\n| `/browsertest create chat file-upload` | Explicitly create a new test |\n\n### Smart Routing Logic\n\nThe command should parse the argument `$ARGUMENTS` and route based on the first word:\n\n1. **`run [feature]`** — Execute tests. If a feature name is provided, run only `tests/<feature>/`. Otherwise run all tests. Show results summary after completion.\n\n2. **`create <feature> <description>`** — Create a new test:\n   - Use Playwright MCP to navigate to the feature in the running app\n   - Capture accessibility snapshots to identify key elements and selectors\n   - Generate `.spec.ts` file with appropriate POM usage\n   - Run the test to verify it passes\n   - Update manifest.json with test metadata\n\n3. **`debug <test-name>`** — Debug a failing test:\n   - Run the failing test with `--reporter=json` to capture error details\n   - Use Playwright MCP to navigate to the failing page\n   - Capture current accessibility tree\n   - Classify: TEST bug (selector changed, timing issue) or CODE bug (regression)\n   - If TEST bug: auto-fix the spec, re-run, update manifest\n   - If CODE bug: present diagnosis and fix options via AskUserQuestion\n\n4. **`maintain`** — Delegate to `/browsertest:maintain` command\n\n5. **`report`** — Read `apps/e2e/manifest.json` and display formatted health dashboard\n\n6. **No recognized subcommand** — Treat as a feature search. Look in `apps/e2e/manifest.json` for a matching test. If found, run it. If not found, offer to create it.\n\n### Report Dashboard Format\n\nWhen `/browsertest report` is invoked, display:\n\n```\nBrowser Test Health Dashboard\n==============================\n\nSuite Status: <N> tests | <N> passing | <N> failing | <N>% pass rate\nLast Run: <timestamp> (<duration>)\n\nFeature Breakdown:\n  <feature>: <passed>/<total> passing (<percent>%)\n  ...\n\nRecent History (last 5 runs):\n  #<N>: <passed>/<total> passed (<duration>)\n  ...\n\nStale Tests (code changed since last update):\n  - <test>.spec.ts (<file> modified <N>d ago)\n  ...\n\nRun: /browsertest maintain  to update stale tests\n```\n\n## Acceptance Criteria\n\n- `.claude/commands/browsertest.md` exists with correct frontmatter\n- The command handles all six routing patterns (run, create, debug, maintain, report, no-subcommand)\n- The `run` subcommand executes `npx playwright test` from `apps/e2e/`\n- The `report` subcommand reads and formats `manifest.json` data\n- The `create` subcommand instructions reference Playwright MCP for snapshot-driven test creation\n- The `debug` subcommand instructions include the classify-then-fix methodology\n- The command uses `$ARGUMENTS` for argument parsing\n- Allowed tools include all necessary tools (Read, Write, Edit, Grep, Glob, Bash, Task, TaskOutput, AskUserQuestion)",
      "activeForm": "Creating /browsertest command with smart routing",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.6"],
      "parallelWith": ["2.2"]
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "AI Commands",
      "subject": "[browser-testing-system] [P2] Create browser-testing skill",
      "description": "Create the `.claude/skills/browser-testing/SKILL.md` that teaches Claude Code the methodology for writing and maintaining DorkOS browser tests.\n\n## File: `.claude/skills/browser-testing/SKILL.md`\n\n### Frontmatter\n\n```yaml\n---\nname: browser-testing\ndescription: Methodology for writing and maintaining DorkOS browser tests\n---\n```\n\n### Skill Content\n\nThe skill must teach the following topics with concrete examples:\n\n#### 1. When to Write a Browser Test vs Unit Test\n\n- **Browser test**: Cross-component flows (sidebar click updates chat panel), SSE streaming verification, real API calls through the full stack, CSS/layout regressions, browser-specific behavior\n- **Unit test (Vitest)**: Individual component rendering, hook logic, service functions, schema validation, pure utility functions\n- **Rule of thumb**: If the behavior spans multiple FSD layers or requires a real server, it's a browser test\n\n#### 2. Page Object Model Patterns\n\n- POMs live in `apps/e2e/pages/` and are injected as Playwright fixtures via `fixtures/index.ts`\n- Each POM encapsulates locators and interaction methods for one page or component\n- Test files import `test` and `expect` from `../../fixtures`, never from `@playwright/test` directly\n- Example POM structure showing constructor with locators and async methods\n\n#### 3. Selector Strategy\n\nPriority order:\n1. `getByRole()` — Best: semantic, resilient to UI changes. Example: `page.getByRole('button', { name: /send/i })`\n2. `data-testid` — Good: stable contract between test and implementation. Example: `page.locator('[data-testid=\"chat-panel\"]')`\n3. CSS class — Last resort: fragile, breaks on styling changes. Avoid unless no other option.\n\n#### 4. Wait Strategy\n\n- NEVER use `page.waitForTimeout()` or `setTimeout`\n- Use locator state waits: `.waitFor({ state: 'visible' })`, `.waitFor({ state: 'hidden' })`\n- For streaming responses: wait for inference indicator to appear then disappear\n- For navigation: use `page.waitForURL()` or `expect(page).toHaveURL()`\n- For API calls: use `page.waitForResponse()` to intercept specific endpoints\n\n#### 5. Test Tagging\n\n- `@smoke` — Critical path tests, no SDK dependency, fast (<5s). Run with `--grep @smoke`\n- `@integration` — SDK-dependent tests, require ANTHROPIC_API_KEY, slower (10-60s). Run with `--grep @integration`\n- Add tags to `test.describe()` titles: `test.describe('Feature — Description @smoke', ...)`\n\n#### 6. Debugging Methodology\n\n1. Reproduce: Run the failing test with `PWDEBUG=1` or `--trace on`\n2. Snapshot: Use Playwright MCP `browser_snapshot` to capture the current accessibility tree\n3. Compare: Check if the expected elements still exist with the expected attributes\n4. Classify: Is it a TEST bug (selector changed, timing issue) or CODE bug (regression)?\n5. Fix: If test bug, update the POM/spec. If code bug, fix the source.\n\n#### 7. Manifest Management\n\n- `apps/e2e/manifest.json` is automatically updated by the custom reporter after each run\n- Test entries are keyed by spec filename (e.g., `send-message`)\n- Feature is derived from the first directory in the test path\n- Run history is capped at 100 entries\n- The `/browsertest report` command reads this file for health dashboards\n\n#### 8. DorkOS-Specific Patterns\n\n- **SSE stream testing**: The app uses Server-Sent Events for real-time updates. Test by sending a message and waiting for the inference indicator lifecycle (visible -> hidden)\n- **Session URL state**: Sessions are tracked via `?session=` URL parameter. After creating a new session, verify the URL updates\n- **Multi-panel layout**: The app has a sidebar + main panel layout. Some interactions affect both panels (e.g., clicking a session in sidebar updates chat panel)\n- **Settings dialog**: Opens as a modal overlay. Use Escape key or click-outside to close\n\n## Acceptance Criteria\n\n- `.claude/skills/browser-testing/SKILL.md` exists with correct frontmatter\n- All 8 teaching topics are covered with concrete examples\n- Examples reference actual DorkOS file paths and component names\n- Selector strategy priority is clearly ranked (getByRole > data-testid > CSS)\n- Wait strategy explicitly forbids arbitrary timeouts\n- DorkOS-specific patterns section covers SSE, URL state, layout, and settings",
      "activeForm": "Creating browser-testing skill",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["1.6"],
      "parallelWith": ["2.1"]
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Self-Maintenance",
      "subject": "[browser-testing-system] [P3] Create /browsertest:maintain command",
      "description": "Create the `/browsertest:maintain` command that audits browser test suite health, detects stale and orphaned tests, and auto-updates broken tests.\n\n## File: `.claude/commands/browsertest:maintain.md`\n\n### Frontmatter\n\n```yaml\n---\ndescription: Audit browser test suite health and fix stale tests\nallowed-tools: Read, Write, Edit, Grep, Glob, Bash, Task, TaskOutput, AskUserQuestion\nargument-hint: ''\ncategory: testing\n---\n```\n\n### Command Body — Maintenance Flow\n\nThe command should implement this maintenance workflow:\n\n#### Step 1: Read Manifest\nRead `apps/e2e/manifest.json` to get the list of all tracked tests.\n\n#### Step 2: Audit Each Test\nFor each test entry in the manifest:\n1. Check if the spec file still exists on disk (glob for the specFile path)\n2. Check if `relatedCode` files were modified since the test's `lastRun` date (use `git log --since=\"<lastRun>\" -- <relatedCode paths>` to detect changes)\n3. Run the individual test: `cd apps/e2e && npx playwright test <specFile> --reporter=json`\n\n#### Step 3: Categorize Results\nClassify each test into one of four categories:\n- **Healthy** — Test passes AND related code unchanged since last run\n- **Stale** — Test passes BUT related code was modified since last run (test may need updating to reflect new behavior)\n- **Broken** — Test fails (selector changed, timing issue, or code regression)\n- **Orphaned** — Spec file still exists but related source code files have been deleted\n\n#### Step 4: Auto-Fix Stale Tests\nFor stale tests:\n1. Use Playwright MCP `browser_navigate` to visit the feature in the running app\n2. Use `browser_snapshot` to capture the current accessibility tree\n3. Compare current selectors/structure with what the test expects\n4. Update POM locators or test assertions if they've drifted\n5. Re-run the test to verify the update works\n\n#### Step 5: Handle Orphaned Tests\nFor orphaned tests:\n1. Present the list of orphaned tests to the user via output\n2. Ask the user to confirm removal using AskUserQuestion\n3. If confirmed, delete the spec file and remove the entry from manifest.json\n\n#### Step 6: Handle Broken Tests\nFor broken tests:\n1. Run with `--reporter=json` to capture error details\n2. Use Playwright MCP to inspect the page state\n3. Classify: TEST bug or CODE bug (same methodology as `/browsertest debug`)\n4. If TEST bug: auto-fix and re-run\n5. If CODE bug: report to user with diagnosis\n\n#### Step 7: Update Manifest and Report\nUpdate manifest.json with audit results and display a summary:\n\n```\nBrowser Test Audit Results\n===========================\n\nHealthy: <N> tests\nStale (updated): <N> tests\nBroken (fixed): <N> tests\nBroken (code bug): <N> tests\nOrphaned (removed): <N> tests\n\nDetails:\n  [OK] smoke/app-loads.spec.ts — healthy\n  [UPDATED] chat/send-message.spec.ts — stale, updated selectors\n  [BUG] session-list/session-management.spec.ts — code regression in SessionSidebar\n  ...\n```\n\n## Acceptance Criteria\n\n- `.claude/commands/browsertest:maintain.md` exists with correct frontmatter\n- The command implements all 7 steps of the maintenance flow\n- Stale detection uses `git log --since` to compare code modification dates\n- Orphan detection checks if related source files exist on disk\n- The command uses AskUserQuestion before deleting any test files\n- Auto-fix flow uses Playwright MCP for snapshot-driven selector updates\n- Final report categorizes all tests and shows per-test status",
      "activeForm": "Creating /browsertest:maintain command",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["2.1"],
      "parallelWith": []
    },
    {
      "id": "4.1",
      "phase": 4,
      "phaseName": "Polish",
      "subject": "[browser-testing-system] [P4] Add relatedCode tracking and coverage mapping to manifest",
      "description": "Enhance the manifest.json schema to support `relatedCode` tracking per test entry and feature-level coverage mapping.\n\n## Changes\n\n### 1. Extend TestEntry interface in manifest-reporter.ts\n\nAdd a `relatedCode` field to the `TestEntry` interface:\n\n```typescript\ninterface TestEntry {\n  specFile: string;\n  feature: string;\n  description: string;\n  lastRun: string;\n  lastStatus: string;\n  runCount: number;\n  passCount: number;\n  failCount: number;\n  relatedCode: string[];  // NEW: source files this test covers\n  lastModified: string;   // NEW: last time the spec file was modified\n}\n```\n\nThe `relatedCode` array contains relative paths to source files that this test exercises. For example, the `send-message` test would have:\n```json\n\"relatedCode\": [\n  \"apps/client/src/layers/features/chat/ui/ChatPanel.tsx\",\n  \"apps/client/src/layers/features/chat/ui/MessageList.tsx\",\n  \"apps/client/src/layers/features/chat/ui/MessageItem.tsx\",\n  \"apps/client/src/layers/features/chat/ui/InferenceIndicator.tsx\"\n]\n```\n\nThe `lastModified` field records when the spec file itself was last changed (via `git log -1 --format=%cI -- <specFile>`).\n\n### 2. Update manifest-reporter.ts\n\nModify the reporter to preserve `relatedCode` and `lastModified` fields when updating test entries. These fields are populated by the `/browsertest create` and `/browsertest:maintain` commands, not by the reporter itself. The reporter should:\n- Preserve existing `relatedCode` arrays when updating entries\n- Preserve existing `lastModified` when updating entries\n- Default to `[]` for relatedCode and `''` for lastModified on new entries\n\n### 3. Add coverage mapping section to manifest\n\nAdd a top-level `coverage` field to the manifest:\n\n```typescript\ninterface Manifest {\n  version: number;\n  tests: Record<string, TestEntry>;\n  runHistory: Array<{ ... }>;\n  coverage: {                    // NEW\n    lastUpdated: string;\n    features: Record<string, {\n      testCount: number;\n      sourceFiles: number;\n      coveredFiles: number;\n      percentage: number;\n    }>;\n  };\n}\n```\n\nThe coverage section is populated by the `/browsertest report` command (or `/browsertest:maintain`), not by the reporter. It maps FSD features to their test coverage:\n- `testCount` — number of spec files for this feature\n- `sourceFiles` — total source files in the feature directory (from `apps/client/src/layers/features/<name>/`)\n- `coveredFiles` — source files referenced in at least one test's `relatedCode`\n- `percentage` — `coveredFiles / sourceFiles * 100`\n\n### 4. Update seed test entries in manifest.json\n\nAdd `relatedCode` to the initial manifest for the four seed tests:\n\n- `app-loads`: `[\"apps/client/src/App.tsx\"]`\n- `send-message`: `[\"apps/client/src/layers/features/chat/ui/ChatPanel.tsx\", \"apps/client/src/layers/features/chat/ui/MessageList.tsx\", \"apps/client/src/layers/features/chat/ui/MessageItem.tsx\", \"apps/client/src/layers/features/chat/ui/InferenceIndicator.tsx\"]`\n- `session-management`: `[\"apps/client/src/layers/features/session-list/ui/SessionSidebar.tsx\", \"apps/client/src/layers/features/session-list/ui/SessionItem.tsx\"]`\n- `settings-dialog`: `[\"apps/client/src/layers/features/settings/ui/SettingsDialog.tsx\"]`\n\n## Acceptance Criteria\n\n- `TestEntry` interface includes `relatedCode: string[]` and `lastModified: string`\n- Reporter preserves `relatedCode` and `lastModified` when updating entries\n- New entries default to `relatedCode: []` and `lastModified: ''`\n- `Manifest` interface includes optional `coverage` object\n- Seed test entries in manifest.json include their `relatedCode` arrays\n- The `/browsertest report` command instructions are updated to show coverage data when available",
      "activeForm": "Adding relatedCode tracking and coverage mapping to manifest",
      "size": "medium",
      "priority": "low",
      "dependencies": ["1.5", "1.6", "3.1"],
      "parallelWith": []
    }
  ]
}
