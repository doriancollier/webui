{
  "spec": "specs/relay-runtime-adapters/02-specification.md",
  "slug": "relay-runtime-adapters",
  "generatedAt": "2026-02-25T22:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Interface Extension & Adapter Refactor",
      "subject": "relay-runtime-adapters [P1] Add AdapterContext and DeliveryResult types to relay types",
      "description": "Add two new interfaces to `packages/relay/src/types.ts` and update the existing `RelayAdapter` and `AdapterRegistryLike` interfaces.\n\n## New Types\n\nAdd these interfaces after the existing `AdapterStatus` interface (around line 262):\n\n```typescript\n/**\n * Rich context passed to adapter deliver() for informed dispatch decisions.\n *\n * Contains optional agent info (from Mesh registry or envelope metadata),\n * optional platform info (for external adapters), and trace context.\n */\nexport interface AdapterContext {\n  /** Agent info — populated from Mesh registry, envelope metadata, or static config */\n  agent?: {\n    /** Working directory for the agent (absolute path) */\n    directory: string;\n    /** Runtime type (e.g., 'claude-code', 'codex', 'open-code') */\n    runtime: string;\n    /** Agent manifest from Mesh registry (if available) */\n    manifest?: Record<string, unknown>;\n  };\n  /** Platform info — for external adapters */\n  platform?: {\n    /** Platform name (e.g., 'telegram', 'slack', 'discord') */\n    name: string;\n    /** Platform-specific metadata */\n    metadata?: Record<string, unknown>;\n  };\n  /** Trace context for delivery tracking */\n  trace?: {\n    traceId: string;\n    spanId: string;\n    parentSpanId?: string;\n  };\n}\n\n/**\n * Result of an adapter delivery attempt.\n *\n * Adapters return this from deliver() to indicate success, failure, or\n * dead-letter disposition.\n */\nexport interface DeliveryResult {\n  success: boolean;\n  /** Error message if delivery failed */\n  error?: string;\n  /** Whether a dead letter was created for this failure */\n  deadLettered?: boolean;\n  /** Response message ID if the adapter published a reply */\n  responseMessageId?: string;\n  /** Delivery duration in milliseconds */\n  durationMs?: number;\n}\n```\n\n## Update RelayAdapter Interface\n\nChange the `deliver()` signature from:\n```typescript\ndeliver(subject: string, envelope: RelayEnvelope): Promise<void>;\n```\nTo:\n```typescript\ndeliver(subject: string, envelope: RelayEnvelope, context?: AdapterContext): Promise<DeliveryResult>;\n```\n\n## Update AdapterRegistryLike Interface\n\nChange the `deliver()` signature from:\n```typescript\ndeliver(subject: string, envelope: RelayEnvelope): Promise<boolean>;\n```\nTo:\n```typescript\ndeliver(subject: string, envelope: RelayEnvelope, context?: AdapterContext): Promise<boolean>;\n```\n\n## Update AdapterConfig Type\n\nChange the `AdapterConfig` interface `type` field from:\n```typescript\ntype: 'telegram' | 'webhook';\n```\nTo:\n```typescript\ntype: 'telegram' | 'webhook' | 'claude-code' | 'plugin';\n```\n\nChange the `config` field from:\n```typescript\nconfig: TelegramAdapterConfig | WebhookAdapterConfig;\n```\nTo:\n```typescript\nconfig: TelegramAdapterConfig | WebhookAdapterConfig | Record<string, unknown>;\n```\n\nAdd a new optional `builtin` field:\n```typescript\n/** Built-in adapter flag — when true, adapter is loaded from @dorkos/relay */\nbuiltin?: boolean;\n```\n\nAdd a new optional `plugin` field:\n```typescript\n/** Plugin source — required when type is 'plugin' */\nplugin?: { package?: string; path?: string };\n```\n\n## Update AdapterRegistry.deliver()\n\nIn `packages/relay/src/adapter-registry.ts`, update the `deliver()` method to accept and pass through the `context` parameter:\n\n```typescript\nasync deliver(subject: string, envelope: RelayEnvelope, context?: AdapterContext): Promise<boolean> {\n  const adapter = this.getBySubject(subject);\n  if (!adapter) return false;\n  await adapter.deliver(subject, envelope, context);\n  return true;\n}\n```\n\nAdd the import for `AdapterContext` from `./types.js`.\n\n## Acceptance Criteria\n\n- `AdapterContext` and `DeliveryResult` interfaces exist in `packages/relay/src/types.ts`\n- `RelayAdapter.deliver()` accepts optional `AdapterContext` and returns `Promise<DeliveryResult>`\n- `AdapterRegistryLike.deliver()` accepts optional `AdapterContext`\n- `AdapterRegistry.deliver()` passes `context` through to the matched adapter\n- `AdapterConfig.type` includes `'claude-code'` and `'plugin'` as valid values\n- All existing tests still compile and pass (no behavioral changes yet)\n- TypeScript compiles without errors across all packages",
      "activeForm": "Adding AdapterContext and DeliveryResult types to relay types",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.2"]
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Interface Extension & Adapter Refactor",
      "subject": "relay-runtime-adapters [P1] Extend Zod adapter config schemas in relay-schemas",
      "description": "Extend the adapter configuration Zod schemas in `packages/shared/src/relay-schemas.ts` to support the new `claude-code` and `plugin` adapter types.\n\n## Changes to AdapterTypeSchema\n\nReplace the existing `AdapterTypeSchema` (line 232):\n```typescript\nexport const AdapterTypeSchema = z.enum(['telegram', 'webhook']).openapi('AdapterType');\n```\nWith:\n```typescript\nexport const AdapterTypeSchema = z\n  .enum(['telegram', 'webhook', 'claude-code', 'plugin'])\n  .openapi('AdapterType');\n```\n\n## Add PluginSourceSchema\n\nAdd a new schema after `AdapterTypeSchema`:\n```typescript\nexport const PluginSourceSchema = z\n  .object({\n    /** npm package name (e.g., 'dorkos-relay-slack') */\n    package: z.string().optional(),\n    /** Local file path (absolute or relative to config dir) */\n    path: z.string().optional(),\n  })\n  .refine(\n    (data) => data.package || data.path,\n    { message: 'Plugin source must specify either package or path' },\n  )\n  .openapi('PluginSource');\n\nexport type PluginSource = z.infer<typeof PluginSourceSchema>;\n```\n\n## Update AdapterConfigSchema\n\nReplace the existing `AdapterConfigSchema` (lines 276-287):\n```typescript\nexport const AdapterConfigSchema = z\n  .object({\n    id: z\n      .string()\n      .min(1)\n      .regex(/^[a-z0-9-]+$/, 'Must be lowercase alphanumeric with hyphens'),\n    type: AdapterTypeSchema,\n    enabled: z.boolean().default(true),\n    config: z.union([TelegramAdapterConfigSchema, WebhookAdapterConfigSchema]),\n  })\n  .openapi('AdapterConfig');\n```\nWith:\n```typescript\nexport const AdapterConfigSchema = z\n  .object({\n    id: z\n      .string()\n      .min(1)\n      .regex(/^[a-z0-9-]+$/, 'Must be lowercase alphanumeric with hyphens'),\n    type: AdapterTypeSchema,\n    enabled: z.boolean().default(true),\n    /** Built-in adapter flag — when true, adapter is loaded from @dorkos/relay */\n    builtin: z.boolean().optional(),\n    /** Plugin source — required when type is 'plugin' */\n    plugin: PluginSourceSchema.optional(),\n    /** Adapter-specific configuration (passed to adapter constructor/factory) */\n    config: z.union([\n      TelegramAdapterConfigSchema,\n      WebhookAdapterConfigSchema,\n      z.record(z.unknown()),\n    ]),\n  })\n  .openapi('AdapterConfig');\n```\n\n## Update AdapterStatusSchema\n\nUpdate the `type` field in `AdapterStatusSchema` (line 293) to use the updated `AdapterTypeSchema`:\n```typescript\ntype: AdapterTypeSchema,\n```\n(This should already work since it references `AdapterTypeSchema`, but verify it compiles.)\n\n## Acceptance Criteria\n\n- `AdapterTypeSchema` accepts `'claude-code'` and `'plugin'` as valid values\n- `PluginSourceSchema` validates that at least one of `package` or `path` is provided\n- `AdapterConfigSchema` includes optional `builtin` and `plugin` fields\n- `AdapterConfigSchema.config` accepts `Record<string, unknown>` in addition to Telegram and webhook configs\n- All existing tests still pass — the old config shapes remain valid\n- TypeScript compiles without errors",
      "activeForm": "Extending Zod adapter config schemas in relay-schemas",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1"]
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Interface Extension & Adapter Refactor",
      "subject": "relay-runtime-adapters [P1] Refactor Telegram and webhook adapters for new deliver() signature",
      "description": "Update the existing `TelegramAdapter` and `WebhookAdapter` to conform to the new `deliver()` signature that accepts optional `AdapterContext` and returns `DeliveryResult`.\n\n## TelegramAdapter Changes\n\nFile: `packages/relay/src/adapters/telegram-adapter.ts`\n\n1. Add import for `AdapterContext` and `DeliveryResult` from `../types.js`\n2. Change the `deliver()` method signature from:\n```typescript\nasync deliver(subject: string, envelope: RelayEnvelope): Promise<void> {\n```\nTo:\n```typescript\nasync deliver(subject: string, envelope: RelayEnvelope, _context?: AdapterContext): Promise<DeliveryResult> {\n```\n\n3. Wrap the existing method body to return a `DeliveryResult`. At the start of the method, capture `startTime`:\n```typescript\nconst startTime = Date.now();\n```\n\n4. Wrap the existing logic in a try/catch. On success, return:\n```typescript\nreturn {\n  success: true,\n  durationMs: Date.now() - startTime,\n};\n```\n\n5. On error, return:\n```typescript\nreturn {\n  success: false,\n  error: err instanceof Error ? err.message : String(err),\n  durationMs: Date.now() - startTime,\n};\n```\n\nThe existing error handling that increments `this.status.errorCount` and sets `this.status.lastError` should remain, but instead of throwing, the adapter now returns a structured result.\n\n## WebhookAdapter Changes\n\nFile: `packages/relay/src/adapters/webhook-adapter.ts`\n\n1. Add import for `AdapterContext` and `DeliveryResult` from `../types.js`\n2. Change the `deliver()` method signature from:\n```typescript\nasync deliver(_subject: string, envelope: RelayEnvelope): Promise<void> {\n```\nTo:\n```typescript\nasync deliver(_subject: string, envelope: RelayEnvelope, _context?: AdapterContext): Promise<DeliveryResult> {\n```\n\n3. Same pattern as Telegram — capture `startTime`, wrap in try/catch, return `DeliveryResult` on success or failure.\n\nThe webhook adapter currently throws on non-2xx responses. Instead of throwing, return `{ success: false, error: ... }`. The throw behavior should be converted to a return.\n\n## Update Existing Tests\n\nUpdate the existing adapter tests to verify the new return type:\n- `deliver()` returns `{ success: true, durationMs: number }` on success\n- `deliver()` returns `{ success: false, error: string }` on failure (instead of throwing)\n- The `_context` parameter is accepted but ignored by these adapters\n\n## Acceptance Criteria\n\n- `TelegramAdapter.deliver()` accepts optional `AdapterContext` and returns `Promise<DeliveryResult>`\n- `WebhookAdapter.deliver()` accepts optional `AdapterContext` and returns `Promise<DeliveryResult>`\n- Neither adapter uses the `context` parameter (prefixed with `_` to indicate unused)\n- Both adapters return `{ success: true, durationMs }` on successful delivery\n- Both adapters return `{ success: false, error }` on failure (no longer throw from `deliver()`)\n- All existing adapter tests pass with updated assertions\n- TypeScript compiles without errors across all packages",
      "activeForm": "Refactoring Telegram and webhook adapters for new deliver signature",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": ["1.4"]
    },
    {
      "id": "1.4",
      "phase": 1,
      "phaseName": "Interface Extension & Adapter Refactor",
      "subject": "relay-runtime-adapters [P1] Export new types from relay package index",
      "description": "Update `packages/relay/src/index.ts` to export the new `AdapterContext` and `DeliveryResult` types so third-party adapter packages can import them.\n\n## Changes to index.ts\n\nIn the \"Adapter types\" export section (lines 85-94), add `AdapterContext` and `DeliveryResult` to the type exports:\n\n```typescript\n// Adapter types\nexport type {\n  RelayPublisher,\n  RelayAdapter,\n  AdapterStatus,\n  AdapterConfig,\n  AdapterContext,\n  DeliveryResult,\n  TelegramAdapterConfig,\n  WebhookAdapterConfig,\n  AdapterRegistryLike,\n  PublishResultLike,\n} from './types.js';\n```\n\nThis enables third-party adapter authors to import the types:\n```typescript\nimport type { RelayAdapter, AdapterContext, DeliveryResult } from '@dorkos/relay';\n```\n\n## Acceptance Criteria\n\n- `AdapterContext` is exported as a type from `@dorkos/relay`\n- `DeliveryResult` is exported as a type from `@dorkos/relay`\n- Existing exports are unchanged\n- A consumer can write `import type { AdapterContext, DeliveryResult } from '@dorkos/relay'` without errors",
      "activeForm": "Exporting new types from relay package index",
      "size": "small",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": ["1.3"]
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "Plugin Loader",
      "subject": "relay-runtime-adapters [P2] Implement adapter plugin loader",
      "description": "Create `packages/relay/src/adapter-plugin-loader.ts` that dynamically loads adapter instances from configuration entries. The plugin loader handles three sources: built-in adapters, npm packages, and local file paths.\n\n## File: `packages/relay/src/adapter-plugin-loader.ts`\n\n```typescript\n/**\n * Dynamic adapter plugin loader.\n *\n * Loads RelayAdapter instances from three sources:\n * 1. Built-in adapters (from a provided factory map)\n * 2. npm packages (via dynamic import)\n * 3. Local file paths (via dynamic import with pathToFileURL)\n *\n * Loading errors are non-fatal — logs a warning and skips the failing adapter.\n *\n * @module relay/adapter-plugin-loader\n */\nimport { pathToFileURL } from 'node:url';\nimport { resolve, isAbsolute } from 'node:path';\nimport type { RelayAdapter } from './types.js';\n\n/** Configuration entry for a single adapter to load. */\nexport interface PluginAdapterConfig {\n  id: string;\n  type: string;\n  enabled?: boolean;\n  builtin?: boolean;\n  plugin?: { package?: string; path?: string };\n  config: Record<string, unknown>;\n}\n\n/** Expected module shape from a plugin package. */\nexport interface AdapterPluginModule {\n  default: (config: Record<string, unknown>) => RelayAdapter;\n}\n\n/**\n * Load adapter instances from config entries.\n *\n * Handles three sources:\n * 1. builtin: true — imported from built-in adapter map\n * 2. plugin.package — dynamic import(packageName)\n * 3. plugin.path — dynamic import(pathToFileURL(absolutePath))\n *\n * Loading errors are non-fatal — logs and skips.\n *\n * @param configs - Array of adapter configuration entries\n * @param builtinMap - Map of type string to factory function for built-in adapters\n * @param configDir - Base directory for resolving relative plugin paths\n * @returns Array of successfully loaded adapter instances\n */\nexport async function loadAdapters(\n  configs: PluginAdapterConfig[],\n  builtinMap: Map<string, (config: Record<string, unknown>) => RelayAdapter>,\n  configDir: string,\n): Promise<RelayAdapter[]> {\n  const adapters: RelayAdapter[] = [];\n\n  for (const entry of configs) {\n    if (entry.enabled === false) continue;\n\n    try {\n      let adapter: RelayAdapter | null = null;\n\n      if (entry.builtin && builtinMap.has(entry.type)) {\n        // Built-in adapter\n        const factory = builtinMap.get(entry.type)!;\n        adapter = factory(entry.config);\n      } else if (entry.plugin?.package) {\n        // npm package\n        const mod = (await import(entry.plugin.package)) as AdapterPluginModule;\n        adapter = validateAndCreate(mod, entry);\n      } else if (entry.plugin?.path) {\n        // Local file\n        const absPath = isAbsolute(entry.plugin.path)\n          ? entry.plugin.path\n          : resolve(configDir, entry.plugin.path);\n        const mod = (await import(\n          pathToFileURL(absPath).href\n        )) as AdapterPluginModule;\n        adapter = validateAndCreate(mod, entry);\n      }\n\n      if (adapter) {\n        adapters.push(adapter);\n      }\n    } catch (err) {\n      // Non-fatal: log and continue\n      console.warn(`[PluginLoader] Failed to load adapter '${entry.id}':`, err);\n    }\n  }\n\n  return adapters;\n}\n\n/**\n * Duck-type validate and create adapter from a loaded module.\n *\n * @param mod - The dynamically imported module\n * @param entry - The config entry for error reporting\n * @returns A validated RelayAdapter instance\n * @throws If the module doesn't export a default factory function\n */\nfunction validateAndCreate(\n  mod: unknown,\n  entry: PluginAdapterConfig,\n): RelayAdapter {\n  const m = mod as Record<string, unknown>;\n  if (typeof m.default !== 'function') {\n    throw new Error(\n      `Module for '${entry.id}' does not export a default factory function`,\n    );\n  }\n  const factory = m.default as (config: Record<string, unknown>) => RelayAdapter;\n  const adapter = factory(entry.config);\n  validateAdapterShape(adapter, entry.id);\n  return adapter;\n}\n\n/**\n * Validate that an object implements the RelayAdapter interface shape.\n *\n * Uses duck-type checking to verify required properties and methods\n * exist without relying on TypeScript's structural typing at runtime.\n *\n * @param obj - The object to validate\n * @param id - The adapter ID for error messages\n * @throws If the object is missing required RelayAdapter members\n */\nexport function validateAdapterShape(\n  obj: unknown,\n  id: string,\n): asserts obj is RelayAdapter {\n  const a = obj as Record<string, unknown>;\n  if (typeof a.id !== 'string')\n    throw new Error(`Adapter '${id}': missing 'id' property`);\n  if (typeof a.subjectPrefix !== 'string')\n    throw new Error(`Adapter '${id}': missing 'subjectPrefix'`);\n  if (typeof a.displayName !== 'string')\n    throw new Error(`Adapter '${id}': missing 'displayName'`);\n  if (typeof a.start !== 'function')\n    throw new Error(`Adapter '${id}': missing 'start()' method`);\n  if (typeof a.stop !== 'function')\n    throw new Error(`Adapter '${id}': missing 'stop()' method`);\n  if (typeof a.deliver !== 'function')\n    throw new Error(`Adapter '${id}': missing 'deliver()' method`);\n  if (typeof a.getStatus !== 'function')\n    throw new Error(`Adapter '${id}': missing 'getStatus()' method`);\n}\n```\n\n## Export from index.ts\n\nAdd to `packages/relay/src/index.ts`:\n```typescript\n// Plugin loader\nexport { loadAdapters, validateAdapterShape } from './adapter-plugin-loader.js';\nexport type {\n  PluginAdapterConfig,\n  AdapterPluginModule,\n} from './adapter-plugin-loader.js';\n```\n\n## Tests: `packages/relay/src/__tests__/adapter-plugin-loader.test.ts`\n\nWrite comprehensive tests covering:\n\n1. **Loads built-in adapters from provided map** — Create a mock builtinMap with a factory that returns a mock RelayAdapter. Call `loadAdapters()` with a config entry `{ id: 'test', type: 'test-type', builtin: true, config: {} }`. Assert the returned array has length 1 and the adapter's `id` matches.\n\n2. **Loads plugin from npm package name** — Use `vi.mock()` to mock a dynamic `import()` of a package name. The mock module exports a default factory function that returns a mock RelayAdapter. Assert the adapter is loaded and has the correct properties.\n\n3. **Loads plugin from local file path** — Mock dynamic `import()` with a `pathToFileURL`-based URL. The config entry has `plugin: { path: '/absolute/path/to/adapter.js' }`. Assert the adapter is loaded.\n\n4. **Resolves relative paths against config directory** — Config entry has `plugin: { path: './adapters/my-adapter.js' }`, configDir is `/home/user/.dork/relay`. Assert the import is called with `pathToFileURL('/home/user/.dork/relay/adapters/my-adapter.js').href`.\n\n5. **Duck-type validates loaded module has required methods** — Create a mock module that returns an object missing `deliver()`. Assert `loadAdapters()` logs a warning and returns an empty array (non-fatal).\n\n6. **Returns empty for modules without default export** — Mock module has no `default` export. Assert non-fatal skip.\n\n7. **Skips disabled entries** — Config entry has `enabled: false`. Assert it's not loaded.\n\n8. **Continues loading after individual failures** — First of three config entries fails to load. Assert the other two are still loaded.\n\n9. **validateAdapterShape throws for missing properties** — Test each required property individually.\n\n## Acceptance Criteria\n\n- `loadAdapters()` loads from built-in map, npm packages, and local file paths\n- Disabled entries (`enabled: false`) are skipped\n- Loading errors are non-fatal (logged as warnings, not thrown)\n- `validateAdapterShape()` checks for `id`, `subjectPrefix`, `displayName`, `start`, `stop`, `deliver`, `getStatus`\n- Relative paths are resolved against `configDir`\n- All tests pass\n- Exported from `@dorkos/relay`",
      "activeForm": "Implementing adapter plugin loader",
      "size": "large",
      "priority": "high",
      "dependencies": ["1.1", "1.4"],
      "parallelWith": []
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Claude Code Adapter",
      "subject": "relay-runtime-adapters [P3] Implement ClaudeCodeAdapter",
      "description": "Create `packages/relay/src/adapters/claude-code-adapter.ts` — the built-in adapter that bridges Relay messages to Agent SDK sessions. This adapter handles `relay.agent.>` and `relay.system.pulse.>` subjects and fully replaces the `MessageReceiver` class.\n\n## Dependency Interfaces\n\nDefine these minimal interfaces at the top of the file for dependency injection (matching existing patterns from `message-receiver.ts`):\n\n```typescript\nimport { randomUUID } from 'node:crypto';\nimport type { RelayEnvelope, TraceSpan } from '@dorkos/shared/relay-schemas';\nimport { PulseDispatchPayloadSchema } from '@dorkos/shared/relay-schemas';\nimport type { StreamEvent } from '@dorkos/shared/types';\nimport type {\n  RelayAdapter,\n  RelayPublisher,\n  AdapterStatus,\n  AdapterContext,\n  DeliveryResult,\n  PublishOptions,\n} from '../types.js';\n\n/** Maximum characters to collect for run output summary. */\nconst OUTPUT_SUMMARY_MAX_CHARS = 1000;\n\n/** Subject prefix for agent-bound messages. */\nconst AGENT_SUBJECT_PREFIX = 'relay.agent.';\n\n/** Subject prefix for Pulse dispatch messages. */\nconst PULSE_SUBJECT_PREFIX = 'relay.system.pulse.';\n\n/** Configuration for the ClaudeCodeAdapter. */\nexport interface ClaudeCodeAdapterConfig {\n  /** Maximum concurrent agent sessions. Default: 3 */\n  maxConcurrent?: number;\n  /** Default session timeout in ms (used when envelope has no TTL). Default: 300000 (5 min) */\n  defaultTimeoutMs?: number;\n  /** Default working directory for agents without explicit directory */\n  defaultCwd?: string;\n}\n\n/**\n * Minimal interface for agent session management.\n *\n * Matches the existing AgentManagerLike from message-receiver.ts.\n */\nexport interface AgentManagerLike {\n  ensureSession(\n    sessionId: string,\n    opts: { permissionMode: string; cwd?: string; hasStarted?: boolean },\n  ): void;\n  sendMessage(\n    sessionId: string,\n    content: string,\n    opts?: { permissionMode?: string; cwd?: string },\n  ): AsyncGenerator<StreamEvent>;\n}\n\n/** Minimal TraceStore interface for dependency injection. */\nexport interface TraceStoreLike {\n  insertSpan(span: TraceSpan): void;\n  updateSpan(messageId: string, update: Partial<TraceSpan>): void;\n}\n\n/** Minimal PulseStore interface for Pulse run lifecycle updates. */\nexport interface PulseStoreLike {\n  updateRun(runId: string, update: Record<string, unknown>): void;\n}\n\n/** Dependencies injected into ClaudeCodeAdapter. */\nexport interface ClaudeCodeAdapterDeps {\n  agentManager: AgentManagerLike;\n  traceStore: TraceStoreLike;\n  pulseStore?: PulseStoreLike;\n}\n```\n\n## ClaudeCodeAdapter Class\n\n```typescript\n/**\n * Runtime adapter that bridges Relay messages to Claude Code Agent SDK sessions.\n *\n * Handles two subject patterns:\n * - `relay.agent.>` — agent-directed messages\n * - `relay.system.pulse.>` — Pulse scheduler dispatch\n *\n * Replaces the temporary MessageReceiver bridge with a unified adapter\n * that plugs into the AdapterRegistry alongside Telegram and webhook adapters.\n */\nexport class ClaudeCodeAdapter implements RelayAdapter {\n  readonly id: string;\n  readonly subjectPrefix = 'relay.agent.';\n  readonly displayName = 'Claude Code';\n\n  private readonly config: Required<ClaudeCodeAdapterConfig>;\n  private readonly deps: ClaudeCodeAdapterDeps;\n  private relay: RelayPublisher | null = null;\n  private activeCount = 0;\n  private status: AdapterStatus = {\n    state: 'disconnected',\n    messageCount: { inbound: 0, outbound: 0 },\n    errorCount: 0,\n  };\n\n  constructor(id: string, config: ClaudeCodeAdapterConfig, deps: ClaudeCodeAdapterDeps) {\n    this.id = id;\n    this.config = {\n      maxConcurrent: config.maxConcurrent ?? 3,\n      defaultTimeoutMs: config.defaultTimeoutMs ?? 300_000,\n      defaultCwd: config.defaultCwd ?? process.cwd(),\n    };\n    this.deps = deps;\n  }\n\n  async start(relay: RelayPublisher): Promise<void> {\n    this.relay = relay;\n    this.status = {\n      state: 'connected',\n      messageCount: { inbound: 0, outbound: 0 },\n      errorCount: 0,\n      startedAt: new Date().toISOString(),\n    };\n  }\n\n  async stop(): Promise<void> {\n    this.relay = null;\n    this.status.state = 'disconnected';\n  }\n\n  getStatus(): AdapterStatus {\n    return { ...this.status };\n  }\n\n  async deliver(\n    subject: string,\n    envelope: RelayEnvelope,\n    context?: AdapterContext,\n  ): Promise<DeliveryResult> {\n    const startTime = Date.now();\n    this.status.messageCount.inbound++;\n\n    // Semaphore check\n    if (this.activeCount >= this.config.maxConcurrent) {\n      return {\n        success: false,\n        error: `Adapter at capacity (${this.config.maxConcurrent} concurrent sessions)`,\n        durationMs: Date.now() - startTime,\n      };\n    }\n\n    this.activeCount++;\n\n    try {\n      if (subject.startsWith(PULSE_SUBJECT_PREFIX)) {\n        return await this.handlePulseMessage(subject, envelope, context, startTime);\n      } else {\n        return await this.handleAgentMessage(subject, envelope, context, startTime);\n      }\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : String(err);\n      this.status.errorCount++;\n      this.status.lastError = errorMsg;\n      this.status.lastErrorAt = new Date().toISOString();\n      return {\n        success: false,\n        error: errorMsg,\n        durationMs: Date.now() - startTime,\n      };\n    } finally {\n      this.activeCount--;\n    }\n  }\n}\n```\n\n## Agent Message Handling\n\nImplement `handleAgentMessage` as a private method:\n\n```typescript\nprivate async handleAgentMessage(\n  subject: string,\n  envelope: RelayEnvelope,\n  context: AdapterContext | undefined,\n  startTime: number,\n): Promise<DeliveryResult> {\n  const sessionId = this.extractSessionId(subject);\n  if (!sessionId) {\n    return {\n      success: false,\n      error: `Could not extract sessionId from subject: ${subject}`,\n      durationMs: Date.now() - startTime,\n    };\n  }\n\n  const traceId = randomUUID();\n  const spanId = randomUUID();\n  const now = Date.now();\n\n  // Record trace span as pending\n  const span: TraceSpan = {\n    messageId: envelope.id,\n    traceId,\n    spanId,\n    parentSpanId: context?.trace?.parentSpanId ?? null,\n    subject: envelope.subject,\n    fromEndpoint: envelope.from,\n    toEndpoint: `agent:${sessionId}`,\n    status: 'pending',\n    budgetHopsUsed: envelope.budget.hopCount,\n    budgetTtlRemainingMs: envelope.budget.ttl - now,\n    sentAt: now,\n    deliveredAt: null,\n    processedAt: null,\n    error: null,\n  };\n  this.deps.traceStore.insertSpan(span);\n\n  // Resolve agent working directory\n  const agentCwd = context?.agent?.directory ?? this.config.defaultCwd;\n\n  // Ensure agent session\n  this.deps.agentManager.ensureSession(sessionId, {\n    permissionMode: 'default',\n    cwd: agentCwd,\n    hasStarted: true,\n  });\n\n  this.deps.traceStore.updateSpan(envelope.id, {\n    status: 'delivered',\n    deliveredAt: Date.now(),\n  });\n\n  // Format prompt with relay context\n  const content = this.extractPayloadContent(envelope.payload);\n  const prompt = this.formatPromptWithContext(content, envelope);\n\n  // Set up timeout from TTL budget\n  const ttlRemaining = envelope.budget.ttl - Date.now();\n  const timeoutMs = ttlRemaining > 0 ? ttlRemaining : this.config.defaultTimeoutMs;\n  const controller = new AbortController();\n  const timeout = setTimeout(() => controller.abort(), timeoutMs);\n\n  try {\n    const eventStream = this.deps.agentManager.sendMessage(sessionId, prompt, {\n      cwd: agentCwd,\n    });\n\n    // Stream events and publish to replyTo\n    for await (const event of eventStream) {\n      if (controller.signal.aborted) break;\n      if (envelope.replyTo && this.relay) {\n        await this.publishResponse(envelope, event, sessionId);\n      }\n    }\n\n    this.deps.traceStore.updateSpan(envelope.id, {\n      status: controller.signal.aborted ? 'failed' : 'processed',\n      processedAt: Date.now(),\n      ...(controller.signal.aborted && { error: 'TTL budget expired' }),\n    });\n\n    return {\n      success: !controller.signal.aborted,\n      error: controller.signal.aborted ? 'TTL budget expired' : undefined,\n      deadLettered: controller.signal.aborted,\n      durationMs: Date.now() - startTime,\n    };\n  } finally {\n    clearTimeout(timeout);\n  }\n}\n```\n\n## Pulse Message Handling\n\nImplement `handlePulseMessage` as a private method — port directly from `MessageReceiver.handlePulseMessage()`:\n\n```typescript\nprivate async handlePulseMessage(\n  subject: string,\n  envelope: RelayEnvelope,\n  context: AdapterContext | undefined,\n  startTime: number,\n): Promise<DeliveryResult> {\n  const traceId = randomUUID();\n  const spanId = randomUUID();\n  const now = Date.now();\n\n  // Validate payload\n  const parsed = PulseDispatchPayloadSchema.safeParse(envelope.payload);\n  if (!parsed.success) {\n    const failSpan: TraceSpan = {\n      messageId: envelope.id,\n      traceId,\n      spanId,\n      parentSpanId: null,\n      subject: envelope.subject,\n      fromEndpoint: envelope.from,\n      toEndpoint: 'pulse:unknown',\n      status: 'failed',\n      budgetHopsUsed: envelope.budget.hopCount,\n      budgetTtlRemainingMs: envelope.budget.ttl - now,\n      sentAt: now,\n      deliveredAt: now,\n      processedAt: now,\n      error: `Invalid PulseDispatchPayload: ${JSON.stringify(parsed.error.flatten().fieldErrors)}`,\n    };\n    this.deps.traceStore.insertSpan(failSpan);\n    return {\n      success: false,\n      error: 'Invalid PulseDispatchPayload',\n      durationMs: Date.now() - startTime,\n    };\n  }\n\n  const payload = parsed.data;\n  const { scheduleId, runId, prompt, cwd, permissionMode } = payload;\n  const effectiveCwd = cwd ?? context?.agent?.directory ?? this.config.defaultCwd;\n\n  // Record trace span as delivered\n  const span: TraceSpan = {\n    messageId: envelope.id,\n    traceId,\n    spanId,\n    parentSpanId: null,\n    subject: envelope.subject,\n    fromEndpoint: envelope.from,\n    toEndpoint: `pulse:${scheduleId}`,\n    status: 'delivered',\n    budgetHopsUsed: envelope.budget.hopCount,\n    budgetTtlRemainingMs: envelope.budget.ttl - now,\n    sentAt: now,\n    deliveredAt: now,\n    processedAt: null,\n    error: null,\n  };\n  this.deps.traceStore.insertSpan(span);\n\n  // Set up timeout from TTL budget\n  const ttlRemaining = envelope.budget.ttl - Date.now();\n  const controller = new AbortController();\n  let timeout: ReturnType<typeof setTimeout> | undefined;\n  if (ttlRemaining <= 0) {\n    controller.abort();\n  } else {\n    timeout = setTimeout(() => controller.abort(), ttlRemaining);\n  }\n\n  let outputSummary = '';\n\n  try {\n    if (controller.signal.aborted) {\n      throw new Error('Run timed out (TTL budget expired)');\n    }\n\n    this.deps.agentManager.ensureSession(runId, {\n      permissionMode,\n      cwd: effectiveCwd,\n      hasStarted: false,\n    });\n\n    const eventStream = this.deps.agentManager.sendMessage(runId, prompt, {\n      cwd: effectiveCwd,\n    });\n\n    for await (const event of eventStream) {\n      if (controller.signal.aborted) break;\n\n      if (event.type === 'text_delta' && outputSummary.length < OUTPUT_SUMMARY_MAX_CHARS) {\n        const data = event.data as { text: string };\n        outputSummary += data.text;\n      }\n\n      if (envelope.replyTo && this.relay) {\n        await this.publishResponse(envelope, event, runId);\n      }\n    }\n\n    const durationMs = Date.now() - startTime;\n    const truncatedSummary = outputSummary.slice(0, OUTPUT_SUMMARY_MAX_CHARS);\n\n    if (this.deps.pulseStore) {\n      if (controller.signal.aborted) {\n        this.deps.pulseStore.updateRun(runId, {\n          status: 'cancelled',\n          finishedAt: new Date().toISOString(),\n          durationMs,\n          outputSummary: truncatedSummary,\n          error: 'Run timed out (TTL budget expired)',\n          sessionId: runId,\n        });\n      } else {\n        this.deps.pulseStore.updateRun(runId, {\n          status: 'completed',\n          finishedAt: new Date().toISOString(),\n          durationMs,\n          outputSummary: truncatedSummary,\n          sessionId: runId,\n        });\n      }\n    }\n\n    this.deps.traceStore.updateSpan(envelope.id, {\n      status: 'processed',\n      processedAt: Date.now(),\n    });\n\n    return {\n      success: !controller.signal.aborted,\n      error: controller.signal.aborted ? 'TTL budget expired' : undefined,\n      durationMs,\n    };\n  } catch (err) {\n    const durationMs = Date.now() - startTime;\n    const errorMsg = err instanceof Error ? err.message : String(err);\n\n    if (this.deps.pulseStore) {\n      this.deps.pulseStore.updateRun(runId, {\n        status: 'failed',\n        finishedAt: new Date().toISOString(),\n        durationMs,\n        outputSummary: outputSummary.slice(0, OUTPUT_SUMMARY_MAX_CHARS),\n        error: errorMsg,\n        sessionId: runId,\n      });\n    }\n\n    this.deps.traceStore.updateSpan(envelope.id, {\n      status: 'failed',\n      processedAt: Date.now(),\n      error: errorMsg,\n    });\n\n    return {\n      success: false,\n      error: errorMsg,\n      deadLettered: true,\n      durationMs,\n    };\n  } finally {\n    if (timeout) clearTimeout(timeout);\n  }\n}\n```\n\n## Prompt Formatting\n\nImplement `formatPromptWithContext` — injects relay metadata as an XML block following the `context-builder.ts` pattern:\n\n```typescript\n/**\n * Format the user prompt with a <relay_context> XML block.\n *\n * Follows the XML block pattern used by context-builder.ts (<env>, <git_status>).\n * The relay context provides the agent with sender info, budget awareness,\n * and reply instructions.\n */\nprivate formatPromptWithContext(content: string, envelope: RelayEnvelope): string {\n  const lines: string[] = [\n    `From: ${envelope.from}`,\n    `Message-ID: ${envelope.id}`,\n    `Subject: ${envelope.subject}`,\n    `Sent: ${envelope.createdAt}`,\n    '',\n    'Budget remaining:',\n    `- Hops: ${envelope.budget.hopCount} of ${envelope.budget.maxHops} used`,\n    `- TTL: ${Math.max(0, Math.round((envelope.budget.ttl - Date.now()) / 1000))} seconds remaining`,\n    `- Max turns: ${envelope.budget.callBudgetRemaining}`,\n  ];\n\n  if (envelope.replyTo) {\n    lines.push('');\n    lines.push(`Reply to: ${envelope.replyTo}`);\n    lines.push('If you cannot complete the task within the budget, summarize what you\\'ve done and stop.');\n  }\n\n  const contextBlock = `<relay_context>\\n${lines.join('\\n')}\\n</relay_context>`;\n  return `${contextBlock}\\n\\n${content}`;\n}\n```\n\n## Helper Methods\n\n```typescript\n/** Extract session ID from relay.agent.{sessionId} subject. */\nprivate extractSessionId(subject: string): string | null {\n  const segments = subject.split('.');\n  if (segments.length < 3 || segments[0] !== 'relay' || segments[1] !== 'agent') {\n    return null;\n  }\n  return segments[2] || null;\n}\n\n/** Extract message content from an envelope payload. */\nprivate extractPayloadContent(payload: unknown): string {\n  if (typeof payload === 'string') return payload;\n  if (payload && typeof payload === 'object') {\n    const obj = payload as Record<string, unknown>;\n    if (typeof obj.content === 'string') return obj.content;\n    if (typeof obj.text === 'string') return obj.text;\n  }\n  return JSON.stringify(payload);\n}\n\n/** Publish a response event to the envelope's replyTo subject. */\nprivate async publishResponse(\n  originalEnvelope: RelayEnvelope,\n  event: StreamEvent,\n  fromId: string,\n): Promise<void> {\n  if (!this.relay || !originalEnvelope.replyTo) return;\n  await this.relay.publish(originalEnvelope.replyTo, event, {\n    from: `agent:${fromId}`,\n    budget: {\n      hopCount: originalEnvelope.budget.hopCount + 1,\n    },\n  });\n}\n```\n\n## Export from index.ts\n\nAdd to `packages/relay/src/index.ts`:\n```typescript\n// Built-in adapters\nexport { ClaudeCodeAdapter } from './adapters/claude-code-adapter.js';\nexport type {\n  ClaudeCodeAdapterConfig,\n  ClaudeCodeAdapterDeps,\n  AgentManagerLike as ClaudeCodeAgentManagerLike,\n  TraceStoreLike,\n  PulseStoreLike,\n} from './adapters/claude-code-adapter.js';\n```\n\n## Acceptance Criteria\n\n- `ClaudeCodeAdapter` implements `RelayAdapter` interface\n- Handles `relay.agent.>` subjects (agent-directed messages)\n- Handles `relay.system.pulse.>` subjects (Pulse scheduler dispatch)\n- Semaphore rejects when at `maxConcurrent` capacity\n- Formats prompts with `<relay_context>` XML block\n- TTL budget is enforced via AbortController timeout\n- Trace spans are recorded through the delivery lifecycle\n- Pulse run lifecycle is updated in PulseStore\n- Response events are published to `envelope.replyTo`\n- Exported from `@dorkos/relay`",
      "activeForm": "Implementing ClaudeCodeAdapter",
      "size": "large",
      "priority": "high",
      "dependencies": ["1.1", "1.4"],
      "parallelWith": []
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "Claude Code Adapter",
      "subject": "relay-runtime-adapters [P3] Write ClaudeCodeAdapter tests",
      "description": "Create comprehensive tests for the ClaudeCodeAdapter in `packages/relay/src/adapters/__tests__/claude-code-adapter.test.ts`.\n\n## Test File Structure\n\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport type { RelayEnvelope, TraceSpan } from '@dorkos/shared/relay-schemas';\nimport type { StreamEvent } from '@dorkos/shared/types';\nimport { ClaudeCodeAdapter } from '../claude-code-adapter.js';\nimport type {\n  AgentManagerLike,\n  TraceStoreLike,\n  PulseStoreLike,\n  ClaudeCodeAdapterDeps,\n} from '../claude-code-adapter.js';\nimport type { RelayPublisher, AdapterContext } from '../../types.js';\n```\n\n## Mock Factories\n\nCreate mock factories at the top of the test file:\n\n```typescript\nfunction createMockAgentManager(): AgentManagerLike {\n  return {\n    ensureSession: vi.fn(),\n    sendMessage: vi.fn().mockReturnValue(\n      (async function* () {\n        yield { type: 'text_delta', data: { text: 'Hello ' } } as StreamEvent;\n        yield { type: 'text_delta', data: { text: 'world' } } as StreamEvent;\n        yield { type: 'done', data: {} } as StreamEvent;\n      })(),\n    ),\n  };\n}\n\nfunction createMockTraceStore(): TraceStoreLike {\n  return {\n    insertSpan: vi.fn(),\n    updateSpan: vi.fn(),\n  };\n}\n\nfunction createMockPulseStore(): PulseStoreLike {\n  return {\n    updateRun: vi.fn(),\n  };\n}\n\nfunction createMockRelay(): RelayPublisher {\n  return {\n    publish: vi.fn().mockResolvedValue({ messageId: 'resp-1', deliveredTo: 1 }),\n    onSignal: vi.fn().mockReturnValue(() => {}),\n  };\n}\n\nfunction createTestEnvelope(overrides?: Partial<RelayEnvelope>): RelayEnvelope {\n  return {\n    id: 'msg-001',\n    subject: 'relay.agent.session-abc',\n    from: 'user:console',\n    replyTo: 'relay.human.console.client-1',\n    budget: {\n      hopCount: 1,\n      maxHops: 5,\n      ancestorChain: [],\n      ttl: Date.now() + 300_000,\n      callBudgetRemaining: 10,\n    },\n    createdAt: new Date().toISOString(),\n    payload: { content: 'Run the budget report' },\n    ...overrides,\n  };\n}\n\nfunction createPulseEnvelope(overrides?: Partial<RelayEnvelope>): RelayEnvelope {\n  return {\n    id: 'msg-002',\n    subject: 'relay.system.pulse.budget-monitor',\n    from: 'system:pulse',\n    replyTo: 'relay.human.console.client-1',\n    budget: {\n      hopCount: 0,\n      maxHops: 5,\n      ancestorChain: [],\n      ttl: Date.now() + 300_000,\n      callBudgetRemaining: 5,\n    },\n    createdAt: new Date().toISOString(),\n    payload: {\n      type: 'pulse_dispatch',\n      scheduleId: 'sched-1',\n      runId: 'run-1',\n      prompt: 'Check the budget',\n      cwd: '/home/user/project',\n      permissionMode: 'default',\n      scheduleName: 'Budget Monitor',\n      cron: '0 * * * *',\n      trigger: 'cron',\n    },\n    ...overrides,\n  };\n}\n```\n\n## Test Cases\n\n### Agent Message Tests\n\n1. **Delivers agent message — calls AgentManager with correct cwd and formatted prompt**\n   - Create adapter, call `deliver()` with agent envelope and `context.agent.directory = '/projects/myapp'`\n   - Assert `agentManager.ensureSession` called with sessionId `'session-abc'`, cwd `'/projects/myapp'`\n   - Assert `agentManager.sendMessage` called with prompt containing `<relay_context>` block and the payload content\n   - Assert result is `{ success: true }`\n\n2. **Formats `<relay_context>` XML block with sender, budget, reply-to**\n   - Capture the prompt passed to `sendMessage`\n   - Assert it contains `From: user:console`\n   - Assert it contains `Message-ID: msg-001`\n   - Assert it contains `Hops: 1 of 5 used`\n   - Assert it contains `Reply to: relay.human.console.client-1`\n   - Assert the actual content follows the XML block\n\n3. **Enforces concurrency semaphore — rejects when at capacity**\n   - Create adapter with `maxConcurrent: 1`\n   - Mock `sendMessage` to return an async generator that never completes (hangs)\n   - Call `deliver()` (first call starts processing)\n   - Call `deliver()` again (second call)\n   - Assert second result is `{ success: false, error: 'Adapter at capacity (1 concurrent sessions)' }`\n\n4. **Derives session timeout from envelope TTL budget**\n   - Create envelope with TTL set to `Date.now() + 5000` (5 seconds)\n   - Mock `sendMessage` to yield events slowly\n   - Assert AbortController triggers after TTL expires\n   - Assert result has `success: false, error: 'TTL budget expired'`\n\n5. **Publishes response events to `envelope.replyTo`**\n   - Call `deliver()` with envelope that has `replyTo`\n   - Assert `relay.publish` was called for each event from the stream\n   - Assert `from` is `'agent:session-abc'`\n   - Assert `budget.hopCount` is `originalEnvelope.budget.hopCount + 1`\n\n6. **Records trace spans through delivery lifecycle**\n   - Call `deliver()` successfully\n   - Assert `traceStore.insertSpan` called with `status: 'pending'`\n   - Assert `traceStore.updateSpan` called with `status: 'delivered'`\n   - Assert `traceStore.updateSpan` called with `status: 'processed'`\n\n7. **Returns failure result on session error**\n   - Mock `sendMessage` to throw an error\n   - Assert result is `{ success: false, error: '...' }`\n   - Assert `traceStore.updateSpan` called with `status: 'failed'`\n\n8. **Works without Mesh context (uses defaultCwd)**\n   - Call `deliver()` without `context` parameter\n   - Assert `ensureSession` called with `cwd` from adapter config `defaultCwd`\n\n9. **Works with Mesh context (uses context.agent.directory)**\n   - Call `deliver()` with `context: { agent: { directory: '/mesh/agent', runtime: 'claude-code' } }`\n   - Assert `ensureSession` called with `cwd: '/mesh/agent'`\n\n### Pulse Message Tests\n\n10. **Handles Pulse dispatch messages — validates payload, updates PulseStore lifecycle**\n    - Call `deliver()` with Pulse envelope\n    - Assert `agentManager.sendMessage` called with the prompt from the payload\n    - Assert `pulseStore.updateRun` called with `status: 'completed'`\n\n11. **Pulse: records failed trace for invalid payload**\n    - Call `deliver()` with Pulse subject but invalid payload\n    - Assert `traceStore.insertSpan` called with `status: 'failed'`\n    - Assert result is `{ success: false }`\n\n12. **Pulse: updates PulseStore to cancelled on TTL timeout**\n    - Create envelope with TTL already expired (`ttl: Date.now() - 1000`)\n    - Assert `pulseStore.updateRun` called with `status: 'cancelled'` or run throws with TTL error\n\n13. **Pulse: collects output summary up to 1000 chars**\n    - Mock `sendMessage` to yield many `text_delta` events totaling > 1000 chars\n    - Assert `pulseStore.updateRun` called with `outputSummary` trimmed to 1000 chars\n\n### Adapter Lifecycle Tests\n\n14. **start() sets state to connected**\n    - Call `start()` with mock relay\n    - Assert `getStatus().state` is `'connected'`\n\n15. **stop() sets state to disconnected**\n    - Call `start()` then `stop()`\n    - Assert `getStatus().state` is `'disconnected'`\n\n## Acceptance Criteria\n\n- All 15+ test cases pass\n- Tests use mock factories (no real AgentManager, TraceStore, or PulseStore)\n- Each test validates a specific behavior described in the spec's testing strategy\n- Test descriptions clearly explain what behavior is being validated",
      "activeForm": "Writing ClaudeCodeAdapter tests",
      "size": "large",
      "priority": "high",
      "dependencies": ["3.1"],
      "parallelWith": []
    },
    {
      "id": "4.1",
      "phase": 4,
      "phaseName": "Server Integration",
      "subject": "relay-runtime-adapters [P4] Update AdapterManager for claude-code and plugin types",
      "description": "Update `apps/server/src/services/relay/adapter-manager.ts` to support the new `claude-code` and `plugin` adapter types, inject dependencies for ClaudeCodeAdapter, and optionally enrich AdapterContext with Mesh agent data.\n\n## Constructor Changes\n\nThe `AdapterManager` needs additional dependencies for constructing `ClaudeCodeAdapter` and loading plugins. Update the constructor:\n\n```typescript\nimport { ClaudeCodeAdapter } from '@dorkos/relay';\nimport type {\n  ClaudeCodeAdapterDeps,\n  AgentManagerLike as ClaudeCodeAgentManagerLike,\n  TraceStoreLike,\n  PulseStoreLike,\n} from '@dorkos/relay';\nimport { loadAdapters } from '@dorkos/relay';\nimport type { AdapterContext } from '@dorkos/relay';\n\n/** Dependencies for constructing runtime adapters. */\nexport interface AdapterManagerDeps {\n  agentManager: ClaudeCodeAgentManagerLike;\n  traceStore: TraceStoreLike;\n  pulseStore?: PulseStoreLike;\n  /** Optional MeshCore for enriching AdapterContext with agent info */\n  meshCore?: {\n    getAgent(id: string): { manifest: Record<string, unknown> } | undefined;\n  };\n}\n\nexport class AdapterManager {\n  private readonly registry: AdapterRegistry;\n  private configWatcher: FSWatcher | null = null;\n  private readonly configPath: string;\n  private configs: AdapterConfig[] = [];\n  private readonly deps: AdapterManagerDeps;\n\n  constructor(\n    registry: AdapterRegistry,\n    configPath: string,\n    deps: AdapterManagerDeps,\n  ) {\n    this.registry = registry;\n    this.configPath = configPath;\n    this.deps = deps;\n  }\n```\n\n## Make createAdapter Async\n\nChange `createAdapter` from synchronous to async to support plugin loading:\n\n```typescript\nprivate async createAdapter(config: AdapterConfig): Promise<RelayAdapter | null> {\n  switch (config.type) {\n    case 'telegram':\n      return new TelegramAdapter(\n        config.id,\n        config.config as TelegramAdapterConfig,\n      );\n    case 'webhook':\n      return new WebhookAdapter(\n        config.id,\n        config.config as WebhookAdapterConfig,\n      );\n    case 'claude-code':\n      return new ClaudeCodeAdapter(\n        config.id,\n        config.config as Record<string, unknown>,\n        {\n          agentManager: this.deps.agentManager,\n          traceStore: this.deps.traceStore,\n          pulseStore: this.deps.pulseStore,\n        },\n      );\n    case 'plugin':\n      return this.loadPlugin(config);\n    default:\n      logger.warn(`[AdapterManager] Unknown adapter type: ${(config as AdapterConfig).type}`);\n      return null;\n  }\n}\n```\n\n## Plugin Loading Method\n\n```typescript\nprivate async loadPlugin(config: AdapterConfig): Promise<RelayAdapter | null> {\n  if (!config.plugin) {\n    logger.warn(`[AdapterManager] Plugin adapter '${config.id}' missing plugin source config`);\n    return null;\n  }\n\n  const builtinMap = new Map<string, (c: Record<string, unknown>) => RelayAdapter>();\n  const configDir = dirname(this.configPath);\n  const results = await loadAdapters([{\n    id: config.id,\n    type: config.type,\n    enabled: config.enabled,\n    plugin: config.plugin,\n    config: config.config as Record<string, unknown>,\n  }], builtinMap, configDir);\n\n  return results[0] ?? null;\n}\n```\n\n## Update startEnabledAdapters\n\nSince `createAdapter` is now async, update `startEnabledAdapters`:\n\n```typescript\nprivate async startEnabledAdapters(): Promise<void> {\n  for (const config of this.configs) {\n    if (!config.enabled) continue;\n    if (this.registry.get(config.id)) continue;\n\n    const adapter = await this.createAdapter(config);\n    if (adapter) {\n      try {\n        await this.registry.register(adapter);\n      } catch (err) {\n        logger.warn(`[AdapterManager] Failed to start adapter '${config.id}':`, err);\n      }\n    }\n  }\n}\n```\n\n## Update enable() Method\n\nSince `createAdapter` is now async:\n\n```typescript\nasync enable(id: string): Promise<void> {\n  const config = this.configs.find((c) => c.id === id);\n  if (!config) throw new Error(`Adapter not found: ${id}`);\n\n  config.enabled = true;\n  await this.saveConfig();\n\n  const adapter = await this.createAdapter(config);\n  if (adapter) {\n    await this.registry.register(adapter);\n  }\n}\n```\n\n## Mesh Integration: Context Enrichment\n\nAdd a method to enrich AdapterContext with Mesh agent info. This is called by the AdapterRegistry's deliver flow or by overriding the deliver path:\n\n```typescript\n/**\n * Enrich AdapterContext with Mesh agent info if MeshCore is available.\n *\n * Extracts the agent ID from the subject (e.g., relay.agent.{agentId})\n * and looks up the agent manifest in the Mesh registry.\n */\nbuildContext(subject: string): AdapterContext | undefined {\n  if (!this.deps.meshCore) return undefined;\n  if (!subject.startsWith('relay.agent.')) return undefined;\n\n  const segments = subject.split('.');\n  const agentId = segments[2];\n  if (!agentId) return undefined;\n\n  const agentInfo = this.deps.meshCore.getAgent(agentId);\n  if (!agentInfo) return undefined;\n\n  const manifest = agentInfo.manifest as Record<string, unknown>;\n  return {\n    agent: {\n      directory: (manifest.directory as string) ?? process.cwd(),\n      runtime: (manifest.runtime as string) ?? 'claude-code',\n      manifest,\n    },\n  };\n}\n```\n\n## Default Config Generation\n\nAdd a method to generate default `adapters.json` when it doesn't exist:\n\n```typescript\n/**\n * Generate a default adapters.json with claude-code enabled.\n *\n * Called during initialization if no config file exists and Relay is enabled.\n */\nprivate async ensureDefaultConfig(): Promise<void> {\n  try {\n    await readFile(this.configPath, 'utf-8');\n    // Config exists, nothing to do\n  } catch (err) {\n    if ((err as NodeJS.ErrnoException).code === 'ENOENT') {\n      const defaultConfig = {\n        adapters: [\n          {\n            id: 'claude-code',\n            type: 'claude-code',\n            builtin: true,\n            enabled: true,\n            config: {\n              maxConcurrent: 3,\n              defaultTimeoutMs: 300000,\n            },\n          },\n        ],\n      };\n      await mkdir(dirname(this.configPath), { recursive: true });\n      await writeFile(\n        this.configPath,\n        JSON.stringify(defaultConfig, null, 2),\n        'utf-8',\n      );\n      logger.info('[AdapterManager] Generated default adapters.json with claude-code adapter');\n    }\n  }\n}\n```\n\nCall `ensureDefaultConfig()` at the start of `initialize()`:\n```typescript\nasync initialize(): Promise<void> {\n  await this.ensureDefaultConfig();\n  await this.loadConfig();\n  await this.startEnabledAdapters();\n  this.startConfigWatcher();\n}\n```\n\n## Update Existing Tests\n\nUpdate `apps/server/src/services/relay/__tests__/adapter-manager.test.ts`:\n- Constructor now requires a `deps` parameter\n- `createAdapter` is now async\n- Add test for `'claude-code'` config type creating a ClaudeCodeAdapter\n- Add test for `'plugin'` config type using the plugin loader\n- Add test for Mesh context enrichment via `buildContext()`\n- Add test for default config generation when no adapters.json exists\n\n## Acceptance Criteria\n\n- `AdapterManager` constructor accepts `AdapterManagerDeps`\n- `createAdapter()` is async and handles `'claude-code'` and `'plugin'` types\n- `ClaudeCodeAdapter` is constructed with injected `agentManager`, `traceStore`, `pulseStore`\n- Plugin adapters are loaded via `loadAdapters()` from `@dorkos/relay`\n- `buildContext()` enriches `AdapterContext` with Mesh agent info when `meshCore` is available\n- Default `adapters.json` is generated with `claude-code` enabled when no config exists\n- All existing and new tests pass",
      "activeForm": "Updating AdapterManager for claude-code and plugin types",
      "size": "large",
      "priority": "high",
      "dependencies": ["2.1", "3.1"],
      "parallelWith": ["4.2"]
    },
    {
      "id": "4.2",
      "phase": 4,
      "phaseName": "Server Integration",
      "subject": "relay-runtime-adapters [P4] Remove MessageReceiver and update server startup",
      "description": "Delete `MessageReceiver` and all references to it, replacing its role with the `ClaudeCodeAdapter` managed by `AdapterManager`.\n\n## Files to Delete\n\n1. `apps/server/src/services/relay/message-receiver.ts` — the entire file\n2. `apps/server/src/services/relay/__tests__/message-receiver.test.ts` — the test file\n\n## Files to Update\n\n### 1. `apps/server/src/services/relay/index.ts`\n\nRemove the MessageReceiver exports. Change from:\n```typescript\nexport { setRelayEnabled, isRelayEnabled } from './relay-state.js';\nexport { AdapterManager } from './adapter-manager.js';\nexport { TraceStore } from './trace-store.js';\nexport type { TraceStoreOptions, TraceSpanUpdate } from './trace-store.js';\nexport { MessageReceiver, extractSessionId, extractPayloadContent } from './message-receiver.js';\nexport type { AgentManagerLike, MessageReceiverOptions } from './message-receiver.js';\n```\nTo:\n```typescript\nexport { setRelayEnabled, isRelayEnabled } from './relay-state.js';\nexport { AdapterManager } from './adapter-manager.js';\nexport type { AdapterManagerDeps } from './adapter-manager.js';\nexport { TraceStore } from './trace-store.js';\nexport type { TraceStoreOptions, TraceSpanUpdate } from './trace-store.js';\n```\n\n### 2. `apps/server/src/index.ts`\n\nRemove the MessageReceiver import and instantiation. Specifically:\n\n**Remove import:**\n```typescript\nimport { MessageReceiver } from './services/relay/message-receiver.js';\n```\n\n**Remove variable declaration:**\n```typescript\nlet messageReceiver: MessageReceiver | undefined;\n```\n\n**Remove instantiation block** (the section that creates and starts MessageReceiver, approximately lines 91-98):\n```typescript\n// Initialize message receiver (bridges Relay -> AgentManager)\nmessageReceiver = new MessageReceiver({\n  relayCore,\n  agentManager,\n  traceStore,\n  defaultCwd: process.env.DORKOS_DEFAULT_CWD ?? process.cwd(),\n});\nmessageReceiver.start();\nlogger.info('[Relay] MessageReceiver started');\n```\n\n**Update AdapterManager construction** to pass the new `deps` parameter:\n```typescript\nadapterManager = new AdapterManager(\n  adapterRegistry,\n  relayConfigPath,\n  {\n    agentManager,\n    traceStore,\n    pulseStore,\n    meshCore,\n  },\n);\n```\n\nThe `AdapterManager.initialize()` will now generate the default `adapters.json` with `claude-code` enabled, which replaces the `MessageReceiver` functionality entirely.\n\n**Remove any `messageReceiver.stop()` calls** in the shutdown/cleanup section.\n\n### 3. Check for any other references\n\nSearch the entire codebase for `MessageReceiver` or `message-receiver` imports and remove them. Files that may reference it:\n- `apps/server/src/services/mcp-tool-server.ts` — check if it references MessageReceiver\n- Any other server files that import from the relay services barrel\n\n## Verification\n\nAfter removal:\n1. `npm run typecheck` passes — no broken imports\n2. `npm test -- --run` passes — all tests pass (MessageReceiver tests are deleted, not failing)\n3. The server starts correctly with Relay enabled\n4. The `claude-code` adapter in `adapters.json` handles `relay.agent.>` and `relay.system.pulse.>` subjects (the same subjects MessageReceiver subscribed to)\n\n## Acceptance Criteria\n\n- `message-receiver.ts` is deleted\n- `message-receiver.test.ts` is deleted\n- No imports of `MessageReceiver` exist anywhere in the codebase\n- The relay services barrel (`index.ts`) no longer exports MessageReceiver\n- Server startup creates `AdapterManager` with the new `deps` parameter\n- `AdapterManager.initialize()` generates default config with `claude-code` adapter\n- TypeScript compiles without errors\n- All remaining tests pass",
      "activeForm": "Removing MessageReceiver and updating server startup",
      "size": "medium",
      "priority": "high",
      "dependencies": ["4.1"],
      "parallelWith": []
    },
    {
      "id": "4.3",
      "phase": 4,
      "phaseName": "Server Integration",
      "subject": "relay-runtime-adapters [P4] End-to-end verification and CLAUDE.md updates",
      "description": "Verify the complete integration works end-to-end and update documentation references.\n\n## End-to-End Verification Steps\n\n1. **TypeScript compilation**: Run `npm run typecheck` across all packages. Verify zero errors.\n\n2. **All tests pass**: Run `npm test -- --run`. Verify all test suites pass.\n\n3. **Lint check**: Run `npm run lint`. Verify no new errors (warnings are acceptable).\n\n4. **Verify adapter flow**: Check that the following data flow is intact by reviewing code paths:\n   - A message published to `relay.agent.{sessionId}` is routed by `RelayCore` to `AdapterRegistry`\n   - `AdapterRegistry.deliver()` matches `ClaudeCodeAdapter` (subjectPrefix `relay.agent.`)\n   - `ClaudeCodeAdapter.deliver()` calls `AgentManager.sendMessage()` with formatted prompt\n   - Response events are published to `envelope.replyTo`\n   - Trace spans are recorded through the lifecycle\n\n5. **Verify Pulse flow**: Check that:\n   - Messages on `relay.system.pulse.{scheduleId}` are handled by `ClaudeCodeAdapter`\n   - PulseStore run lifecycle is updated (completed/failed/cancelled)\n\n6. **Verify plugin loading**: Check that:\n   - `adapters.json` with `type: 'plugin'` entries would trigger `loadAdapters()`\n   - Plugin validation rejects modules without required methods\n\n## CLAUDE.md Updates\n\nUpdate the following sections in `/Users/doriancollier/Keep/dork-os/core/CLAUDE.md`:\n\n### Service Descriptions\n\nUpdate the `message-receiver.ts` entry. Replace:\n```\n- **`services/relay/message-receiver.ts`** - Bridge between Relay message bus and AgentManager. Subscribes to `relay.agent.>` and `relay.system.pulse.>`. Routes incoming messages to `agentManager.sendMessage()` for agent sessions and handles Pulse dispatch with full run lifecycle (PulseStore tracking, timeout, output collection).\n```\nWith:\n```\n- **`services/relay/adapter-manager.ts`** - Server-side adapter lifecycle manager for the Relay message bus. Loads adapter configurations from `~/.dork/relay/adapters.json`, instantiates adapters via `AdapterRegistry`, watches config for hot-reload. Supports built-in adapters (telegram, webhook, claude-code), npm plugin packages, and local file plugins. Generates default config with `claude-code` adapter when none exists. Optionally enriches `AdapterContext` with Mesh agent info. Injects `AgentManagerLike`, `TraceStore`, `PulseStore` for `ClaudeCodeAdapter` construction.\n```\n\nNote: The `adapter-manager.ts` description already exists in the service list. Update it to reflect the new capabilities rather than adding a duplicate.\n\n### Package Exports\n\nIf `@dorkos/relay` exports are mentioned in CLAUDE.md, add `AdapterContext`, `DeliveryResult`, `ClaudeCodeAdapter`, `loadAdapters`, `validateAdapterShape` to the list.\n\n### Session Architecture\n\nUpdate the \"When `DORKOS_RELAY_ENABLED` is true\" section to mention that `ClaudeCodeAdapter` (not `MessageReceiver`) handles the `relay.agent.>` subscription.\n\n## Acceptance Criteria\n\n- `npm run typecheck` passes with zero errors\n- `npm test -- --run` passes all test suites\n- `npm run lint` shows no new errors\n- CLAUDE.md is updated to reflect the removal of MessageReceiver and addition of ClaudeCodeAdapter\n- No references to `MessageReceiver` remain in documentation or comments (except in git history)",
      "activeForm": "Running end-to-end verification and updating documentation",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["4.2"],
      "parallelWith": []
    }
  ]
}
