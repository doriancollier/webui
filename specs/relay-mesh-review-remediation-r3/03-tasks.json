{
  "spec": "specs/relay-mesh-review-remediation-r3/02-specification.md",
  "slug": "relay-mesh-review-remediation-r3",
  "generatedAt": "2026-03-01T12:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Critical Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P1] Add boundary validation to mesh route filesystem paths",
      "description": "Add `validateBoundary()` calls to all mesh route endpoints that accept filesystem paths. This mirrors the established pattern in `routes/files.ts` and `routes/agents.ts`.\n\n**File:** `apps/server/src/routes/mesh.ts`\n\n**Step 1:** Import `validateBoundary` from the boundary utility:\n\n```typescript\nimport { validateBoundary } from '../lib/boundary.js';\n```\n\n**Step 2:** Add boundary validation to `POST /discover` — validate each root path before passing to `meshCore.discover()`:\n\n```typescript\nrouter.post('/discover', async (req, res) => {\n  const result = DiscoverRequestSchema.safeParse(req.body);\n  if (!result.success) {\n    return res.status(400).json({ error: 'Validation failed', details: result.error.flatten() });\n  }\n\n  // Validate each discovery root against boundary\n  const validatedRoots: string[] = [];\n  for (const root of result.data.roots) {\n    try {\n      validatedRoots.push(await validateBoundary(root));\n    } catch {\n      return res.status(403).json({ error: `Path outside boundary: ${root}` });\n    }\n  }\n\n  try {\n    const MAX_CANDIDATES = 1000;\n    const candidates = [];\n    const options = result.data.maxDepth ? { maxDepth: result.data.maxDepth } : undefined;\n    for await (const candidate of meshCore.discover(validatedRoots, options)) {\n      candidates.push(candidate);\n      if (candidates.length >= MAX_CANDIDATES) break;\n    }\n    return res.json({ candidates, truncated: candidates.length >= MAX_CANDIDATES });\n  } catch (err) {\n    const message = err instanceof Error ? err.message : 'Discovery failed';\n    return res.status(500).json({ error: message });\n  }\n});\n```\n\n**Step 3:** Add boundary validation to `POST /agents` — validate `projectPath`:\n\n```typescript\nrouter.post('/agents', async (req, res) => {\n  const result = RegisterAgentRequestSchema.safeParse(req.body);\n  if (!result.success) { ... }\n\n  const { path: projectPath, overrides, approver } = result.data;\n\n  // Validate projectPath against boundary\n  let validatedPath: string;\n  try {\n    validatedPath = await validateBoundary(projectPath);\n  } catch {\n    return res.status(403).json({ error: `Path outside boundary: ${projectPath}` });\n  }\n\n  // ... rest of handler using validatedPath instead of projectPath\n});\n```\n\n**Step 4:** Add boundary validation to `POST /deny` — validate `path`:\n\n```typescript\nrouter.post('/deny', async (req, res) => {\n  const result = DenyRequestSchema.safeParse(req.body);\n  if (!result.success) { ... }\n\n  try {\n    await validateBoundary(result.data.path);\n  } catch {\n    return res.status(403).json({ error: `Path outside boundary: ${result.data.path}` });\n  }\n\n  // ... rest of handler\n});\n```\n\n**Step 5:** Add boundary validation to `DELETE /denied/:encodedPath` — validate the decoded path:\n\n```typescript\nrouter.delete('/denied/:encodedPath', async (req, res) => {\n  const filePath = decodeURIComponent(req.params.encodedPath);\n  if (filePath.includes('..') || filePath.includes('\\0')) {\n    return res.status(400).json({ error: 'Invalid path' });\n  }\n\n  try {\n    await validateBoundary(filePath);\n  } catch {\n    return res.status(403).json({ error: `Path outside boundary: ${filePath}` });\n  }\n\n  await meshCore.undeny(filePath);\n  return res.json({ success: true });\n});\n```\n\n**Testing:** Add tests in `apps/server/src/routes/__tests__/mesh.test.ts` (create if needed):\n- Test that `POST /discover` returns 403 when any root path is outside the boundary\n- Test that `POST /agents` returns 403 when projectPath is outside the boundary\n- Test that `POST /deny` returns 403 for out-of-boundary paths\n- Test that `DELETE /denied/:encodedPath` returns 403 for out-of-boundary paths\n- Test that valid paths still work normally (200/201)\n\n**Acceptance criteria:**\n- All four mesh endpoints that accept filesystem paths validate against the configured boundary\n- Out-of-boundary paths return 403 with descriptive error message\n- Existing tests continue to pass\n- `pnpm typecheck` passes",
      "activeForm": "Adding boundary validation to mesh route endpoints",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.2", "1.3", "1.4"]
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Critical Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P1] Fix extractChatId accepting invalid chat ID 0",
      "description": "The `extractChatId` function in the Telegram adapter accepts chat ID 0 because `Number(\"\") === 0` and `Number.isInteger(0) === true`. Chat ID 0 is invalid in the Telegram API and should return `null`.\n\n**File:** `packages/relay/src/adapters/telegram-adapter.ts`\n\nFind the `extractChatId` function (around lines 80-96) and add guards for empty strings that would parse to 0:\n\n```typescript\nfunction extractChatId(subject: string): number | null {\n  if (!subject.startsWith(SUBJECT_PREFIX)) return null;\n  const remainder = subject.slice(SUBJECT_PREFIX.length + 1);\n  if (!remainder) return null;\n\n  if (remainder.startsWith(`${GROUP_SEGMENT}.`)) {\n    const idStr = remainder.slice(GROUP_SEGMENT.length + 1);\n    if (!idStr) return null;  // Guard: Number(\"\") === 0, which is invalid\n    const id = Number(idStr);\n    return Number.isInteger(id) ? id : null;\n  }\n\n  const id = Number(remainder);\n  return Number.isInteger(id) ? id : null;\n}\n```\n\nThe key fix is adding `if (!idStr) return null;` before `Number(idStr)` in the group branch. This prevents `Number(\"\")` from producing `0`, which would be treated as a valid chat ID.\n\n**Testing:** Add tests in the existing `packages/relay/src/__tests__/adapters/telegram-adapter.test.ts`:\n\n```typescript\ndescribe('extractChatId edge cases', () => {\n  it('returns null for empty group suffix (would produce chat ID 0)', () => {\n    // Subject like \"relay.human.telegram.group.\" with no ID after final dot\n    // This would cause Number(\"\") === 0 without the guard\n    const result = extractChatId('relay.human.telegram.group.');\n    expect(result).toBeNull();\n  });\n\n  it('returns valid group chat IDs', () => {\n    const result = extractChatId('relay.human.telegram.group.12345');\n    expect(result).toBe(12345);\n  });\n\n  it('returns valid DM chat IDs', () => {\n    const result = extractChatId('relay.human.telegram.67890');\n    expect(result).toBe(67890);\n  });\n\n  it('returns null for non-integer IDs', () => {\n    const result = extractChatId('relay.human.telegram.abc');\n    expect(result).toBeNull();\n  });\n});\n```\n\nNote: `extractChatId` is a module-level function (not exported). If it is not exported, the tests should exercise it indirectly via the adapter's `handleOutbound` method or the subscription callback, using subjects with the problematic patterns. If it is exported (possibly via `@internal` tag), test it directly.\n\n**Acceptance criteria:**\n- `extractChatId` returns `null` for subjects that would produce chat ID 0\n- Valid chat IDs (positive integers) still work correctly\n- Group and DM subject formats both handled correctly\n- Existing Telegram adapter tests pass",
      "activeForm": "Fixing extractChatId to reject invalid chat ID 0",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1", "1.3", "1.4"]
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Critical Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P1] Add SubscriptionRegistry.clear() and call from RelayCore.close()",
      "description": "The `SubscriptionRegistry` has no `clear()` method, so when `RelayCore.close()` is called, all subscriptions leak and are never cleaned up. This can cause handlers to fire on stale data after a relay instance is closed.\n\n**File 1:** `packages/relay/src/subscription-registry.ts`\n\nAdd a `clear()` method that empties the in-memory subscription map and persists the empty state:\n\n```typescript\n/**\n * Remove all subscriptions and persist the empty state.\n *\n * Called during RelayCore shutdown to prevent leaked handlers.\n */\nclear(): void {\n  this.subscriptions.clear();\n  this.persistSubscriptions();\n}\n```\n\nThis should be added as a public method on the `SubscriptionRegistry` class. The `persistSubscriptions()` method already exists and writes the current state of `this.subscriptions` to `subscriptions.json`.\n\n**File 2:** `packages/relay/src/relay-core.ts`\n\nIn the `close()` method, call `this.subscriptionRegistry.clear()` before closing watchers:\n\n```typescript\nasync close(): Promise<void> {\n  if (this.closed) return;\n  this.closed = true;\n\n  // Clear all subscriptions to prevent leaked handlers\n  this.subscriptionRegistry.clear();\n\n  // Stop all endpoint watchers\n  await this.watcherManager.closeAll();\n\n  // Stop config watcher\n  if (this.configWatcher) {\n    await this.configWatcher.close();\n    this.configWatcher = null;\n  }\n\n  // Close access control (stops its chokidar watcher)\n  this.accessControl.close();\n}\n```\n\n**Testing:** Add test in `packages/relay/src/__tests__/subscription-registry.test.ts` (create if needed):\n\n```typescript\ndescribe('SubscriptionRegistry.clear()', () => {\n  it('removes all subscriptions', () => {\n    const registry = new SubscriptionRegistry(testDataDir);\n    registry.subscribe('relay.test.>', handler1);\n    registry.subscribe('relay.other.*', handler2);\n    expect(registry.list().length).toBe(2);\n\n    registry.clear();\n    expect(registry.list().length).toBe(0);\n  });\n\n  it('persists empty state to disk', () => {\n    const registry = new SubscriptionRegistry(testDataDir);\n    registry.subscribe('relay.test.>', handler1);\n    registry.clear();\n\n    // Create a new registry from the same directory — should have 0 subscriptions\n    const registry2 = new SubscriptionRegistry(testDataDir);\n    expect(registry2.list().length).toBe(0);\n  });\n});\n```\n\n**Acceptance criteria:**\n- `SubscriptionRegistry` has a public `clear()` method\n- `clear()` empties `this.subscriptions` and persists to disk\n- `RelayCore.close()` calls `this.subscriptionRegistry.clear()` before other cleanup\n- Existing relay tests pass\n- `pnpm typecheck` passes",
      "activeForm": "Adding subscription registry cleanup on close",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1", "1.2", "1.4"]
    },
    {
      "id": "1.4",
      "phase": 1,
      "phaseName": "Critical Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P1] Wrap BindingRouter saveSessionMap calls in error handling",
      "description": "The `BindingRouter` calls `saveSessionMap()` in two places (after creating a new session mapping and during `cleanupOrphanedSessions()`). If either call fails (e.g., disk full, permission error), the error propagates up and silently loses the in-memory session mapping that was just created.\n\n**File:** `apps/server/src/services/relay/binding-router.ts`\n\nWrap both `saveSessionMap()` call sites in try/catch blocks with warning logs:\n\n**Call site 1** — In the session creation flow (around line 181):\n\n```typescript\nthis.sessionMap.set(key, sessionId);\nthis.evictOldestSessions();\ntry {\n  await this.saveSessionMap();\n} catch (err) {\n  logger.warn('BindingRouter: failed to persist session map, will retry on next write', err);\n}\nreturn sessionId;\n```\n\n**Call site 2** — In `cleanupOrphanedSessions()` (around line 95):\n\n```typescript\nif (removed > 0) {\n  try {\n    await this.saveSessionMap();\n  } catch (err) {\n    logger.warn('BindingRouter: failed to persist session map after cleanup, will retry on next write', err);\n  }\n  logger.info(`Cleaned up ${removed} orphaned session mapping(s)`);\n}\n```\n\n**Call site 3** — In `shutdown()` (around line 299):\n\n```typescript\nasync shutdown(): Promise<void> {\n  this.unsubscribe?.();\n  try {\n    await this.saveSessionMap();\n  } catch (err) {\n    logger.warn('BindingRouter: failed to persist session map on shutdown', err);\n  }\n  this.sessionMap.clear();\n}\n```\n\nThe key principle: session map persistence is best-effort. The in-memory map is the source of truth during runtime; the JSON file is only for recovery across restarts. A failed persist should never cause the session creation to fail.\n\n**Testing:** Add or update tests in `apps/server/src/services/relay/__tests__/binding-router.test.ts`:\n\n```typescript\nit('does not throw when saveSessionMap fails', async () => {\n  // Mock fs writeFile to reject\n  vi.mocked(writeFile).mockRejectedValueOnce(new Error('ENOSPC: no space left'));\n\n  // Should not throw — the session should still be created in memory\n  await expect(router.routeMessage(testEnvelope)).resolves.not.toThrow();\n});\n```\n\n**Acceptance criteria:**\n- All three `saveSessionMap()` call sites are wrapped in try/catch\n- Errors are logged at `warn` level with descriptive messages\n- Session creation succeeds even when persist fails\n- Existing binding-router tests pass\n- `pnpm typecheck` passes",
      "activeForm": "Adding error handling to BindingRouter session persist calls",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1", "1.2", "1.3"]
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "High-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P2] Mask sensitive config in adapter-manager getAdapter()",
      "description": "The `getAdapter()` method in `AdapterManager` returns raw adapter config including sensitive fields (tokens, secrets). The `listAdapters()` method already masks sensitive fields, but `getAdapter()` does not, creating an inconsistency where a single-adapter lookup exposes secrets.\n\n**File:** `apps/server/src/services/relay/adapter-manager.ts`\n\nUpdate the `getAdapter()` method to mask sensitive fields before returning, matching the behavior of `listAdapters()`:\n\n```typescript\ngetAdapter(id: string): { config: AdapterConfig; status: AdapterStatus } | undefined {\n  const config = this.configs.find((c) => c.id === id);\n  if (!config) return undefined;\n\n  const adapter = this.registry.get(id);\n  const status: AdapterStatus = adapter?.getStatus() ?? defaultAdapterStatus();\n  const manifest = this.manifests.get(config.type);\n  const maskedConfig = {\n    ...config,\n    config: maskSensitiveFields(\n      config.config as Record<string, unknown>,\n      manifest,\n    ),\n  };\n  return { config: maskedConfig, status };\n}\n```\n\nThe `maskSensitiveFields` function is already imported from `./adapter-config.js`. The `this.manifests` map holds `AdapterManifest` objects keyed by adapter type. The manifest's `configSchema` array identifies which fields are `sensitive: true`.\n\n**Testing:** Add test in the existing adapter-manager test file:\n\n```typescript\ndescribe('getAdapter', () => {\n  it('masks sensitive config fields', () => {\n    // Setup: register an adapter with a sensitive token field\n    const result = manager.getAdapter('telegram-1');\n    expect(result).toBeDefined();\n    // The 'token' field in TelegramAdapterConfig is marked sensitive\n    expect(result!.config.config.token).toBe('****');\n  });\n\n  it('returns same masked format as listAdapters()', () => {\n    const single = manager.getAdapter('telegram-1');\n    const list = manager.listAdapters();\n    const fromList = list.find(a => a.config.id === 'telegram-1');\n    expect(single!.config.config).toEqual(fromList!.config.config);\n  });\n});\n```\n\n**Acceptance criteria:**\n- `getAdapter()` returns masked config matching `listAdapters()` output\n- Sensitive fields (token, secret, password) are replaced with `'****'`\n- Non-sensitive fields are returned unchanged\n- Existing adapter-manager tests pass\n- `pnpm typecheck` passes",
      "activeForm": "Masking sensitive config in getAdapter API",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["2.2", "2.3", "2.4", "2.5", "2.6", "2.7", "2.8", "2.9", "2.10"]
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "High-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P2] Consolidate duplicated types — eliminate relay types.ts / shared schema drift",
      "description": "Eight interfaces in `packages/relay/src/types.ts` are manually duplicated from Zod schemas in `packages/shared/src/relay-schemas.ts`. They have already diverged (e.g., `AdapterStatus` in relay is missing fields present in the shared schema). Fix by importing Zod-inferred types and removing manual duplicates.\n\n**File 1:** `packages/shared/src/relay-schemas.ts`\n\nRemove the `Z` suffix from all inferred type names. Add deprecated re-exports for backward compatibility:\n\n```typescript\n// Before:\nexport type TelegramAdapterConfigZ = z.infer<typeof TelegramAdapterConfigSchema>;\nexport type WebhookAdapterConfigZ = z.infer<typeof WebhookAdapterConfigSchema>;\nexport type AdapterConfigZ = z.infer<typeof AdapterConfigSchema>;\nexport type AdapterStatusZ = z.infer<typeof AdapterStatusSchema>;\n\n// After:\nexport type TelegramAdapterConfig = z.infer<typeof TelegramAdapterConfigSchema>;\nexport type WebhookAdapterConfig = z.infer<typeof WebhookAdapterConfigSchema>;\nexport type AdapterConfig = z.infer<typeof AdapterConfigSchema>;\nexport type AdapterStatus = z.infer<typeof AdapterStatusSchema>;\n\n/** @deprecated Use TelegramAdapterConfig */\nexport type TelegramAdapterConfigZ = TelegramAdapterConfig;\n/** @deprecated Use WebhookAdapterConfigZ */\nexport type WebhookAdapterConfigZ = WebhookAdapterConfig;\n/** @deprecated Use AdapterConfig */\nexport type AdapterConfigZ = AdapterConfig;\n/** @deprecated Use AdapterStatus */\nexport type AdapterStatusZ = AdapterStatus;\n```\n\nDo this for all types that currently have the `Z` suffix: `RateLimitConfig`, `CircuitBreakerConfig`, `BackpressureConfig`, `ReliabilityConfig`, `TelegramAdapterConfig`, `WebhookAdapterConfig`, `AdapterConfig`, `AdapterStatus`.\n\n**File 2:** `packages/relay/src/types.ts`\n\nReplace all manually duplicated interfaces with imports from the shared schema:\n\n```typescript\n// Import types derived from Zod schemas — single source of truth\nimport type {\n  RateLimitConfig,\n  CircuitBreakerConfig,\n  BackpressureConfig,\n  ReliabilityConfig,\n  TelegramAdapterConfig,\n  WebhookAdapterConfig,\n  AdapterConfig,\n} from '@dorkos/shared/relay-schemas';\n\n// Re-export for consumers within the relay package\nexport type { RateLimitConfig, CircuitBreakerConfig, BackpressureConfig, ReliabilityConfig };\nexport type { TelegramAdapterConfig, WebhookAdapterConfig, AdapterConfig };\n\n// AdapterStatus: relay's internal version may be narrower\n// Keep as a separate pick type to avoid exposing server-enriched fields\nimport type { AdapterStatus as AdapterStatusFull } from '@dorkos/shared/relay-schemas';\nexport type AdapterStatus = Pick<AdapterStatusFull, 'state' | 'messageCount' | 'errorCount' | 'lastError' | 'lastErrorAt' | 'startedAt'>;\n```\n\nRemove the manually-defined `RateLimitConfig`, `CircuitBreakerConfig`, `BackpressureConfig`, `ReliabilityConfig`, `TelegramAdapterConfig`, `WebhookAdapterConfig`, and `AdapterConfig` interfaces from `types.ts`.\n\n**File 3:** Update all consumers in the relay package that import these types to ensure they still resolve correctly. Since the types are re-exported from `types.ts`, most consumers should work without changes. Verify with `pnpm typecheck`.\n\n**Testing:**\n- Run `pnpm typecheck` — all packages must compile without errors\n- Run `pnpm test -- --run` — no regressions\n- Verify that `AdapterStatus` fields in relay internals match what's expected\n\n**Acceptance criteria:**\n- No manually duplicated type interfaces in `packages/relay/src/types.ts` for types that have Zod schema equivalents\n- All types import from `@dorkos/shared/relay-schemas` as the single source of truth\n- Deprecated `*Z` re-exports exist in `relay-schemas.ts` for backward compatibility\n- `pnpm typecheck` passes across all packages\n- `pnpm build` succeeds",
      "activeForm": "Consolidating duplicated type interfaces with Zod schema imports",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["2.1", "2.3", "2.4", "2.5", "2.6", "2.7", "2.8", "2.9", "2.10"]
    },
    {
      "id": "2.3",
      "phase": 2,
      "phaseName": "High-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P2] Extract shared payload extraction utility",
      "description": "Payload extraction logic (checking for `content`, `text` string fields, falling back to JSON.stringify) is duplicated in `telegram-adapter.ts` and `claude-code-adapter.ts`. Extract into a shared utility.\n\n**New file:** `packages/relay/src/lib/payload-utils.ts`\n\n```typescript\n/**\n * Payload extraction utilities for Relay adapters.\n *\n * @module relay/lib/payload-utils\n */\n\n/**\n * Extract text content from an unknown Relay envelope payload.\n *\n * Checks for `content` and `text` string fields, falls back to JSON serialization.\n *\n * @param payload - The unknown payload from a RelayEnvelope\n */\nexport function extractPayloadContent(payload: unknown): string {\n  if (typeof payload === 'string') return payload;\n  if (payload !== null && typeof payload === 'object') {\n    const obj = payload as Record<string, unknown>;\n    if (typeof obj.content === 'string') return obj.content;\n    if (typeof obj.text === 'string') return obj.text;\n  }\n  try {\n    return JSON.stringify(payload);\n  } catch {\n    return '[unserializable payload]';\n  }\n}\n```\n\n**File 2:** `packages/relay/src/adapters/telegram-adapter.ts`\n\nFind the local payload extraction logic (look for patterns like `payload.content || payload.text || JSON.stringify(payload)`) and replace with:\n\n```typescript\nimport { extractPayloadContent } from '../lib/payload-utils.js';\n\n// In the outbound handler:\nconst text = extractPayloadContent(envelope.payload);\n```\n\nRemove the local implementation.\n\n**File 3:** `packages/relay/src/adapters/claude-code-adapter.ts`\n\nSame replacement — find the duplicated payload extraction and replace with the import:\n\n```typescript\nimport { extractPayloadContent } from '../lib/payload-utils.js';\n\n// In the message handler:\nconst content = extractPayloadContent(envelope.payload);\n```\n\nRemove the local implementation.\n\n**New test file:** `packages/relay/src/lib/__tests__/payload-utils.test.ts`\n\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { extractPayloadContent } from '../payload-utils.js';\n\ndescribe('extractPayloadContent', () => {\n  it('returns string payload directly', () => {\n    expect(extractPayloadContent('hello')).toBe('hello');\n  });\n\n  it('extracts content field from object', () => {\n    expect(extractPayloadContent({ content: 'hello', other: 123 })).toBe('hello');\n  });\n\n  it('extracts text field from object when content is missing', () => {\n    expect(extractPayloadContent({ text: 'hello', other: 123 })).toBe('hello');\n  });\n\n  it('prefers content over text', () => {\n    expect(extractPayloadContent({ content: 'a', text: 'b' })).toBe('a');\n  });\n\n  it('falls back to JSON.stringify for other objects', () => {\n    expect(extractPayloadContent({ foo: 'bar' })).toBe('{\"foo\":\"bar\"}');\n  });\n\n  it('handles null payload', () => {\n    expect(extractPayloadContent(null)).toBe('null');\n  });\n\n  it('handles undefined payload', () => {\n    expect(extractPayloadContent(undefined)).toBe(undefined); // JSON.stringify(undefined) returns undefined\n  });\n\n  it('handles unserializable payload (circular reference)', () => {\n    const obj: Record<string, unknown> = {};\n    obj.self = obj;\n    expect(extractPayloadContent(obj)).toBe('[unserializable payload]');\n  });\n\n  it('handles number payload', () => {\n    expect(extractPayloadContent(42)).toBe('42');\n  });\n});\n```\n\n**Acceptance criteria:**\n- `extractPayloadContent` lives in `packages/relay/src/lib/payload-utils.ts`\n- Both `telegram-adapter.ts` and `claude-code-adapter.ts` import from the shared utility\n- No duplicated payload extraction logic remains in either adapter\n- All new tests pass\n- Existing adapter tests pass\n- `pnpm typecheck` passes",
      "activeForm": "Extracting shared payload extraction utility from adapters",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["2.1", "2.2", "2.4", "2.5", "2.6", "2.7", "2.8", "2.9", "2.10"]
    },
    {
      "id": "2.4",
      "phase": 2,
      "phaseName": "High-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P2] Replace BindingStore writeGeneration with mtime-based self-write detection",
      "description": "The `BindingStore` uses a `writeGeneration` counter to detect self-writes (to avoid reloading when chokidar triggers on our own write). This is fragile and can miss edge cases. Replace with mtime-based detection.\n\n**File:** `apps/server/src/services/relay/binding-store.ts`\n\n**Step 1:** Replace the `writeGeneration` counter with `lastWriteMtime`:\n\n```typescript\n// Remove:\nprivate writeGeneration = 0;\n\n// Add:\nprivate lastWriteMtime: number | null = null;\n```\n\n**Step 2:** Update the `save()` method to record the mtime after writing:\n\n```typescript\nprivate async save(): Promise<void> {\n  // ... existing atomic write logic (write to .tmp, rename) ...\n  const stat = await fsp.stat(this.filePath);\n  this.lastWriteMtime = stat.mtimeMs;\n}\n```\n\n**Step 3:** Update the chokidar change handler to check mtime:\n\n```typescript\nprivate async handleFileChange(): Promise<void> {\n  try {\n    const stat = await fsp.stat(this.filePath);\n    if (this.lastWriteMtime !== null && stat.mtimeMs === this.lastWriteMtime) {\n      // Our own write — skip reload\n      this.lastWriteMtime = null;\n      return;\n    }\n    await this.load();\n  } catch (err) {\n    logger.warn('BindingStore: failed to handle file change', err);\n  }\n}\n```\n\n**Step 4:** Remove any references to `writeGeneration` in the change handler and `save()` method.\n\n**Testing:** Update existing binding-store tests:\n\n```typescript\nit('skips reload on self-write (mtime match)', async () => {\n  const store = new BindingStore(testDir);\n  await store.add(testBinding);\n  // The chokidar handler should detect our own write via mtime and skip reload\n  // Verify load() was not called after save()\n});\n\nit('reloads on external file change', async () => {\n  const store = new BindingStore(testDir);\n  // Simulate external write by directly modifying the file\n  await fsp.writeFile(bindingsPath, JSON.stringify([newBinding]));\n  // Wait for chokidar to trigger\n  // Verify the store now contains the externally written binding\n});\n```\n\n**Acceptance criteria:**\n- `writeGeneration` counter is removed\n- Self-write detection uses `stat.mtimeMs` comparison\n- External file changes still trigger reload\n- Self-writes do not trigger unnecessary reloads\n- Existing binding-store tests pass\n- `pnpm typecheck` passes",
      "activeForm": "Replacing BindingStore writeGeneration with mtime-based detection",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["2.1", "2.2", "2.3", "2.5", "2.6", "2.7", "2.8", "2.9", "2.10"]
    },
    {
      "id": "2.5",
      "phase": 2,
      "phaseName": "High-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P2] Add DeliveryPipeline timer cleanup and close() method",
      "description": "The `DeliveryPipeline` creates dedup timers via `setTimeout` that are never cleaned up, preventing clean process exit (Node stays alive waiting for timers).\n\n**File:** `packages/relay/src/delivery-pipeline.ts`\n\n**Step 1:** Add a `Set` to track active timers:\n\n```typescript\nprivate readonly dedupTimers = new Set<NodeJS.Timeout>();\n```\n\n**Step 2:** In the `dispatchToSubscribers` method (or wherever the dedup timer is created), register the timer in the set and remove it on expiry:\n\n```typescript\n// Find the existing setTimeout for dedup cleanup:\nconst timer = setTimeout(() => {\n  this.recentlyDispatched.delete(messageId);\n  this.dedupTimers.delete(timer);\n}, DISPATCH_DEDUP_TTL_MS);\nthis.dedupTimers.add(timer);\n```\n\n**Step 3:** Add a `close()` method:\n\n```typescript\n/**\n * Clean up all pending dedup timers. Call during RelayCore shutdown.\n */\nclose(): void {\n  for (const timer of this.dedupTimers) clearTimeout(timer);\n  this.dedupTimers.clear();\n  this.recentlyDispatched.clear();\n}\n```\n\n**File 2:** `packages/relay/src/relay-core.ts`\n\nIn the `close()` method, call `this.deliveryPipeline.close()` before or alongside the watcher cleanup:\n\n```typescript\nasync close(): Promise<void> {\n  if (this.closed) return;\n  this.closed = true;\n\n  this.subscriptionRegistry.clear();  // from task 1.3\n  this.deliveryPipeline.close();      // NEW: clean up dedup timers\n\n  await this.watcherManager.closeAll();\n  // ... rest of cleanup\n}\n```\n\n**Testing:** Add test for the `close()` method:\n\n```typescript\ndescribe('DeliveryPipeline.close()', () => {\n  it('clears all pending dedup timers', () => {\n    const pipeline = new DeliveryPipeline(/* deps */);\n    // Trigger a dispatch to create a dedup timer\n    pipeline.dispatchToSubscribers(testEnvelope, [testHandler]);\n\n    // Timer should be tracked\n    pipeline.close();\n    // After close, all timers should be cleared\n    // Node should be able to exit cleanly\n  });\n});\n```\n\n**Acceptance criteria:**\n- `DeliveryPipeline` tracks all dedup timers in a `Set`\n- `close()` clears all timers and the dedup set\n- `RelayCore.close()` calls `this.deliveryPipeline.close()`\n- Node process can exit cleanly after `RelayCore.close()`\n- Existing relay tests pass\n- `pnpm typecheck` passes",
      "activeForm": "Adding DeliveryPipeline timer cleanup and close method",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["2.1", "2.2", "2.3", "2.4", "2.6", "2.7", "2.8", "2.9", "2.10"]
    },
    {
      "id": "2.6",
      "phase": 2,
      "phaseName": "High-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P2] Standardize adapter status mutation to immutable spread pattern",
      "description": "The `webhook-adapter.ts` and `claude-code-adapter.ts` use in-place mutation for status updates (`this.status.state = ...`, `this.status.messageCount.inbound++`), while `telegram-adapter.ts` uses immutable spread. Standardize all adapters to the immutable pattern for consistency and to avoid shared-reference bugs.\n\n**File 1:** `packages/relay/src/adapters/webhook-adapter.ts`\n\nFind and replace all in-place status mutations with immutable spread:\n\n```typescript\n// Before:\nthis.status.state = 'connected';\n// After:\nthis.status = { ...this.status, state: 'connected' };\n\n// Before:\nthis.status.state = 'stopping';\n// After:\nthis.status = { ...this.status, state: 'stopping' };\n\n// Before:\nthis.status.state = 'disconnected';\n// After:\nthis.status = { ...this.status, state: 'disconnected' };\n\n// Before:\nthis.status.messageCount.inbound++;\n// After:\nthis.status = {\n  ...this.status,\n  messageCount: {\n    ...this.status.messageCount,\n    inbound: this.status.messageCount.inbound + 1,\n  },\n};\n\n// Before:\nthis.status.messageCount.outbound++;\n// After:\nthis.status = {\n  ...this.status,\n  messageCount: {\n    ...this.status.messageCount,\n    outbound: this.status.messageCount.outbound + 1,\n  },\n};\n\n// Before:\nthis.status.errorCount++;\n// After:\nthis.status = { ...this.status, errorCount: this.status.errorCount + 1 };\n\n// Before:\nthis.status.lastError = message;\nthis.status.lastErrorAt = new Date().toISOString();\n// After:\nthis.status = {\n  ...this.status,\n  lastError: message,\n  lastErrorAt: new Date().toISOString(),\n};\n```\n\n**File 2:** `packages/relay/src/adapters/claude-code-adapter.ts`\n\nApply the same immutable spread pattern to all status mutations in this adapter.\n\n**Testing:**\n- Existing adapter tests should continue to pass since `getStatus()` returns the current `this.status` reference\n- Run `pnpm test -- --run` to verify no regressions\n\n**Acceptance criteria:**\n- All status mutations in `webhook-adapter.ts` use immutable spread\n- All status mutations in `claude-code-adapter.ts` use immutable spread\n- No in-place property assignment on `this.status` or its nested objects in either adapter\n- All three adapters (telegram, webhook, claude-code) follow the same mutation pattern\n- Existing adapter tests pass\n- `pnpm typecheck` passes",
      "activeForm": "Standardizing adapter status mutation to immutable spread pattern",
      "size": "small",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["2.1", "2.2", "2.3", "2.4", "2.5", "2.7", "2.8", "2.9", "2.10"]
    },
    {
      "id": "2.7",
      "phase": 2,
      "phaseName": "High-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P2] Fix O(n*m) dead-letter lookup in conversations endpoint",
      "description": "The conversations endpoint in `routes/relay.ts` performs O(n*m) dead-letter lookups by calling `.find()` inside a loop over messages. Replace with a pre-built Map for O(1) lookups. Also extract the conversation-building logic into a helper function to keep the route handler under 50 lines.\n\n**File:** `apps/server/src/routes/relay.ts`\n\nFind the conversations endpoint handler and refactor:\n\n**Step 1:** Build a lookup Map once from the dead-letter list:\n\n```typescript\n// Build lookup map once — O(n) instead of O(n*m) per message\nconst deadLetterMap = new Map(deadLetters.map(dl => [dl.messageId, dl]));\n```\n\n**Step 2:** Replace `.find()` calls with Map lookups:\n\n```typescript\n// Before:\nconst dl = deadLetters.find(d => d.messageId === messageId);\n// After:\nconst dl = deadLetterMap.get(messageId);\n```\n\n**Step 3:** Extract the conversation-building logic into a helper function:\n\n```typescript\n/** Build conversation objects from messages and dead-letter data. */\nfunction buildConversations(\n  messages: RelayEnvelope[],\n  deadLetterMap: Map<string, DeadLetterEntry>,\n): Conversation[] {\n  // ... conversation grouping and building logic moved here\n}\n```\n\nThis keeps the route handler thin (validate input, call helper, return response) and makes the conversation logic testable in isolation.\n\n**Testing:**\n- Existing relay route tests should continue to pass\n- Optionally add a unit test for `buildConversations()` with a dead-letter that matches a message ID\n\n**Acceptance criteria:**\n- Dead-letter lookups use `Map.get()` instead of `Array.find()`\n- Conversation-building logic is extracted into a named helper function\n- Route handler body is under 50 lines\n- Existing tests pass\n- `pnpm typecheck` passes",
      "activeForm": "Optimizing dead-letter lookup to O(1) with Map",
      "size": "small",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["2.1", "2.2", "2.3", "2.4", "2.5", "2.6", "2.8", "2.9", "2.10"]
    },
    {
      "id": "2.8",
      "phase": 2,
      "phaseName": "High-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P2] Consolidate TraceStoreLike interface into relay types.ts",
      "description": "Two separate `TraceStoreLike` interfaces exist: one in `packages/relay/src/types.ts` and another in `packages/relay/src/adapters/claude-code-adapter.ts`. They should be a single interface.\n\n**File 1:** `packages/relay/src/types.ts`\n\nEnsure the `TraceStoreLike` interface has both methods (check which methods each definition has and merge):\n\n```typescript\n/** Minimal interface for trace storage used by adapters and delivery pipeline. */\nexport interface TraceStoreLike {\n  insertSpan(span: Record<string, unknown>): void;\n  updateSpan(messageId: string, update: Record<string, unknown>): void;\n}\n```\n\n**File 2:** `packages/relay/src/adapters/claude-code-adapter.ts`\n\nRemove the local `TraceStoreLike` interface definition and import from `types.ts`:\n\n```typescript\n// Remove local definition:\n// interface TraceStoreLike { ... }\n\n// Import from types:\nimport type { TraceStoreLike } from '../types.js';\n```\n\n**File 3:** Verify that all other files importing `TraceStoreLike` use the canonical `types.ts` definition. Check:\n- `packages/relay/src/adapter-delivery.ts`\n- `packages/relay/src/relay-core.ts`\n- `apps/server/src/services/relay/adapter-manager.ts`\n\n**Testing:**\n- `pnpm typecheck` passes\n- Existing tests pass\n\n**Acceptance criteria:**\n- Single `TraceStoreLike` interface in `packages/relay/src/types.ts`\n- No duplicate definition in `claude-code-adapter.ts` or any other file\n- All consumers import from `types.ts` (or from the barrel `index.ts`)\n- `pnpm typecheck` passes",
      "activeForm": "Consolidating TraceStoreLike interface into single definition",
      "size": "small",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["2.1", "2.2", "2.3", "2.4", "2.5", "2.6", "2.7", "2.9", "2.10"]
    },
    {
      "id": "2.9",
      "phase": 2,
      "phaseName": "High-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P2] Add SSE backpressure for slow relay clients",
      "description": "The Relay SSE stream endpoint writes to the response without checking if the client can keep up. If a client falls behind, writes accumulate in Node's buffer and can cause memory bloat.\n\n**File:** `apps/server/src/routes/relay.ts`\n\nFind the SSE stream endpoint (the one that calls `relayCore.subscribe()` and writes `data:` lines to `res`) and add backpressure handling:\n\n```typescript\nconst unsubMessages = relayCore.subscribe(pattern, (envelope) => {\n  if (res.writableEnded) return;\n  const data = `data: ${JSON.stringify(envelope)}\\n\\n`;\n  const canContinue = res.write(data);\n  if (!canContinue) {\n    // Client buffer is full — delivery of subsequent events will be\n    // naturally paused because `res.write()` returns false. Node will\n    // buffer in memory but the drain event lets us know when the client\n    // has caught up. We don't need to explicitly pause/resume the\n    // subscription because the relay subscription is callback-based;\n    // we just skip logging here to avoid noise.\n    res.once('drain', () => {\n      // Client caught up — next write will succeed normally\n    });\n  }\n});\n```\n\nThe key change is checking the return value of `res.write()`. When it returns `false`, the internal buffer is full. Node's built-in backpressure mechanism will handle the rest — subsequent `res.write()` calls will still buffer, but the `drain` event signals when the client has caught up.\n\nFor a more aggressive approach, you could also track a `paused` boolean and skip events while the client is behind:\n\n```typescript\nlet paused = false;\nconst unsubMessages = relayCore.subscribe(pattern, (envelope) => {\n  if (res.writableEnded || paused) return;\n  const data = `data: ${JSON.stringify(envelope)}\\n\\n`;\n  const canContinue = res.write(data);\n  if (!canContinue) {\n    paused = true;\n    res.once('drain', () => { paused = false; });\n  }\n});\n```\n\nChoose the simpler approach (checking return value, not skipping events) unless testing reveals memory pressure.\n\n**Testing:**\n- Manual test: verify SSE stream still works for normal clients\n- Existing relay route tests should pass\n\n**Acceptance criteria:**\n- SSE write checks return value of `res.write()`\n- Slow clients don't cause unbounded memory growth\n- Normal-speed clients see no behavior change\n- Existing tests pass\n- `pnpm typecheck` passes",
      "activeForm": "Adding SSE backpressure handling for slow relay clients",
      "size": "small",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["2.1", "2.2", "2.3", "2.4", "2.5", "2.6", "2.7", "2.8", "2.10"]
    },
    {
      "id": "2.10",
      "phase": 2,
      "phaseName": "High-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P2] Fix adapter-delivery timer initialization",
      "description": "In `adapter-delivery.ts`, the timeout timer variable may be used before initialization in the `finally` block if an error occurs before the timer is set up.\n\n**File:** `packages/relay/src/adapter-delivery.ts`\n\nFind the timer variable and ensure it's initialized as `undefined` with proper type, and the `finally` block checks for it:\n\n```typescript\nlet timer: NodeJS.Timeout | undefined;\ntry {\n  timer = setTimeout(() => {\n    // ... timeout logic\n  }, timeoutMs);\n\n  // ... delivery logic\n} finally {\n  if (timer) clearTimeout(timer);\n}\n```\n\nThe fix ensures:\n1. `timer` is typed as `NodeJS.Timeout | undefined` (not just `NodeJS.Timeout`)\n2. `timer` is initialized as `undefined` (or left unassigned)\n3. The `finally` block checks `if (timer)` before calling `clearTimeout()`\n\n**Testing:**\n- Existing adapter delivery tests should pass\n- `pnpm typecheck` passes\n\n**Acceptance criteria:**\n- Timer variable is properly typed as `NodeJS.Timeout | undefined`\n- `finally` block safely checks before clearing\n- No potential `clearTimeout(undefined)` calls\n- Existing tests pass",
      "activeForm": "Fixing adapter-delivery timer initialization safety",
      "size": "small",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["2.1", "2.2", "2.3", "2.4", "2.5", "2.6", "2.7", "2.8", "2.9"]
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Medium-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P3] Extract shared mesh registration logic and toManifest helper",
      "description": "Mesh registration logic is duplicated between `registerByPath()` and `registerFromCandidate()` in `MeshCore`. The destructure pattern `const { projectPath: _p, namespace: _n, scanRoot: _s, ...manifest } = entry;` is repeated 4 times.\n\n**File:** `packages/mesh/src/mesh-core.ts`\n\n**Step 1:** Extract `registerInternal()` helper with shared write-manifest, upsert-DB, relay-bridge logic:\n\n```typescript\n/**\n * Shared registration logic for all registration paths.\n *\n * Writes the manifest to disk, upserts the registry DB, and registers\n * with Relay. If the DB upsert fails, the on-disk manifest is rolled back.\n *\n * @param projectPath - Absolute path to the agent project\n * @param manifest - The agent manifest to register\n * @param scanRoot - The scan root that discovered this agent\n */\nprivate async registerInternal(\n  projectPath: string,\n  manifest: AgentManifest,\n  scanRoot: string,\n): Promise<AgentManifest> {\n  // 1. Write manifest to disk\n  await writeManifest(projectPath, manifest);\n\n  // 2. Upsert DB with compensation (rollback on failure)\n  const entry = { ...manifest, projectPath, namespace: manifest.namespace!, scanRoot };\n  try {\n    this.registry.upsert(entry);\n  } catch (err) {\n    await removeManifest(projectPath);\n    throw err;\n  }\n\n  // 3. Register with Relay (if available) — non-fatal\n  try {\n    this.relayBridge.registerAgent(manifest);\n  } catch {\n    // Non-fatal — agent works without relay\n  }\n\n  return manifest;\n}\n```\n\n**Step 2:** Extract `toManifest()` helper to replace the 4x repeated destructure:\n\n```typescript\n/**\n * Strip internal registry fields (projectPath, namespace, scanRoot) from\n * an AgentRegistryEntry, returning a clean AgentManifest.\n */\nprivate toManifest(entry: AgentRegistryEntry): AgentManifest {\n  const { projectPath: _p, namespace: _n, scanRoot: _s, ...manifest } = entry;\n  return manifest;\n}\n```\n\n**Step 3:** Refactor `registerByPath()` and `registerFromCandidate()` to call `registerInternal()` instead of duplicating the write/upsert/relay logic.\n\n**Step 4:** Replace all 4 occurrences of the destructure pattern with `this.toManifest(entry)`.\n\n**Testing:**\n- Existing mesh-core tests should pass\n- Verify that `registerByPath()` and `registerFromCandidate()` still produce the same results\n- `pnpm typecheck` passes\n\n**Acceptance criteria:**\n- Registration logic is in a single `registerInternal()` method\n- The destructure-to-manifest pattern is in a single `toManifest()` method\n- No duplicated registration steps between `registerByPath()` and `registerFromCandidate()`\n- All occurrences of the destructure pattern use `toManifest()`\n- Existing tests pass",
      "activeForm": "Extracting shared mesh registration logic and toManifest helper",
      "size": "medium",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["3.2", "3.3", "3.4", "3.5", "3.6"]
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "Medium-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P3] Deduplicate AgentNode card header into shared component",
      "description": "The `AgentNode.tsx` component has duplicated card header/badge rendering between `DefaultCard` and `ExpandedCard` variants.\n\n**File:** `apps/client/src/layers/features/mesh/ui/AgentNode.tsx`\n\nExtract a shared `CardHeader` component that both card variants compose:\n\n```typescript\n/** Shared card header with health dot, name, and feature badges. */\nfunction CardHeader({ data, width }: { data: AgentNodeData; width: 'compact' | 'default' | 'expanded' }) {\n  const borderColor = resolveBorderColor(data);\n  const hasRelay = data.relaySubject !== null;\n  const hasPulse = (data.pulseScheduleCount ?? 0) > 0;\n\n  return (\n    <div className=\"flex items-center gap-2\">\n      {/* Health indicator dot */}\n      <span\n        className={cn(\n          'h-2 w-2 shrink-0 rounded-full',\n          data.healthStatus === 'active' ? 'bg-green-500' : 'bg-neutral-400',\n        )}\n      />\n      {/* Agent name */}\n      <span className=\"truncate font-medium\">{data.name}</span>\n      {/* Runtime badge */}\n      {data.runtime && (\n        <Badge variant=\"outline\" className=\"text-[10px]\">\n          {data.runtime}\n        </Badge>\n      )}\n      {/* Feature indicators */}\n      {hasRelay && <RelayIndicator />}\n      {hasPulse && <PulseIndicator />}\n    </div>\n  );\n}\n```\n\nUpdate `DefaultCard` and `ExpandedCard` to compose `CardHeader` instead of duplicating the header rendering. Each card variant still adds its own unique sections (expanded shows capabilities, connections, etc.).\n\nNote: The exact JSX structure depends on the current implementation. Read the existing `DefaultCard` and `ExpandedCard` components to identify the duplicated elements, then extract them.\n\n**Testing:**\n- Visual check: agent nodes should render the same way in the topology graph\n- Existing mesh component tests (if any) should pass\n- `pnpm typecheck` passes\n\n**Acceptance criteria:**\n- Common header/badge rendering is in a single `CardHeader` component\n- `DefaultCard` and `ExpandedCard` compose `CardHeader`\n- No duplicated rendering logic between the two card variants\n- Visual appearance is unchanged\n- `pnpm typecheck` passes",
      "activeForm": "Deduplicating AgentNode card header into shared component",
      "size": "small",
      "priority": "low",
      "dependencies": [],
      "parallelWith": ["3.1", "3.3", "3.4", "3.5", "3.6"]
    },
    {
      "id": "3.3",
      "phase": 3,
      "phaseName": "Medium-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P3] Fix MeshCore.getStatus() double-fetch and other mesh improvements",
      "description": "Multiple medium-severity mesh fixes grouped together because they touch the same files.\n\n**Fix 1 (M4):** `MeshCore.getStatus()` double-fetch\n\n**File:** `packages/mesh/src/mesh-core.ts`\n\nRefactor `getStatus()` to use a single `listWithHealth()` call and compute all counts from the result instead of making separate DB queries:\n\n```typescript\ngetStatus(): MeshStatus {\n  const agents = this.registry.listWithHealth();\n  const totalCount = agents.length;\n  const activeCount = agents.filter(a => a.healthStatus === 'active').length;\n  const staleCount = agents.filter(a => a.healthStatus === 'stale').length;\n  const inactiveCount = agents.filter(a => a.healthStatus === 'inactive').length;\n  const deniedCount = this.registry.listDenied().length;\n  const namespaces = [...new Set(agents.map(a => a.namespace))];\n\n  return {\n    totalAgents: totalCount,\n    activeAgents: activeCount,\n    staleAgents: staleCount,\n    inactiveAgents: inactiveCount,\n    deniedPaths: deniedCount,\n    namespaces,\n  };\n}\n```\n\n**Fix 2 (M5):** Discovery cache invalidation\n\n**File:** `apps/client/src/layers/entities/mesh/model/use-mesh-discover.ts`\n\nAdd `onSuccess` handler to invalidate the agents query cache after discovery completes:\n\n```typescript\nimport { useQueryClient } from '@tanstack/react-query';\n\nexport function useDiscoverAgents() {\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: (opts: { roots: string[]; maxDepth?: number }) =>\n      transport.discoverMeshAgents(opts.roots, opts.maxDepth),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['mesh', 'agents'] });\n    },\n  });\n}\n```\n\n**Fix 3 (M6):** callerNamespace routing\n\n**File:** `apps/server/src/routes/mesh.ts`\n\nIn the `GET /agents` handler, route the `callerNamespace` query param through `meshCore.list()` which supports namespace filtering, instead of `listWithHealth()` which ignores it:\n\nFind the current implementation and ensure namespace filtering works correctly with the health-enriched listing.\n\n**Testing:**\n- `pnpm typecheck` passes\n- Existing mesh tests pass\n- Verify `getStatus()` produces the same results with fewer DB calls\n\n**Acceptance criteria:**\n- `getStatus()` makes a single `listWithHealth()` call instead of multiple queries\n- Discovery mutation invalidates the `['mesh', 'agents']` query key\n- `callerNamespace` filtering works correctly in `GET /agents`\n- All existing tests pass",
      "activeForm": "Fixing MeshCore double-fetch and mesh query improvements",
      "size": "medium",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["3.1", "3.2", "3.4", "3.5", "3.6"]
    },
    {
      "id": "3.4",
      "phase": 3,
      "phaseName": "Medium-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P3] Schema improvements — AgentHealthStatus, UpdateAgentRequest, RelayBudget, Z suffix removal",
      "description": "Multiple schema-level improvements that touch `packages/shared/src/` files.\n\n**Fix 1 (M9):** Add 'unreachable' to AgentHealthStatus\n\n**File:** `packages/shared/src/mesh-schemas.ts`\n\n```typescript\n// Before:\nexport const AgentHealthStatusSchema = z.enum(['active', 'inactive', 'stale']);\n// After:\nexport const AgentHealthStatusSchema = z.enum(['active', 'inactive', 'stale', 'unreachable']);\n```\n\n**Fix 2 (M14):** Derive UpdateAgentRequestSchema from AgentManifestSchema\n\n**File:** `packages/shared/src/mesh-schemas.ts`\n\nReplace the manually-defined `UpdateAgentRequestSchema` with one derived from `AgentManifestSchema`:\n\n```typescript\nexport const UpdateAgentRequestSchema = AgentManifestSchema.pick({\n  name: true,\n  description: true,\n  capabilities: true,\n  persona: true,\n  personaEnabled: true,\n  color: true,\n  icon: true,\n}).partial();\n```\n\nVerify that this produces the same shape as the current manual definition. If the current definition has additional fields, include them in the `.pick()` call.\n\n**Fix 3 (M18):** Add TTL minimum to RelayBudgetSchema\n\n**File:** `packages/shared/src/relay-schemas.ts`\n\nFind the `ttl` field in `RelayBudgetSchema` and add `.min(0)`:\n\n```typescript\nttl: z.number().int().min(0).openapi({ description: 'Absolute expiry timestamp (ms since epoch)' }),\n```\n\n**Fix 4 (M7):** Remove Z suffix from Zod types (this may already be handled by task 2.2, but ensure deprecated re-exports are in place).\n\nIf task 2.2 has not yet handled the `Z` suffix removal in `relay-schemas.ts`, do it here. If it has, verify the deprecated re-exports exist.\n\n**Testing:**\n- `pnpm typecheck` passes across all packages (especially server, client, relay, mesh, shared)\n- `pnpm build` succeeds\n- Existing tests pass\n- Verify the new 'unreachable' health status is accepted by all consumers\n\n**Acceptance criteria:**\n- `AgentHealthStatusSchema` includes 'unreachable'\n- `UpdateAgentRequestSchema` is derived from `AgentManifestSchema.pick().partial()`\n- `RelayBudgetSchema.ttl` has `.min(0)` validation\n- All Z-suffix types have deprecated re-exports\n- `pnpm typecheck` and `pnpm build` pass",
      "activeForm": "Improving shared schemas with health status, derived types, and budget validation",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["2.2"],
      "parallelWith": ["3.1", "3.2", "3.3", "3.5", "3.6"]
    },
    {
      "id": "3.5",
      "phase": 3,
      "phaseName": "Medium-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P3] Telegram adapter improvements — webhook cleanup, max reconnect logging, caption-only tests",
      "description": "Three related Telegram adapter improvements grouped together.\n\n**Fix 1 (M8):** Telegram webhook cleanup on stop\n\n**File:** `packages/relay/src/adapters/telegram-adapter.ts`\n\nIn the `stop()` method, add a `deleteWebhook()` call when the adapter was running in webhook mode:\n\n```typescript\nasync stop(): Promise<void> {\n  if (this.bot === null) return;\n  this.status = { ...this.status, state: 'stopping' };\n\n  // Delete webhook from Telegram's side to prevent stale updates\n  if (this.config.mode === 'webhook') {\n    try {\n      await this.bot.api.deleteWebhook();\n    } catch {\n      // Best-effort — bot may already be unreachable\n    }\n  }\n\n  // ... rest of existing stop() logic\n}\n```\n\n**Fix 2 (M15):** Log terminal state on max reconnect exhaustion\n\n**File:** `packages/relay/src/adapters/telegram-adapter.ts`\n\nIn the `handlePollingError()` method (or wherever reconnect attempts are tracked), add a terminal status message when max attempts are exhausted:\n\n```typescript\nprivate handlePollingError(err: unknown): void {\n  this.recordError(err);\n  if (this.reconnectAttempts >= TelegramAdapter.RECONNECT_DELAYS.length) {\n    this.status = {\n      ...this.status,\n      lastError: 'Max reconnection attempts exhausted — adapter will not retry',\n    };\n    return;\n  }\n  // ... rest of reconnect logic\n}\n```\n\n**Fix 3 (M20):** Add caption-only message test\n\n**File:** `packages/relay/src/__tests__/adapters/telegram-adapter.test.ts`\n\nAdd test cases:\n\n```typescript\ndescribe('caption-only messages', () => {\n  it('uses caption when text is undefined', async () => {\n    // Simulate a photo/document message with only a caption, no text field\n    const update = createMockUpdate({\n      message: {\n        chat: { id: 12345 },\n        caption: 'Photo description',\n        // text is undefined\n      },\n    });\n    // Verify the adapter publishes the caption as the payload content\n  });\n});\n```\n\n**Testing:**\n- All new and existing Telegram adapter tests pass\n- `pnpm typecheck` passes\n\n**Acceptance criteria:**\n- `stop()` calls `bot.api.deleteWebhook()` when mode is 'webhook'\n- Max reconnect exhaustion sets a descriptive `lastError` message\n- Caption-only message test exists and passes\n- Existing tests pass",
      "activeForm": "Improving Telegram adapter with webhook cleanup and reconnect logging",
      "size": "medium",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["3.1", "3.2", "3.3", "3.4", "3.6"]
    },
    {
      "id": "3.6",
      "phase": 3,
      "phaseName": "Medium-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P3] Relay route fixes — dot params, adapter error map, Pulse path matching",
      "description": "Three related relay/mesh route fixes grouped together.\n\n**Fix 1 (M13):** Fix relay route params with dots\n\n**File:** `apps/server/src/routes/relay.ts`\n\nExpress route params stop at dots by default. Relay subjects contain dots (e.g., `relay.agent.myns`). Use wildcard route parameters:\n\n```typescript\n// Before:\nrouter.delete('/endpoints/:subject', async (req, res) => { ... });\nrouter.get('/endpoints/:subject/inbox', async (req, res) => { ... });\n\n// After:\nrouter.delete('/endpoints/:subject(*)', async (req, res) => { ... });\nrouter.get('/endpoints/:subject(*)/inbox', async (req, res) => { ... });\n```\n\nNote: The exact Express wildcard syntax may be `/:subject(*)` or `/:subject+` depending on the Express version. Check the Express version in use (Express 4 uses `:param(*)` or regex, Express 5 uses `:param+`). Test both patterns.\n\n**Fix 2 (M16):** Extract shared adapter error status map\n\n**File:** `apps/server/src/routes/relay.ts`\n\nDefine a shared error-code-to-HTTP-status mapping:\n\n```typescript\n/** Map adapter error codes to HTTP status codes. */\nconst ADAPTER_ERROR_STATUS: Record<string, number> = {\n  DUPLICATE_ID: 409,\n  UNKNOWN_TYPE: 400,\n  MULTI_INSTANCE_DENIED: 400,\n  NOT_FOUND: 404,\n  REMOVE_BUILTIN_DENIED: 400,\n};\n```\n\nReplace all inline error-code-to-status mappings in adapter route error handlers:\n\n```typescript\n// Before (multiple handlers):\nif (err instanceof AdapterError) {\n  if (err.code === 'DUPLICATE_ID') return res.status(409).json(...);\n  if (err.code === 'UNKNOWN_TYPE') return res.status(400).json(...);\n  // ... etc\n}\n\n// After:\nif (err instanceof AdapterError) {\n  const status = ADAPTER_ERROR_STATUS[err.code] ?? 500;\n  return res.status(status).json({ error: err.message, code: err.code });\n}\n```\n\n**Fix 3 (M12):** Fix Pulse schedule path matching\n\n**File:** `apps/server/src/routes/mesh.ts`\n\nIn the `enrichAgent()` function, the Pulse schedule matching uses a namespace-based basename heuristic (`cwd.endsWith('/' + namespace)`) which is fragile. Instead, match against the agent's `projectPath` directly:\n\n```typescript\n// Before:\nfor (const [cwd, count] of scheduleCounts) {\n  if (cwd.endsWith(`/${namespace}`) || cwd.endsWith(`\\\\${namespace}`)) {\n    pulseScheduleCount += count;\n  }\n}\n\n// After: Use the agent's projectPath for exact matching\nif (agent.projectPath && scheduleCounts.has(agent.projectPath)) {\n  pulseScheduleCount = scheduleCounts.get(agent.projectPath)!;\n}\n```\n\nNote: This requires the agent object in `enrichAgent()` to have `projectPath` available. If it's not on the `AgentManifest` type, check what fields the topology view exposes and use the inspect API if needed.\n\n**Testing:**\n- Test relay endpoints with dotted subjects work correctly\n- Existing relay and mesh route tests pass\n- `pnpm typecheck` passes\n\n**Acceptance criteria:**\n- Relay endpoints accept subjects with dots\n- Adapter error handling uses a shared status map\n- Pulse schedule matching uses exact projectPath comparison\n- All existing tests pass\n- `pnpm typecheck` passes",
      "activeForm": "Fixing relay route params, adapter errors, and Pulse path matching",
      "size": "medium",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["3.1", "3.2", "3.3", "3.4", "3.5"]
    },
    {
      "id": "3.7",
      "phase": 3,
      "phaseName": "Medium-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P3] Extract TopologyGraph into sub-modules",
      "description": "TopologyGraph.tsx is at 753 lines, exceeding the 500-line must-split threshold. Extract two major pieces into separate files.\n\n**New file 1:** `apps/client/src/layers/features/mesh/lib/elk-layout.ts`\n\nMove the `applyElkLayout` function (~100 lines) into this file. This function uses elkjs to compute a hierarchical layout for the React Flow graph:\n\n```typescript\n/**\n * ELK-based layout computation for the mesh topology graph.\n *\n * @module features/mesh/lib/elk-layout\n */\nimport ELK from 'elkjs/lib/elk.bundled.js';\nimport type { Node, Edge } from '@xyflow/react';\n\n// Move the entire applyElkLayout function here, including:\n// - ELK instance creation\n// - Node/edge mapping to ELK format\n// - Layout computation\n// - Result mapping back to React Flow positions\nexport async function applyElkLayout(\n  nodes: Node[],\n  edges: Edge[],\n  options?: ElkLayoutOptions,\n): Promise<{ nodes: Node[]; edges: Edge[] }> {\n  // ... full implementation moved from TopologyGraph.tsx\n}\n```\n\n**New file 2:** `apps/client/src/layers/features/mesh/lib/build-topology-elements.ts`\n\nMove the node/edge building logic (~150 lines) from the `useMemo` in TopologyGraph into a pure function:\n\n```typescript\n/**\n * Build React Flow nodes and edges from mesh topology data.\n *\n * @module features/mesh/lib/build-topology-elements\n */\nimport type { Node, Edge } from '@xyflow/react';\nimport type { TopologyView } from '@dorkos/shared/mesh-schemas';\n\nexport interface TopologyElements {\n  nodes: Node[];\n  edges: Edge[];\n}\n\n/**\n * Transform a TopologyView into React Flow nodes and edges.\n *\n * @param topology - The mesh topology data from the API\n * @param adapters - Optional adapter data for adapter nodes\n * @param bindings - Optional binding data for binding edges\n */\nexport function buildTopologyElements(\n  topology: TopologyView,\n  adapters?: AdapterInfo[],\n  bindings?: BindingInfo[],\n): TopologyElements {\n  // ... full implementation moved from TopologyGraph.tsx useMemo\n}\n```\n\n**File 3:** `apps/client/src/layers/features/mesh/ui/TopologyGraph.tsx`\n\nUpdate to import from both new files:\n\n```typescript\nimport { applyElkLayout } from '../lib/elk-layout';\nimport { buildTopologyElements } from '../lib/build-topology-elements';\n```\n\nReplace the inline implementations with calls to the imported functions. The `useMemo` should now simply call `buildTopologyElements(topology, adapters, bindings)`. The layout effect should call `applyElkLayout(nodes, edges)`.\n\nTarget: TopologyGraph.tsx should drop to ~450-500 lines after extraction.\n\n**Testing:**\n- Visual check: topology graph renders the same way\n- Existing mesh component tests pass\n- `pnpm typecheck` passes\n- `pnpm build` succeeds (check that new files are included)\n\n**Acceptance criteria:**\n- `elk-layout.ts` contains the `applyElkLayout` function\n- `build-topology-elements.ts` contains the node/edge building logic\n- `TopologyGraph.tsx` imports from both and is under 500 lines\n- Visual rendering is unchanged\n- `pnpm typecheck` and `pnpm build` pass",
      "activeForm": "Extracting TopologyGraph layout and element building into sub-modules",
      "size": "medium",
      "priority": "low",
      "dependencies": [],
      "parallelWith": ["3.8", "3.9", "3.10"]
    },
    {
      "id": "3.8",
      "phase": 3,
      "phaseName": "Medium-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P3] Fix binding-router test envelopes and async watcher cleanup",
      "description": "Two related fixes for test quality and async cleanup.\n\n**Fix 1 (M11):** Fix binding-router test envelopes\n\n**File:** `apps/server/src/services/relay/__tests__/binding-router.test.ts`\n\nThe test envelopes use malformed budget fields that don't match the `RelayBudgetSchema`. Replace with correct field names:\n\n```typescript\n// Before (incorrect field names):\nbudget: { ttlMs: 60000, maxHops: 5, callBudget: 10 }\n\n// After (correct field names matching RelayBudgetSchema):\nbudget: {\n  hopCount: 0,\n  maxHops: 5,\n  ttl: Date.now() + 60000,\n  callBudgetRemaining: 10,\n  ancestorChain: [],\n}\n```\n\nSearch for all occurrences of the old budget format in the test file and replace each one. The correct schema fields are:\n- `hopCount` (number) — current hop count, starts at 0\n- `maxHops` (number) — maximum allowed hops\n- `ttl` (number) — absolute expiry timestamp in ms since epoch\n- `callBudgetRemaining` (number) — remaining tool call budget\n- `ancestorChain` (string[]) — chain of message IDs for loop detection\n\n**Fix 2 (M17):** Async watcher cleanup\n\n**File:** `packages/relay/src/watcher-manager.ts`\n\nUpdate `stopWatcher()` to properly await chokidar's `close()` and ensure the map entry is deleted:\n\n```typescript\n/**\n * Stop and remove a watcher for the given endpoint hash.\n *\n * @param endpointHash - Hash of the endpoint to stop watching\n */\nasync stopWatcher(endpointHash: string): Promise<void> {\n  const watcher = this.watchers.get(endpointHash);\n  if (watcher) {\n    this.watchers.delete(endpointHash);\n    await watcher.close();\n  }\n}\n```\n\n**File:** `packages/relay/src/relay-core.ts`\n\nUpdate `unregisterEndpoint()` to `await` the `stopWatcher()` call:\n\n```typescript\nasync unregisterEndpoint(subject: string): Promise<void> {\n  // ... existing logic ...\n  await this.watcherManager.stopWatcher(hash);\n  // ... rest of cleanup ...\n}\n```\n\nIf `unregisterEndpoint()` is not already async, make it async.\n\n**Testing:**\n- Run binding-router tests: `pnpm vitest run apps/server/src/services/relay/__tests__/binding-router.test.ts`\n- All tests should pass with corrected budget fields\n- `pnpm typecheck` passes\n\n**Acceptance criteria:**\n- All test envelopes in binding-router tests use correct `RelayBudgetSchema` fields\n- `stopWatcher()` is async and awaits `watcher.close()`\n- `unregisterEndpoint()` awaits `stopWatcher()`\n- All tests pass\n- `pnpm typecheck` passes",
      "activeForm": "Fixing test envelope schemas and async watcher cleanup",
      "size": "small",
      "priority": "medium",
      "dependencies": [],
      "parallelWith": ["3.7", "3.9", "3.10"]
    },
    {
      "id": "3.9",
      "phase": 3,
      "phaseName": "Medium-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P3] Reduce topology polling interval to 30 seconds",
      "description": "The topology polling interval is currently 15 seconds, which creates unnecessary server load for data that changes infrequently.\n\n**File:** `apps/client/src/layers/entities/mesh/model/use-mesh-topology.ts`\n\nChange the `refetchInterval` from 15000 to 30000:\n\n```typescript\n// Before:\nrefetchInterval: 15_000,\n\n// After:\nrefetchInterval: 30_000,\n```\n\n**Testing:**\n- Verify the hook file compiles\n- `pnpm typecheck` passes\n\n**Acceptance criteria:**\n- Topology polling interval is 30 seconds\n- `pnpm typecheck` passes",
      "activeForm": "Reducing topology polling interval to 30 seconds",
      "size": "small",
      "priority": "low",
      "dependencies": [],
      "parallelWith": ["3.7", "3.8", "3.10"]
    },
    {
      "id": "3.10",
      "phase": 3,
      "phaseName": "Medium-Severity Fixes",
      "subject": "[relay-mesh-review-remediation-r3] [P3] Add payload extraction tests for edge cases",
      "description": "Add comprehensive tests for the extracted `extractPayloadContent` utility (from task 2.3) and the Telegram adapter's handling of edge cases.\n\n**File 1:** `packages/relay/src/lib/__tests__/payload-utils.test.ts`\n\nThis file should already exist from task 2.3. Add additional edge case tests if not already covered:\n\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { extractPayloadContent } from '../payload-utils.js';\n\ndescribe('extractPayloadContent edge cases', () => {\n  it('handles empty string payload', () => {\n    expect(extractPayloadContent('')).toBe('');\n  });\n\n  it('handles object with non-string content field', () => {\n    expect(extractPayloadContent({ content: 42 })).toBe('{\"content\":42}');\n  });\n\n  it('handles object with non-string text field', () => {\n    expect(extractPayloadContent({ text: true })).toBe('{\"text\":true}');\n  });\n\n  it('handles array payload', () => {\n    expect(extractPayloadContent([1, 2, 3])).toBe('[1,2,3]');\n  });\n\n  it('handles deeply nested object', () => {\n    const payload = { nested: { deep: { content: 'found' } } };\n    // Should NOT find nested content — only checks top-level\n    expect(extractPayloadContent(payload)).toBe(JSON.stringify(payload));\n  });\n});\n```\n\n**File 2:** `packages/relay/src/__tests__/adapters/telegram-adapter.test.ts`\n\nAdd test for `extractPayloadContent` usage within the Telegram adapter (testing via the adapter's outbound handler):\n\n```typescript\ndescribe('outbound message payload extraction', () => {\n  it('handles string payload', async () => {\n    const envelope = createTestEnvelope({\n      payload: 'plain text message',\n    });\n    // Verify sendMessage is called with 'plain text message'\n  });\n\n  it('handles object payload with content field', async () => {\n    const envelope = createTestEnvelope({\n      payload: { content: 'structured message', metadata: {} },\n    });\n    // Verify sendMessage is called with 'structured message'\n  });\n\n  it('handles object payload without content or text', async () => {\n    const envelope = createTestEnvelope({\n      payload: { data: 'raw data', count: 5 },\n    });\n    // Verify sendMessage is called with JSON.stringify of the payload\n  });\n});\n```\n\n**Testing:**\n- Run all new tests: `pnpm vitest run packages/relay/src/lib/__tests__/payload-utils.test.ts`\n- Run Telegram adapter tests: `pnpm vitest run packages/relay/src/__tests__/adapters/telegram-adapter.test.ts`\n- All tests pass\n\n**Acceptance criteria:**\n- Comprehensive edge case tests exist for `extractPayloadContent`\n- Telegram adapter tests cover payload extraction scenarios\n- All tests pass\n- `pnpm typecheck` passes",
      "activeForm": "Adding comprehensive payload extraction edge case tests",
      "size": "small",
      "priority": "low",
      "dependencies": ["2.3"],
      "parallelWith": ["3.7", "3.8", "3.9"]
    }
  ]
}
