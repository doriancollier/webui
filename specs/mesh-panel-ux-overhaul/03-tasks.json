{
  "spec": "specs/mesh-panel-ux-overhaul/02-specification.md",
  "slug": "mesh-panel-ux-overhaul",
  "generatedAt": "2026-02-25T12:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Config + API Foundation",
      "subject": "[mesh-panel-ux-overhaul] [P1] Add scanRoots to mesh config schema",
      "description": "Extend the mesh config object in `packages/shared/src/config-schema.ts` to include a `scanRoots` field.\n\n## Implementation\n\nIn `packages/shared/src/config-schema.ts`, change the `mesh` schema from:\n\n```typescript\nmesh: z\n  .object({\n    enabled: z.boolean().default(false),\n  })\n  .default(() => ({ enabled: false })),\n```\n\nTo:\n\n```typescript\nmesh: z\n  .object({\n    enabled: z.boolean().default(false),\n    scanRoots: z.array(z.string()).default(() => []),\n  })\n  .default(() => ({ enabled: false, scanRoots: [] })),\n```\n\nThis adds a `scanRoots` string array with an empty default. When `scanRoots` is empty, the UI will fall back to the server boundary as the initial root.\n\nThe `UserConfig` type is auto-inferred from the schema via `z.infer<typeof UserConfigSchema>`, so no manual type changes are needed.\n\nThe `USER_CONFIG_DEFAULTS` at the bottom of the file is computed via `UserConfigSchema.parse({ version: 1 })`, so it will automatically pick up the new default.\n\n## Testing\n\nAdd or verify these test cases:\n\n```typescript\nimport { UserConfigSchema } from '@dorkos/shared/config-schema';\n\ndescribe('UserConfigSchema - mesh.scanRoots', () => {\n  it('defaults scanRoots to empty array when not provided', () => {\n    const result = UserConfigSchema.parse({ version: 1 });\n    expect(result.mesh.scanRoots).toEqual([]);\n  });\n\n  it('accepts valid string array for scanRoots', () => {\n    const result = UserConfigSchema.parse({\n      version: 1,\n      mesh: { enabled: true, scanRoots: ['/home/user/projects', '/opt/agents'] },\n    });\n    expect(result.mesh.scanRoots).toEqual(['/home/user/projects', '/opt/agents']);\n  });\n\n  it('rejects non-string values in scanRoots', () => {\n    const result = UserConfigSchema.safeParse({\n      version: 1,\n      mesh: { scanRoots: [123] },\n    });\n    expect(result.success).toBe(false);\n  });\n\n  it('preserves existing mesh.enabled field', () => {\n    const result = UserConfigSchema.parse({\n      version: 1,\n      mesh: { enabled: true, scanRoots: ['/a'] },\n    });\n    expect(result.mesh.enabled).toBe(true);\n  });\n});\n```\n\n## Acceptance Criteria\n\n- `UserConfigSchema` parses `mesh.scanRoots` as a string array defaulting to `[]`\n- Existing `mesh.enabled` field is unchanged\n- `UserConfig` type includes `mesh.scanRoots: string[]`\n- `USER_CONFIG_DEFAULTS.mesh.scanRoots` equals `[]`\n- `pnpm typecheck` passes across all packages that import config-schema",
      "activeForm": "Adding scanRoots to mesh config schema",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.2"]
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Config + API Foundation",
      "subject": "[mesh-panel-ux-overhaul] [P1] Expose boundary in GET /api/config response",
      "description": "Add the server boundary path to the GET `/api/config` response so the client can use it as the default scan root when no custom roots are saved.\n\n## Implementation\n\nIn `apps/server/src/routes/config.ts`, import `getBoundary` from `lib/boundary.ts` and add `boundary` to the GET handler response.\n\nAdd the import at the top of the file:\n\n```typescript\nimport { getBoundary } from '../lib/boundary.js';\n```\n\nIn the `router.get('/')` handler, add `boundary` to the response JSON object:\n\n```typescript\nrouter.get('/', async (_req, res) => {\n  // ... existing code ...\n\n  res.json({\n    // ... existing fields (version, latestVersion, port, uptime, workingDirectory, etc.) ...\n    boundary: getBoundary(),\n  });\n});\n```\n\n`getBoundary()` is already exported from `apps/server/src/lib/boundary.ts`. It returns the resolved boundary path string (defaults to the user's home directory). The boundary is the outermost directory the server allows access to.\n\nThe `boundary` field is a simple string (e.g., `/Users/dorian`). It is not sensitive data — it is equivalent to `workingDirectory` which is already exposed.\n\n## Testing\n\nAdd an integration test or update existing config route tests:\n\n```typescript\nimport request from 'supertest';\n\ndescribe('GET /api/config', () => {\n  it('includes boundary field in response', async () => {\n    const res = await request(app).get('/api/config');\n    expect(res.status).toBe(200);\n    expect(res.body).toHaveProperty('boundary');\n    expect(typeof res.body.boundary).toBe('string');\n    expect(res.body.boundary.length).toBeGreaterThan(0);\n  });\n});\n```\n\n## Acceptance Criteria\n\n- GET `/api/config` response includes `boundary` as a non-empty string\n- The boundary value matches what `getBoundary()` returns (the configured boundary or home directory)\n- Existing response fields are unchanged\n- No new dependencies added",
      "activeForm": "Exposing boundary in config API response",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1"]
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Config + API Foundation",
      "subject": "[mesh-panel-ux-overhaul] [P1] Create useMeshScanRoots entity hook",
      "description": "Create a new entity hook `useMeshScanRoots` that reads saved scan roots from config and provides the server boundary as a fallback default.\n\n## Implementation\n\nCreate `apps/client/src/layers/entities/mesh/model/use-mesh-scan-roots.ts`:\n\n```typescript\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\n\n/**\n * Provides mesh scan root paths from config with boundary fallback.\n *\n * Returns saved scan roots from `~/.dork/config.json`. When no roots\n * are saved, falls back to the server boundary path as the default root.\n * Provides a mutation to persist custom roots to config.\n */\nexport function useMeshScanRoots() {\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n\n  const { data: config } = useQuery({\n    queryKey: ['config'],\n    queryFn: () => transport.getConfig(),\n  });\n\n  const boundary = config?.boundary ?? '~';\n  const savedRoots: string[] = config?.mesh?.scanRoots ?? [];\n  const defaultRoots = savedRoots.length > 0 ? savedRoots : [boundary];\n\n  const { mutate: saveScanRoots } = useMutation({\n    mutationFn: (roots: string[]) =>\n      transport.updateConfig({ mesh: { scanRoots: roots } }),\n    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['config'] }),\n  });\n\n  return { defaultRoots, boundary, savedRoots, saveScanRoots };\n}\n```\n\nThen export it from the entities/mesh barrel at `apps/client/src/layers/entities/mesh/index.ts`:\n\n```typescript\nexport { useMeshScanRoots } from './model/use-mesh-scan-roots';\n```\n\nAdd this line alongside the existing exports.\n\n## Key Behaviors\n\n- `defaultRoots`: Returns `savedRoots` if non-empty, otherwise `[boundary]` (single-element array with server boundary)\n- `boundary`: The server boundary path string, used for display and as fallback\n- `savedRoots`: The raw saved roots from config (may be empty)\n- `saveScanRoots(roots)`: Persists roots to config via PATCH `/api/config` with `{ mesh: { scanRoots: roots } }`, then invalidates the config query cache\n- The hook reuses the existing `['config']` query key, so it shares cache with any other component reading config\n\n## Transport Interface\n\nThe `transport.getConfig()` and `transport.updateConfig()` methods already exist in the Transport interface. The config response type may need to be extended to include `boundary?: string` and `mesh?: { scanRoots?: string[] }` — check `packages/shared/src/types.ts` or the Transport type definition and extend if needed.\n\n## Testing\n\n```typescript\nimport { renderHook, waitFor } from '@testing-library/react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { TransportProvider } from '@/layers/shared/model';\nimport { createMockTransport } from '@dorkos/test-utils';\nimport { useMeshScanRoots } from '../use-mesh-scan-roots';\n\nfunction createWrapper(transport = createMockTransport()) {\n  const queryClient = new QueryClient({ defaultOptions: { queries: { retry: false } } });\n  return ({ children }: { children: React.ReactNode }) => (\n    <QueryClientProvider client={queryClient}>\n      <TransportProvider transport={transport}>{children}</TransportProvider>\n    </QueryClientProvider>\n  );\n}\n\ndescribe('useMeshScanRoots', () => {\n  it('falls back to boundary when no saved roots', async () => {\n    const transport = createMockTransport();\n    transport.getConfig = vi.fn().mockResolvedValue({\n      boundary: '/Users/dorian',\n      mesh: { enabled: true, scanRoots: [] },\n    });\n\n    const { result } = renderHook(() => useMeshScanRoots(), {\n      wrapper: createWrapper(transport),\n    });\n\n    await waitFor(() => {\n      expect(result.current.defaultRoots).toEqual(['/Users/dorian']);\n    });\n    expect(result.current.boundary).toBe('/Users/dorian');\n  });\n\n  it('returns saved roots when they exist', async () => {\n    const transport = createMockTransport();\n    transport.getConfig = vi.fn().mockResolvedValue({\n      boundary: '/Users/dorian',\n      mesh: { enabled: true, scanRoots: ['/projects', '/opt/agents'] },\n    });\n\n    const { result } = renderHook(() => useMeshScanRoots(), {\n      wrapper: createWrapper(transport),\n    });\n\n    await waitFor(() => {\n      expect(result.current.defaultRoots).toEqual(['/projects', '/opt/agents']);\n    });\n  });\n\n  it('calls updateConfig when saveScanRoots is invoked', async () => {\n    const transport = createMockTransport();\n    transport.getConfig = vi.fn().mockResolvedValue({\n      boundary: '/Users/dorian',\n      mesh: { enabled: true, scanRoots: [] },\n    });\n    transport.updateConfig = vi.fn().mockResolvedValue({ success: true });\n\n    const { result } = renderHook(() => useMeshScanRoots(), {\n      wrapper: createWrapper(transport),\n    });\n\n    await waitFor(() => expect(result.current.defaultRoots).toBeDefined());\n\n    result.current.saveScanRoots(['/new/path']);\n\n    await waitFor(() => {\n      expect(transport.updateConfig).toHaveBeenCalledWith({\n        mesh: { scanRoots: ['/new/path'] },\n      });\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n\n- Hook returns `defaultRoots` that falls back to `[boundary]` when `savedRoots` is empty\n- Hook returns the boundary path from the config API response\n- `saveScanRoots` calls `transport.updateConfig` and invalidates the config query\n- Exported from `@/layers/entities/mesh` barrel\n- `pnpm typecheck` passes",
      "activeForm": "Creating useMeshScanRoots entity hook",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1", "1.2"],
      "parallelWith": []
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "Discovery Components",
      "subject": "[mesh-panel-ux-overhaul] [P2] Create ScanRootInput chip/tag component",
      "description": "Create a chip/tag input component for managing scan root paths. Renders each root as a removable badge chip, with an inline text input for adding paths and a folder icon button to open the DirectoryPicker.\n\n## Implementation\n\nCreate `apps/client/src/layers/features/mesh/ui/ScanRootInput.tsx`:\n\n```tsx\nimport { useState, useCallback, type KeyboardEvent } from 'react';\nimport { FolderOpen, X } from 'lucide-react';\nimport { Badge } from '@/layers/shared/ui/badge';\nimport { DirectoryPicker } from '@/layers/shared/ui';\n\ninterface ScanRootInputProps {\n  /** Current list of root paths */\n  roots: string[];\n  /** Called when roots change (add/remove) */\n  onRootsChange: (roots: string[]) => void;\n  /** Whether scanning is in progress */\n  disabled?: boolean;\n}\n\n/** Normalize a path: trim whitespace */\nfunction normalizePath(raw: string): string {\n  return raw.trim();\n}\n\n/**\n * Chip/tag input for managing filesystem scan root paths.\n *\n * Renders each root as a Badge with a remove button. Supports adding\n * paths via text input (Enter or comma to confirm) and via DirectoryPicker.\n * Silently deduplicates paths.\n */\nexport function ScanRootInput({ roots, onRootsChange, disabled }: ScanRootInputProps) {\n  const [inputValue, setInputValue] = useState('');\n  const [pickerOpen, setPickerOpen] = useState(false);\n\n  const addRoot = useCallback(\n    (raw: string) => {\n      const normalized = normalizePath(raw);\n      if (!normalized) return;\n      if (roots.includes(normalized)) return; // deduplicate\n      onRootsChange([...roots, normalized]);\n    },\n    [roots, onRootsChange],\n  );\n\n  const removeRoot = useCallback(\n    (index: number) => {\n      onRootsChange(roots.filter((_, i) => i !== index));\n    },\n    [roots, onRootsChange],\n  );\n\n  const handleKeyDown = useCallback(\n    (e: KeyboardEvent<HTMLInputElement>) => {\n      if (e.key === 'Enter' || e.key === ',') {\n        e.preventDefault();\n        const value = inputValue.replace(/,$/g, '');\n        addRoot(value);\n        setInputValue('');\n      }\n    },\n    [inputValue, addRoot],\n  );\n\n  const handleDirectorySelect = useCallback(\n    (dir: string) => {\n      addRoot(dir);\n      setPickerOpen(false);\n    },\n    [addRoot],\n  );\n\n  return (\n    <div className=\"flex flex-wrap items-center gap-1.5 rounded-md border bg-transparent px-2 py-1.5\">\n      {roots.map((root, index) => (\n        <Badge key={root} variant=\"secondary\" className=\"gap-1 pr-1\">\n          <span className=\"max-w-48 truncate font-mono text-xs\">{root}</span>\n          <button\n            type=\"button\"\n            onClick={() => removeRoot(index)}\n            disabled={disabled}\n            className=\"ml-0.5 rounded-sm p-0.5 hover:bg-muted-foreground/20\"\n            aria-label={`Remove ${root}`}\n          >\n            <X className=\"size-3\" />\n          </button>\n        </Badge>\n      ))}\n\n      <input\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        onKeyDown={handleKeyDown}\n        disabled={disabled}\n        placeholder={roots.length === 0 ? 'Add scan root path...' : ''}\n        className=\"min-w-24 flex-1 bg-transparent px-1 py-0.5 text-sm placeholder:text-muted-foreground focus-visible:outline-none\"\n      />\n\n      <button\n        type=\"button\"\n        onClick={() => setPickerOpen(true)}\n        disabled={disabled}\n        className=\"rounded p-1 text-muted-foreground hover:bg-muted hover:text-foreground\"\n        aria-label=\"Browse directories\"\n      >\n        <FolderOpen className=\"size-4\" />\n      </button>\n\n      {pickerOpen && (\n        <DirectoryPicker\n          open={pickerOpen}\n          onOpenChange={setPickerOpen}\n          onSelect={handleDirectorySelect}\n        />\n      )}\n    </div>\n  );\n}\n```\n\nNote: The DirectoryPicker component is already available at `@/layers/shared/ui`. Verify its exact props interface (`open`, `onOpenChange`, `onSelect`) and adjust accordingly. If it uses a different prop API (e.g., `onSelectDirectory` instead of `onSelect`), adapt the code.\n\n## Layout\n\nThe component uses `flex flex-wrap` so chips flow to multiple lines when they overflow. The text input grows to fill remaining space (`flex-1 min-w-24`). The folder button sits at the end.\n\n```\n[ ~/projects x ] [ /opt/agents x ]  ____  [folder-icon]\n```\n\n## Behaviors\n\n- Enter or comma key adds the current input value as a new chip\n- Duplicate paths are silently ignored (exact string match after normalization)\n- Paths are trimmed of whitespace\n- Each chip has an X button that calls `onRootsChange` with the path removed\n- Folder icon opens DirectoryPicker dialog; selecting a directory adds it as a chip\n- `disabled` prop disables input, remove buttons, and browse button\n\n## Testing\n\nCreate `apps/client/src/layers/features/mesh/ui/__tests__/ScanRootInput.test.tsx`:\n\n```typescript\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect, vi } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport '@testing-library/jest-dom/vitest';\nimport { ScanRootInput } from '../ScanRootInput';\n\n// Mock DirectoryPicker to avoid filesystem UI in tests\nvi.mock('@/layers/shared/ui', () => ({\n  DirectoryPicker: () => null,\n}));\nvi.mock('@/layers/shared/ui/badge', () => ({\n  Badge: ({ children, ...props }: any) => <span {...props}>{children}</span>,\n}));\n\ndescribe('ScanRootInput', () => {\n  it('renders initial roots as chips', () => {\n    render(<ScanRootInput roots={['/home/user']} onRootsChange={vi.fn()} />);\n    expect(screen.getByText('/home/user')).toBeInTheDocument();\n  });\n\n  it('adds new root on Enter key', async () => {\n    const onRootsChange = vi.fn();\n    render(<ScanRootInput roots={[]} onRootsChange={onRootsChange} />);\n\n    const input = screen.getByRole('textbox');\n    await userEvent.type(input, '/opt/agents{Enter}');\n    expect(onRootsChange).toHaveBeenCalledWith(['/opt/agents']);\n  });\n\n  it('adds new root on comma key', async () => {\n    const onRootsChange = vi.fn();\n    render(<ScanRootInput roots={[]} onRootsChange={onRootsChange} />);\n\n    const input = screen.getByRole('textbox');\n    await userEvent.type(input, '/opt/agents,');\n    expect(onRootsChange).toHaveBeenCalledWith(['/opt/agents']);\n  });\n\n  it('removes root when chip X is clicked', async () => {\n    const onRootsChange = vi.fn();\n    render(<ScanRootInput roots={['/a', '/b']} onRootsChange={onRootsChange} />);\n\n    const removeButtons = screen.getAllByLabelText(/remove/i);\n    await userEvent.click(removeButtons[0]);\n    expect(onRootsChange).toHaveBeenCalledWith(['/b']);\n  });\n\n  it('deduplicates paths silently', async () => {\n    const onRootsChange = vi.fn();\n    render(<ScanRootInput roots={['/a']} onRootsChange={onRootsChange} />);\n\n    const input = screen.getByRole('textbox');\n    await userEvent.type(input, '/a{Enter}');\n    expect(onRootsChange).not.toHaveBeenCalled();\n  });\n\n  it('trims whitespace from paths', async () => {\n    const onRootsChange = vi.fn();\n    render(<ScanRootInput roots={[]} onRootsChange={onRootsChange} />);\n\n    const input = screen.getByRole('textbox');\n    await userEvent.type(input, '  /opt/agents  {Enter}');\n    expect(onRootsChange).toHaveBeenCalledWith(['/opt/agents']);\n  });\n\n  it('does not add empty strings', async () => {\n    const onRootsChange = vi.fn();\n    render(<ScanRootInput roots={[]} onRootsChange={onRootsChange} />);\n\n    const input = screen.getByRole('textbox');\n    await userEvent.type(input, '   {Enter}');\n    expect(onRootsChange).not.toHaveBeenCalled();\n  });\n\n  it('disables input and buttons when disabled prop is true', () => {\n    render(<ScanRootInput roots={['/a']} onRootsChange={vi.fn()} disabled />);\n    expect(screen.getByRole('textbox')).toBeDisabled();\n    expect(screen.getByLabelText('Browse directories')).toBeDisabled();\n  });\n});\n```\n\n## Acceptance Criteria\n\n- Renders roots as Badge chips with remove buttons\n- Text input adds new roots on Enter or comma\n- Folder icon button opens DirectoryPicker\n- Duplicate paths are silently ignored\n- Paths are trimmed of whitespace\n- `disabled` prop disables all interactions\n- All tests pass",
      "activeForm": "Creating ScanRootInput chip/tag component",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.3"],
      "parallelWith": ["2.2", "2.3"]
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "Discovery Components",
      "subject": "[mesh-panel-ux-overhaul] [P2] Create MeshEmptyState reusable component",
      "description": "Create a reusable empty state component for Mesh panel tabs that follows the Calm Tech design system with contextual copy and optional CTA buttons.\n\n## Implementation\n\nCreate `apps/client/src/layers/features/mesh/ui/MeshEmptyState.tsx`:\n\n```tsx\nimport type { ReactNode } from 'react';\n\ninterface MeshEmptyStateProps {\n  /** Icon element rendered at the top */\n  icon: ReactNode;\n  /** Primary headline text */\n  headline: string;\n  /** Secondary descriptive text */\n  description: string;\n  /** Optional call-to-action button */\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n}\n\n/**\n * Contextual empty state card for Mesh panel tabs.\n *\n * Follows Calm Tech design: rounded-xl card, centered content,\n * muted colors, icon at size-8, p-8 padding. Optional CTA button\n * for forward-moving actions like \"Go to Discovery\".\n */\nexport function MeshEmptyState({ icon, headline, description, action }: MeshEmptyStateProps) {\n  return (\n    <div className=\"flex flex-col items-center justify-center gap-3 rounded-xl border p-8 text-center\">\n      <div className=\"text-muted-foreground/50\">{icon}</div>\n      <div>\n        <p className=\"font-medium\">{headline}</p>\n        <p className=\"mt-1 text-sm text-muted-foreground\">{description}</p>\n      </div>\n      {action && (\n        <button\n          type=\"button\"\n          onClick={action.onClick}\n          className=\"mt-2 inline-flex items-center gap-1.5 rounded-md bg-primary px-3 py-2 text-sm font-medium text-primary-foreground hover:bg-primary/90\"\n        >\n          {action.label}\n        </button>\n      )}\n    </div>\n  );\n}\n```\n\n## Per-Tab Empty States\n\nThis component will be used in Mode B (full tabbed interface) for each tab's empty state:\n\n| Tab | Icon Component | Headline | Description | CTA |\n|-----|---------------|----------|-------------|-----|\n| Agents | `<Network className=\"size-8\" />` | \"No agents registered yet\" | \"Run a discovery scan to find compatible agents, then register them to join the mesh.\" | \"Go to Discovery\" (calls `onGoToDiscovery`) |\n| Denied | `<ShieldCheck className=\"size-8\" />` | \"No blocked paths\" | \"Paths you deny during discovery will appear here, preventing those agents from joining the mesh.\" | None (healthy state — no CTA needed) |\n| Access | `<Shield className=\"size-8\" />` | \"Cross-project access requires multiple namespaces\" | \"Register agents from different projects to configure which namespaces can communicate.\" | \"Go to Discovery\" (calls `onGoToDiscovery`) |\n\nThe actual usage of these per-tab empty states happens in Task 3.1 (MeshPanel rewrite). This task only creates the reusable component.\n\n## Design Tokens\n\n- Card: `rounded-xl border p-8` (Calm Tech card feel)\n- Icon wrapper: `text-muted-foreground/50` (50% opacity muted)\n- Headline: `font-medium` (default foreground color)\n- Description: `text-sm text-muted-foreground`\n- CTA button: `bg-primary text-primary-foreground rounded-md px-3 py-2`\n\n## Testing\n\nCreate `apps/client/src/layers/features/mesh/ui/__tests__/MeshEmptyState.test.tsx`:\n\n```typescript\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect, vi } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport '@testing-library/jest-dom/vitest';\nimport { MeshEmptyState } from '../MeshEmptyState';\n\ndescribe('MeshEmptyState', () => {\n  it('renders headline and description', () => {\n    render(\n      <MeshEmptyState\n        icon={<span data-testid=\"icon\">icon</span>}\n        headline=\"Test Headline\"\n        description=\"Test description text\"\n      />,\n    );\n    expect(screen.getByText('Test Headline')).toBeInTheDocument();\n    expect(screen.getByText('Test description text')).toBeInTheDocument();\n  });\n\n  it('renders the icon', () => {\n    render(\n      <MeshEmptyState\n        icon={<span data-testid=\"icon\">icon</span>}\n        headline=\"Headline\"\n        description=\"Desc\"\n      />,\n    );\n    expect(screen.getByTestId('icon')).toBeInTheDocument();\n  });\n\n  it('renders CTA button when action is provided', () => {\n    const onClick = vi.fn();\n    render(\n      <MeshEmptyState\n        icon={<span>icon</span>}\n        headline=\"Headline\"\n        description=\"Desc\"\n        action={{ label: 'Go to Discovery', onClick }}\n      />,\n    );\n    expect(screen.getByRole('button', { name: 'Go to Discovery' })).toBeInTheDocument();\n  });\n\n  it('calls action onClick when CTA is clicked', async () => {\n    const onClick = vi.fn();\n    render(\n      <MeshEmptyState\n        icon={<span>icon</span>}\n        headline=\"Headline\"\n        description=\"Desc\"\n        action={{ label: 'Go to Discovery', onClick }}\n      />,\n    );\n    await userEvent.click(screen.getByRole('button', { name: 'Go to Discovery' }));\n    expect(onClick).toHaveBeenCalledOnce();\n  });\n\n  it('does not render CTA button when no action is provided', () => {\n    render(\n      <MeshEmptyState\n        icon={<span>icon</span>}\n        headline=\"Headline\"\n        description=\"Desc\"\n      />,\n    );\n    expect(screen.queryByRole('button')).not.toBeInTheDocument();\n  });\n});\n```\n\n## Acceptance Criteria\n\n- Component renders icon, headline, description, and optional CTA\n- CTA button fires `action.onClick` when clicked\n- No CTA button rendered when `action` is undefined\n- Follows Calm Tech design tokens (rounded-xl, p-8, muted colors)\n- All tests pass",
      "activeForm": "Creating MeshEmptyState reusable component",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["2.1", "2.3"]
    },
    {
      "id": "2.3",
      "phase": 2,
      "phaseName": "Discovery Components",
      "subject": "[mesh-panel-ux-overhaul] [P2] Create DiscoveryView component extracted from MeshPanel",
      "description": "Extract the current inline `DiscoveryTab` from `MeshPanel.tsx` into a standalone `DiscoveryView.tsx` that serves both Mode A (full-bleed hero layout) and Mode B (compact tab content). This component uses the new `ScanRootInput` for path management and `useMeshScanRoots` for config persistence.\n\n## Implementation\n\nCreate `apps/client/src/layers/features/mesh/ui/DiscoveryView.tsx`:\n\n```tsx\nimport { useState, useCallback } from 'react';\nimport { ChevronDown, ChevronRight, Loader2, Radar, Search } from 'lucide-react';\nimport { useDiscoverAgents, useMeshScanRoots } from '@/layers/entities/mesh';\nimport type { DiscoveryCandidate } from '@dorkos/shared/mesh-schemas';\nimport { CandidateCard } from './CandidateCard';\nimport { ScanRootInput } from './ScanRootInput';\n\ninterface DiscoveryViewProps {\n  /** When true, renders full-bleed hero layout (Mode A). Otherwise compact tab layout. */\n  fullBleed?: boolean;\n}\n\n/**\n * Discovery content that serves both Mode A (full-bleed hero) and Mode B (tab content).\n *\n * Mode A: Centered layout with Radar icon, headline, description, scan input, and results.\n * Mode B: Compact layout with just the scan input and results (no headline/icon).\n */\nexport function DiscoveryView({ fullBleed = false }: DiscoveryViewProps) {\n  const { defaultRoots, saveScanRoots } = useMeshScanRoots();\n  const [roots, setRoots] = useState<string[]>(defaultRoots);\n  const [advancedOpen, setAdvancedOpen] = useState(false);\n  const [scanDepth, setScanDepth] = useState(3);\n  const { mutate: discover, data: result, isPending } = useDiscoverAgents();\n  const candidates = result?.candidates;\n\n  const handleRootsChange = useCallback(\n    (newRoots: string[]) => {\n      setRoots(newRoots);\n      saveScanRoots(newRoots);\n    },\n    [saveScanRoots],\n  );\n\n  const handleScan = useCallback(() => {\n    if (roots.length > 0) {\n      discover({ roots, maxDepth: scanDepth });\n    }\n  }, [roots, scanDepth, discover]);\n\n  return (\n    <div className={fullBleed ? 'flex flex-col items-center gap-6 p-8' : 'space-y-4 p-4'}>\n      {/* Hero section — only in Mode A */}\n      {fullBleed && (\n        <div className=\"flex flex-col items-center gap-2 text-center\">\n          <Radar className=\"size-10 text-muted-foreground/50\" />\n          <h2 className=\"text-lg font-semibold\">Discover agents on this machine</h2>\n          <p className=\"max-w-md text-sm text-muted-foreground\">\n            Scan your filesystem to find compatible AI agents.\n          </p>\n        </div>\n      )}\n\n      {/* Scan input + button row */}\n      <div className={fullBleed ? 'w-full max-w-lg space-y-3' : 'space-y-3'}>\n        <div className=\"flex items-end gap-2\">\n          <div className=\"flex-1\">\n            <ScanRootInput\n              roots={roots}\n              onRootsChange={handleRootsChange}\n              disabled={isPending}\n            />\n          </div>\n          <button\n            type=\"button\"\n            onClick={handleScan}\n            disabled={isPending || roots.length === 0}\n            className=\"inline-flex items-center gap-1.5 rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground hover:bg-primary/90 disabled:opacity-50\"\n          >\n            {isPending ? (\n              <Loader2 className=\"size-4 animate-spin\" />\n            ) : (\n              <Search className=\"size-4\" />\n            )}\n            Scan\n          </button>\n        </div>\n\n        {/* Advanced options — progressive disclosure */}\n        <div>\n          <button\n            type=\"button\"\n            onClick={() => setAdvancedOpen(!advancedOpen)}\n            className=\"inline-flex items-center gap-1 text-xs text-muted-foreground hover:text-foreground\"\n          >\n            {advancedOpen ? (\n              <ChevronDown className=\"size-3.5\" />\n            ) : (\n              <ChevronRight className=\"size-3.5\" />\n            )}\n            Advanced options\n          </button>\n\n          {advancedOpen && (\n            <div className=\"mt-2 flex items-center gap-3 rounded-lg border p-3\">\n              <label htmlFor=\"scan-depth\" className=\"text-xs text-muted-foreground\">\n                Scan depth\n              </label>\n              <input\n                id=\"scan-depth\"\n                type=\"range\"\n                min={1}\n                max={5}\n                value={scanDepth}\n                onChange={(e) => setScanDepth(Number(e.target.value))}\n                className=\"flex-1\"\n              />\n              <span className=\"w-4 text-center text-xs font-medium\">{scanDepth}</span>\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Results */}\n      {isPending && (\n        <div className=\"flex items-center justify-center p-8\">\n          <Loader2 className=\"size-5 animate-spin text-muted-foreground\" />\n        </div>\n      )}\n\n      {!isPending && candidates && candidates.length === 0 && (\n        <div className=\"p-8 text-center text-sm text-muted-foreground\">\n          No agents found in these directories. Try scanning with greater depth or different\n          directories.\n        </div>\n      )}\n\n      {!isPending && candidates && candidates.length > 0 && (\n        <div className={fullBleed ? 'w-full max-w-lg space-y-2' : 'space-y-2'}>\n          {candidates.map((c: DiscoveryCandidate) => (\n            <CandidateCard key={c.path} candidate={c} />\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n## Key Notes\n\n- The `defaultRoots` from `useMeshScanRoots()` are used as the initial value for the local `roots` state. This means the component initializes with saved roots (or the boundary fallback).\n- `handleRootsChange` both updates local state AND persists to config via `saveScanRoots` (save immediately on chip add/remove).\n- The `maxDepth` parameter in `discover()` — verify that `useDiscoverAgents` accepts this parameter. The mutation likely calls POST `/api/mesh/discover` which accepts `{ roots, maxDepth }`. Check the existing hook and update if needed.\n- The `CandidateCard` component is already extracted as a separate file at `apps/client/src/layers/features/mesh/ui/CandidateCard.tsx` and exported from the feature barrel.\n- The empty results message is updated from the old generic message to: \"No agents found in these directories. Try scanning with greater depth or different directories.\"\n\n## Important: Initial State Sync\n\nBecause `useMeshScanRoots` fetches config asynchronously, `defaultRoots` may initially be `['~']` (the fallback) and then update once config loads. The `useState(defaultRoots)` only captures the initial value. To handle this, either:\n1. Use a `useEffect` to sync when `defaultRoots` changes, or\n2. Only render the DiscoveryView after config has loaded\n\nOption 1 is simpler:\n\n```tsx\nimport { useEffect } from 'react';\n\n// Inside component:\nconst [roots, setRoots] = useState<string[]>(defaultRoots);\nconst [hasInitialized, setHasInitialized] = useState(false);\n\nuseEffect(() => {\n  if (!hasInitialized && defaultRoots.length > 0) {\n    setRoots(defaultRoots);\n    setHasInitialized(true);\n  }\n}, [defaultRoots, hasInitialized]);\n```\n\n## Testing\n\nCreate `apps/client/src/layers/features/mesh/ui/__tests__/DiscoveryView.test.tsx`:\n\n```typescript\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport '@testing-library/jest-dom/vitest';\nimport type { ReactNode } from 'react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n\nconst mockUseMeshScanRoots = vi.fn().mockReturnValue({\n  defaultRoots: ['/Users/test'],\n  boundary: '/Users/test',\n  savedRoots: [],\n  saveScanRoots: vi.fn(),\n});\nconst mockUseDiscoverAgents = vi.fn().mockReturnValue({\n  mutate: vi.fn(),\n  data: undefined,\n  isPending: false,\n});\n\nvi.mock('@/layers/entities/mesh', () => ({\n  useMeshScanRoots: (...args: unknown[]) => mockUseMeshScanRoots(...args),\n  useDiscoverAgents: (...args: unknown[]) => mockUseDiscoverAgents(...args),\n}));\n\nvi.mock('@/layers/shared/ui', () => ({\n  DirectoryPicker: () => null,\n}));\nvi.mock('@/layers/shared/ui/badge', () => ({\n  Badge: ({ children, ...props }: any) => <span {...props}>{children}</span>,\n}));\n\nimport { DiscoveryView } from '../DiscoveryView';\n\nfunction createWrapper() {\n  const qc = new QueryClient({ defaultOptions: { queries: { retry: false } } });\n  return ({ children }: { children: ReactNode }) => (\n    <QueryClientProvider client={qc}>{children}</QueryClientProvider>\n  );\n}\n\ndescribe('DiscoveryView', () => {\n  beforeEach(() => vi.clearAllMocks());\n\n  it('renders hero headline in fullBleed mode', () => {\n    render(<DiscoveryView fullBleed />, { wrapper: createWrapper() });\n    expect(screen.getByText('Discover agents on this machine')).toBeInTheDocument();\n  });\n\n  it('does not render hero headline in compact mode', () => {\n    render(<DiscoveryView />, { wrapper: createWrapper() });\n    expect(screen.queryByText('Discover agents on this machine')).not.toBeInTheDocument();\n  });\n\n  it('renders scan button', () => {\n    render(<DiscoveryView />, { wrapper: createWrapper() });\n    expect(screen.getByRole('button', { name: /scan/i })).toBeInTheDocument();\n  });\n\n  it('shows advanced options toggle', () => {\n    render(<DiscoveryView />, { wrapper: createWrapper() });\n    expect(screen.getByText('Advanced options')).toBeInTheDocument();\n  });\n\n  it('expands advanced options to show depth slider', async () => {\n    render(<DiscoveryView />, { wrapper: createWrapper() });\n    await userEvent.click(screen.getByText('Advanced options'));\n    expect(screen.getByLabelText('Scan depth')).toBeInTheDocument();\n  });\n\n  it('shows updated empty results message', () => {\n    mockUseDiscoverAgents.mockReturnValue({\n      mutate: vi.fn(),\n      data: { candidates: [] },\n      isPending: false,\n    });\n    render(<DiscoveryView />, { wrapper: createWrapper() });\n    expect(screen.getByText(/No agents found in these directories/)).toBeInTheDocument();\n  });\n});\n```\n\n## Acceptance Criteria\n\n- `fullBleed` mode renders Radar icon, headline, and centered layout\n- Compact mode renders only scan input and results (no headline)\n- Uses `ScanRootInput` instead of plain text input\n- Roots persist to config immediately on add/remove via `saveScanRoots`\n- Advanced options section with depth slider (1-5, default 3)\n- Updated empty results message\n- All tests pass",
      "activeForm": "Creating DiscoveryView component",
      "size": "large",
      "priority": "high",
      "dependencies": ["1.3"],
      "parallelWith": ["2.1", "2.2"]
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "MeshPanel Rewrite",
      "subject": "[mesh-panel-ux-overhaul] [P3] Refactor MeshPanel for Mode A/B conditional rendering",
      "description": "Rewrite `MeshPanel.tsx` to implement the two visual modes: Mode A (Discovery-only, zero agents) and Mode B (full tabbed interface, one or more agents). Add controlled tab state for CTA-driven tab switching, AnimatePresence transitions, and contextual empty states.\n\n## Implementation\n\nRewrite `apps/client/src/layers/features/mesh/ui/MeshPanel.tsx`:\n\n```tsx\nimport { lazy, Suspense, useState } from 'react';\nimport { Loader2, Network, Shield, ShieldCheck } from 'lucide-react';\nimport { AnimatePresence, motion } from 'motion/react';\nimport { Tabs, TabsList, TabsTrigger, TabsContent } from '@/layers/shared/ui';\nimport {\n  useMeshEnabled,\n  useRegisteredAgents,\n  useDeniedAgents,\n  useUnregisterAgent,\n} from '@/layers/entities/mesh';\nimport type { AgentManifest, DenialRecord } from '@dorkos/shared/mesh-schemas';\nimport { Badge } from '@/layers/shared/ui/badge';\nimport { MeshStatsHeader } from './MeshStatsHeader';\nimport { AgentHealthDetail } from './AgentHealthDetail';\nimport { TopologyPanel } from './TopologyPanel';\nimport { DiscoveryView } from './DiscoveryView';\nimport { MeshEmptyState } from './MeshEmptyState';\n\nconst LazyTopologyGraph = lazy(() =>\n  import('./TopologyGraph').then((m) => ({ default: m.TopologyGraph })),\n);\n\n// -- Agents Tab --\n\ninterface AgentsTabProps {\n  agents: AgentManifest[];\n  isLoading: boolean;\n  onGoToDiscovery: () => void;\n}\n\nfunction AgentsTab({ agents, isLoading, onGoToDiscovery }: AgentsTabProps) {\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center p-8\">\n        <Loader2 className=\"size-5 animate-spin text-muted-foreground\" />\n      </div>\n    );\n  }\n\n  if (agents.length === 0) {\n    return (\n      <MeshEmptyState\n        icon={<Network className=\"size-8\" />}\n        headline=\"No agents registered yet\"\n        description=\"Run a discovery scan to find compatible agents, then register them to join the mesh.\"\n        action={{ label: 'Go to Discovery', onClick: onGoToDiscovery }}\n      />\n    );\n  }\n\n  return (\n    <div className=\"space-y-2 p-4\">\n      {agents.map((agent) => (\n        <AgentCard key={agent.id} agent={agent} />\n      ))}\n    </div>\n  );\n}\n\nfunction AgentCard({ agent }: { agent: AgentManifest }) {\n  const { mutate: unregister } = useUnregisterAgent();\n  // (Same implementation as current AgentCard — see existing code)\n  // Keep the existing card rendering with unregister button\n  return (\n    <div className=\"space-y-1 rounded-xl border p-4\">\n      {/* ... existing AgentCard content ... */}\n    </div>\n  );\n}\n\n// -- Denied Tab --\n\ninterface DeniedTabProps {\n  denied: DenialRecord[];\n  isLoading: boolean;\n}\n\nfunction DeniedTab({ denied, isLoading }: DeniedTabProps) {\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center p-8\">\n        <Loader2 className=\"size-5 animate-spin text-muted-foreground\" />\n      </div>\n    );\n  }\n\n  if (denied.length === 0) {\n    return (\n      <MeshEmptyState\n        icon={<ShieldCheck className=\"size-8\" />}\n        headline=\"No blocked paths\"\n        description=\"Paths you deny during discovery will appear here, preventing those agents from joining the mesh.\"\n      />\n    );\n  }\n\n  return (\n    <div className=\"space-y-2 p-4\">\n      {denied.map((d) => (\n        <div key={d.path} className=\"flex items-center justify-between rounded-xl border px-4 py-3\">\n          <div>\n            <p className=\"font-mono text-sm\">{d.path}</p>\n            {d.reason && <p className=\"text-xs text-muted-foreground\">{d.reason}</p>}\n          </div>\n          <Badge variant=\"outline\" className=\"text-xs\">{d.strategy}</Badge>\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// -- Access Tab --\n\ninterface AccessTabProps {\n  onGoToDiscovery: () => void;\n}\n\nfunction AccessTab({ onGoToDiscovery }: AccessTabProps) {\n  // TopologyPanel handles its own data fetching.\n  // Wrap with an empty state check if the access data is empty.\n  // For now, TopologyPanel renders its own content; we add an empty state wrapper.\n  return <TopologyPanel emptyState={\n    <MeshEmptyState\n      icon={<Shield className=\"size-8\" />}\n      headline=\"Cross-project access requires multiple namespaces\"\n      description=\"Register agents from different projects to configure which namespaces can communicate.\"\n      action={{ label: 'Go to Discovery', onClick: onGoToDiscovery }}\n    />\n  } />;\n}\n\n// -- Main Panel --\n\n/** Main Mesh panel — Mode A (Discovery-only) when no agents, Mode B (full tabs) when agents exist. */\nexport function MeshPanel() {\n  const meshEnabled = useMeshEnabled();\n  const { data: agentsResult, isLoading: agentsLoading } = useRegisteredAgents(undefined, meshEnabled);\n  const agents = agentsResult?.agents ?? [];\n  const { data: deniedResult, isLoading: deniedLoading } = useDeniedAgents(meshEnabled);\n  const denied = deniedResult?.denied ?? [];\n  const [selectedAgentId, setSelectedAgentId] = useState<string | null>(null);\n  const [activeTab, setActiveTab] = useState('topology');\n\n  const hasAgents = agents.length > 0;\n\n  if (!meshEnabled) {\n    return (\n      <div className=\"flex flex-col items-center justify-center gap-3 p-8 text-center\">\n        <Network className=\"size-8 text-muted-foreground/50\" />\n        <div>\n          <p className=\"font-medium\">Mesh is not enabled</p>\n          <p className=\"mt-1 text-sm text-muted-foreground\">\n            Mesh provides agent discovery and registry. Start DorkOS with mesh enabled.\n          </p>\n        </div>\n        <code className=\"mt-2 rounded-md bg-muted px-3 py-1.5 font-mono text-sm\">\n          DORKOS_MESH_ENABLED=true dorkos\n        </code>\n      </div>\n    );\n  }\n\n  // Mode A: No registered agents — show Discovery-only view\n  if (!hasAgents) {\n    return <DiscoveryView fullBleed />;\n  }\n\n  // Mode B: Agents exist — show full tabbed interface\n  return (\n    <Tabs value={activeTab} onValueChange={setActiveTab} className=\"flex h-full flex-col\">\n      <AnimatePresence>\n        <motion.div\n          initial={{ opacity: 0, y: -20 }}\n          animate={{ opacity: 1, y: 0 }}\n          exit={{ opacity: 0, y: -20 }}\n          transition={{ duration: 0.2 }}\n        >\n          <MeshStatsHeader />\n          <TabsList className=\"mx-4 mt-3 shrink-0\">\n            <TabsTrigger value=\"topology\">Topology</TabsTrigger>\n            <TabsTrigger value=\"discovery\">Discovery</TabsTrigger>\n            <TabsTrigger value=\"agents\">Agents</TabsTrigger>\n            <TabsTrigger value=\"denied\">Denied</TabsTrigger>\n            <TabsTrigger value=\"access\">Access</TabsTrigger>\n          </TabsList>\n        </motion.div>\n      </AnimatePresence>\n\n      <TabsContent value=\"topology\" className=\"flex flex-1 overflow-hidden\">\n        <div className=\"flex-1\">\n          <Suspense\n            fallback={\n              <div className=\"flex h-full items-center justify-center text-sm text-muted-foreground\">\n                Loading topology...\n              </div>\n            }\n          >\n            <LazyTopologyGraph onSelectAgent={setSelectedAgentId} />\n          </Suspense>\n        </div>\n        {selectedAgentId && (\n          <AgentHealthDetail\n            agentId={selectedAgentId}\n            onClose={() => setSelectedAgentId(null)}\n          />\n        )}\n      </TabsContent>\n\n      <TabsContent value=\"discovery\" className=\"min-h-0 flex-1 overflow-y-auto\">\n        <DiscoveryView />\n      </TabsContent>\n\n      <TabsContent value=\"agents\" className=\"min-h-0 flex-1 overflow-y-auto\">\n        <AgentsTab\n          agents={agents}\n          isLoading={agentsLoading}\n          onGoToDiscovery={() => setActiveTab('discovery')}\n        />\n      </TabsContent>\n\n      <TabsContent value=\"denied\" className=\"min-h-0 flex-1 overflow-y-auto\">\n        <DeniedTab denied={denied} isLoading={deniedLoading} />\n      </TabsContent>\n\n      <TabsContent value=\"access\" className=\"min-h-0 flex-1 overflow-y-auto\">\n        <AccessTab onGoToDiscovery={() => setActiveTab('discovery')} />\n      </TabsContent>\n    </Tabs>\n  );\n}\n```\n\n## Key Changes from Current Implementation\n\n1. **Mode A/B split**: When `agents.length === 0`, render `<DiscoveryView fullBleed />` instead of the full tabbed interface. No tabs, no stats header — just the discovery view.\n2. **Controlled tabs**: Changed from `defaultValue=\"topology\"` to `value={activeTab} onValueChange={setActiveTab}`. This enables CTA buttons in empty states to switch tabs programmatically.\n3. **AnimatePresence**: The stats header and tab bar are wrapped in `motion.div` with `AnimatePresence` for the Mode A to Mode B transition animation.\n4. **Contextual empty states**: `AgentsTab` and `DeniedTab` now use `MeshEmptyState` instead of plain muted text.\n5. **AgentsTab gets `onGoToDiscovery` prop**: Allows the empty state CTA to switch to the discovery tab.\n6. **Discovery tab uses `DiscoveryView`**: Replaces the old inline `DiscoveryTab` function with the new extracted component.\n7. **Access tab empty state**: The `TopologyPanel` component may need an `emptyState` prop, or the access tab can be wrapped with a conditional check. Adjust based on `TopologyPanel`'s current API.\n\n## Important Notes on TopologyPanel/AccessTab\n\nThe `TopologyPanel` component is used for the Access tab. If `TopologyPanel` does not support an `emptyState` prop, create a simpler wrapper:\n\n```tsx\nfunction AccessTab({ onGoToDiscovery }: AccessTabProps) {\n  // If TopologyPanel handles its own empty state internally, just render it.\n  // Otherwise, check if there are access rules and show MeshEmptyState when empty.\n  return <TopologyPanel />;\n}\n```\n\nAnd update `TopologyPanel` separately to show the MeshEmptyState when it has no data.\n\n## Barrel Export Updates\n\nIn `apps/client/src/layers/features/mesh/index.ts`, add exports for the new components:\n\n```typescript\nexport { DiscoveryView } from './ui/DiscoveryView';\nexport { ScanRootInput } from './ui/ScanRootInput';\nexport { MeshEmptyState } from './ui/MeshEmptyState';\n```\n\n## Acceptance Criteria\n\n- Mode A: When no agents are registered, only DiscoveryView (fullBleed) is shown — no tabs, no stats header\n- Mode B: When agents exist, full tabbed interface is shown with stats header and all 5 tabs\n- Tab switching works via controlled state — CTA buttons in empty states can switch to Discovery tab\n- AnimatePresence wraps the stats header + tab bar for smooth Mode A to Mode B transition\n- Empty states use MeshEmptyState with contextual copy and CTAs\n- DiscoveryView used in both modes (fullBleed in Mode A, compact in Mode B Discovery tab)\n- Barrel exports updated\n- `pnpm typecheck` passes",
      "activeForm": "Refactoring MeshPanel for Mode A/B rendering",
      "size": "large",
      "priority": "high",
      "dependencies": ["2.1", "2.2", "2.3"],
      "parallelWith": []
    },
    {
      "id": "4.1",
      "phase": 4,
      "phaseName": "Tests + Polish",
      "subject": "[mesh-panel-ux-overhaul] [P4] Update MeshPanel tests for Mode A/B behavior",
      "description": "Rewrite `apps/client/src/layers/features/mesh/__tests__/MeshPanel.test.tsx` to cover the new Mode A/B conditional rendering, controlled tab state, CTA-driven tab switching, and contextual empty states.\n\n## Implementation\n\nThe existing test file mocks entity hooks and renders MeshPanel in various states. The key changes:\n\n1. Add mocks for `useMeshScanRoots` (new hook used by DiscoveryView)\n2. Add Mode A tests (no agents = Discovery-only view)\n3. Update Mode B tests (agents exist = full tabbed interface)\n4. Add empty state CTA tests (clicking \"Go to Discovery\" switches tab)\n5. Mock `motion/react` to render plain elements (existing pattern in codebase)\n\nRewrite `apps/client/src/layers/features/mesh/__tests__/MeshPanel.test.tsx`:\n\n```typescript\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { render, screen, fireEvent, cleanup } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport '@testing-library/jest-dom/vitest';\nimport type { ReactNode } from 'react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n\n// ---------------------------------------------------------------------------\n// Mock entity hooks\n// ---------------------------------------------------------------------------\n\nconst mockUseMeshEnabled = vi.fn().mockReturnValue(false);\nconst mockUseRegisteredAgents = vi.fn().mockReturnValue({ data: undefined, isLoading: false });\nconst mockUseDiscoverAgents = vi.fn().mockReturnValue({ mutate: vi.fn(), data: undefined, isPending: false });\nconst mockUseDeniedAgents = vi.fn().mockReturnValue({ data: undefined, isLoading: false });\nconst mockUseUnregisterAgent = vi.fn().mockReturnValue({ mutate: vi.fn() });\nconst mockUseMeshStatus = vi.fn().mockReturnValue({ data: undefined, isLoading: false });\nconst mockUseMeshAgentHealth = vi.fn().mockReturnValue({ data: undefined, isLoading: false });\nconst mockUseTopology = vi.fn().mockReturnValue({ data: undefined, isLoading: false });\nconst mockUseUpdateAccessRule = vi.fn().mockReturnValue({ mutate: vi.fn(), isPending: false });\nconst mockUseMeshScanRoots = vi.fn().mockReturnValue({\n  defaultRoots: ['/Users/test'],\n  boundary: '/Users/test',\n  savedRoots: [],\n  saveScanRoots: vi.fn(),\n});\n\nvi.mock('@/layers/entities/mesh', () => ({\n  useMeshEnabled: (...args: unknown[]) => mockUseMeshEnabled(...args),\n  useRegisteredAgents: (...args: unknown[]) => mockUseRegisteredAgents(...args),\n  useDiscoverAgents: (...args: unknown[]) => mockUseDiscoverAgents(...args),\n  useDeniedAgents: (...args: unknown[]) => mockUseDeniedAgents(...args),\n  useUnregisterAgent: (...args: unknown[]) => mockUseUnregisterAgent(...args),\n  useMeshStatus: (...args: unknown[]) => mockUseMeshStatus(...args),\n  useMeshAgentHealth: (...args: unknown[]) => mockUseMeshAgentHealth(...args),\n  useTopology: (...args: unknown[]) => mockUseTopology(...args),\n  useUpdateAccessRule: (...args: unknown[]) => mockUseUpdateAccessRule(...args),\n  useMeshScanRoots: (...args: unknown[]) => mockUseMeshScanRoots(...args),\n}));\n\n// Mock motion/react to render plain elements\nvi.mock('motion/react', () => ({\n  AnimatePresence: ({ children }: { children?: ReactNode }) => <>{children}</>,\n  motion: {\n    div: ({ children, ...props }: Record<string, unknown> & { children?: ReactNode }) => (\n      <div {...props}>{children}</div>\n    ),\n  },\n}));\n\n// Mock radix tabs (same as before — renders all panels)\nvi.mock('@radix-ui/react-tabs', () => ({\n  Root: ({ children, ...props }: Record<string, unknown> & { children?: ReactNode }) => (\n    <div {...props}>{children}</div>\n  ),\n  List: ({ children, ...props }: Record<string, unknown> & { children?: ReactNode }) => (\n    <div role=\"tablist\" {...props}>{children}</div>\n  ),\n  Trigger: ({\n    children, value, ...props\n  }: Record<string, unknown> & { children?: ReactNode; value?: string }) => (\n    <button role=\"tab\" data-value={value} {...props}>{children}</button>\n  ),\n  Content: ({ children, ...props }: Record<string, unknown> & { children?: ReactNode }) => (\n    <div role=\"tabpanel\" {...props}>{children}</div>\n  ),\n}));\n\n// Mock lazy-loaded TopologyGraph\nvi.mock('../ui/TopologyGraph', () => ({\n  TopologyGraph: ({ onSelectAgent }: { onSelectAgent?: (id: string) => void }) => (\n    <div data-testid=\"topology-graph\" onClick={() => onSelectAgent?.('agent-1')} />\n  ),\n}));\n\n// Mock DirectoryPicker\nvi.mock('@/layers/shared/ui', async (importOriginal) => {\n  const actual = await importOriginal() as Record<string, unknown>;\n  return { ...actual, DirectoryPicker: () => null };\n});\n\nimport { MeshPanel } from '../ui/MeshPanel';\n\n// ---------------------------------------------------------------------------\n// Helpers\n// ---------------------------------------------------------------------------\n\nconst mockAgent = {\n  id: 'agent-1',\n  name: 'Test Agent',\n  runtime: 'claude-code',\n  description: 'A test agent',\n  capabilities: ['code'],\n  namespace: 'test-project',\n  version: '1.0.0',\n};\n\nfunction createWrapper() {\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: { retry: false, gcTime: 0 },\n      mutations: { retry: false },\n    },\n  });\n  return ({ children }: { children: ReactNode }) => (\n    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n  );\n}\n\nfunction enableMesh() {\n  mockUseMeshEnabled.mockReturnValue(true);\n  mockUseRegisteredAgents.mockReturnValue({ data: { agents: [] }, isLoading: false });\n  mockUseDeniedAgents.mockReturnValue({ data: { denied: [] }, isLoading: false });\n}\n\nfunction enableMeshWithAgents() {\n  mockUseMeshEnabled.mockReturnValue(true);\n  mockUseRegisteredAgents.mockReturnValue({\n    data: { agents: [mockAgent] },\n    isLoading: false,\n  });\n  mockUseDeniedAgents.mockReturnValue({ data: { denied: [] }, isLoading: false });\n}\n\nbeforeEach(() => {\n  vi.clearAllMocks();\n  mockUseMeshEnabled.mockReturnValue(false);\n  mockUseRegisteredAgents.mockReturnValue({ data: undefined, isLoading: false });\n  mockUseDiscoverAgents.mockReturnValue({ mutate: vi.fn(), data: undefined, isPending: false });\n  mockUseDeniedAgents.mockReturnValue({ data: undefined, isLoading: false });\n  mockUseUnregisterAgent.mockReturnValue({ mutate: vi.fn() });\n  mockUseMeshStatus.mockReturnValue({ data: undefined, isLoading: false });\n  mockUseMeshAgentHealth.mockReturnValue({ data: undefined, isLoading: false });\n  mockUseMeshScanRoots.mockReturnValue({\n    defaultRoots: ['/Users/test'],\n    boundary: '/Users/test',\n    savedRoots: [],\n    saveScanRoots: vi.fn(),\n  });\n});\n\nafterEach(cleanup);\n\n// ---------------------------------------------------------------------------\n// Disabled state\n// ---------------------------------------------------------------------------\n\ndescribe('MeshPanel - disabled state', () => {\n  it('renders disabled message when mesh is disabled', () => {\n    render(<MeshPanel />, { wrapper: createWrapper() });\n    expect(screen.getByText('Mesh is not enabled')).toBeInTheDocument();\n  });\n\n  it('does not render any tabs when disabled', () => {\n    render(<MeshPanel />, { wrapper: createWrapper() });\n    expect(screen.queryByRole('tablist')).not.toBeInTheDocument();\n  });\n});\n\n// ---------------------------------------------------------------------------\n// Mode A: Discovery-only (no agents)\n// ---------------------------------------------------------------------------\n\ndescribe('MeshPanel - Mode A (no agents)', () => {\n  beforeEach(enableMesh);\n\n  it('renders Discovery-only view when no agents registered', () => {\n    render(<MeshPanel />, { wrapper: createWrapper() });\n    expect(screen.getByText(/discover agents/i)).toBeInTheDocument();\n    expect(screen.queryByRole('tablist')).not.toBeInTheDocument();\n  });\n\n  it('does not render MeshStatsHeader in Mode A', () => {\n    render(<MeshPanel />, { wrapper: createWrapper() });\n    // MeshStatsHeader renders agent count text — should not be present\n    expect(screen.queryByText(/agents/i)).not.toBeInTheDocument();\n  });\n\n  it('shows scan button', () => {\n    render(<MeshPanel />, { wrapper: createWrapper() });\n    expect(screen.getByRole('button', { name: /scan/i })).toBeInTheDocument();\n  });\n});\n\n// ---------------------------------------------------------------------------\n// Mode B: Full tabbed interface (agents exist)\n// ---------------------------------------------------------------------------\n\ndescribe('MeshPanel - Mode B (with agents)', () => {\n  beforeEach(enableMeshWithAgents);\n\n  it('renders all 5 tabs when agents exist', () => {\n    render(<MeshPanel />, { wrapper: createWrapper() });\n    expect(screen.getByRole('tablist')).toBeInTheDocument();\n    expect(screen.getByRole('tab', { name: 'Topology' })).toBeInTheDocument();\n    expect(screen.getByRole('tab', { name: 'Discovery' })).toBeInTheDocument();\n    expect(screen.getByRole('tab', { name: 'Agents' })).toBeInTheDocument();\n    expect(screen.getByRole('tab', { name: 'Denied' })).toBeInTheDocument();\n    expect(screen.getByRole('tab', { name: 'Access' })).toBeInTheDocument();\n  });\n\n  it('renders topology graph', () => {\n    render(<MeshPanel />, { wrapper: createWrapper() });\n    expect(screen.getByTestId('topology-graph')).toBeInTheDocument();\n  });\n});\n\n// ---------------------------------------------------------------------------\n// Empty state CTAs\n// ---------------------------------------------------------------------------\n\ndescribe('MeshPanel - empty state CTAs', () => {\n  it('shows \"No blocked paths\" empty state in Denied tab when denied list is empty', () => {\n    enableMeshWithAgents();\n    render(<MeshPanel />, { wrapper: createWrapper() });\n    expect(screen.getByText('No blocked paths')).toBeInTheDocument();\n  });\n});\n```\n\n## Acceptance Criteria\n\n- Disabled state tests still pass\n- Mode A tests verify: no tablist, discovery headline visible, scan button visible\n- Mode B tests verify: tablist with 5 tabs, topology graph rendered\n- Empty state tests verify contextual copy in Denied tab\n- motion/react mock prevents animation-related test failures\n- All existing passing tests continue to pass (or are updated for new behavior)\n- `pnpm vitest run apps/client/src/layers/features/mesh/__tests__/MeshPanel.test.tsx` passes",
      "activeForm": "Updating MeshPanel tests for Mode A/B",
      "size": "large",
      "priority": "high",
      "dependencies": ["3.1"],
      "parallelWith": ["4.2"]
    },
    {
      "id": "4.2",
      "phase": 4,
      "phaseName": "Tests + Polish",
      "subject": "[mesh-panel-ux-overhaul] [P4] Verify animation reduced-motion and config round-trip",
      "description": "Final polish pass to verify AnimatePresence respects `prefers-reduced-motion`, config persistence works end-to-end, and run typecheck across the monorepo.\n\n## Implementation Steps\n\n### 1. Verify Reduced Motion\n\nThe app already wraps in `<MotionConfig reducedMotion=\"user\">` in `App.tsx`. The Mode A to Mode B `AnimatePresence` transition will automatically respect this. No additional code needed, but verify in a test:\n\n```typescript\n// In MeshPanel.test.tsx or a new test file\nit('renders Mode B content without animation when motion is reduced', () => {\n  // With motion/react mocked to plain elements, animations are already stripped.\n  // This test verifies the content still renders correctly.\n  enableMeshWithAgents();\n  render(<MeshPanel />, { wrapper: createWrapper() });\n  expect(screen.getByRole('tablist')).toBeInTheDocument();\n});\n```\n\n### 2. Config Round-Trip Test\n\nVerify that saving scan roots via PATCH `/api/config` and reading them back via GET `/api/config` works correctly. This can be a server-side integration test or a manual verification step.\n\nServer-side test (add to config route tests if they exist):\n\n```typescript\ndescribe('Config - mesh.scanRoots round-trip', () => {\n  it('saves and reads back mesh.scanRoots', async () => {\n    // PATCH with scanRoots\n    const patchRes = await request(app)\n      .patch('/api/config')\n      .send({ mesh: { scanRoots: ['/projects', '/opt/agents'] } });\n    expect(patchRes.status).toBe(200);\n    expect(patchRes.body.success).toBe(true);\n\n    // GET config back\n    const getRes = await request(app).get('/api/config');\n    expect(getRes.status).toBe(200);\n    // The config response includes the saved mesh config\n    // (Note: GET /api/config returns server info, not raw config.\n    // The scanRoots are persisted in ~/.dork/config.json.\n    // Verify via configManager.get('mesh') if testing directly.)\n  });\n});\n```\n\n### 3. Typecheck\n\nRun `pnpm typecheck` to verify no type errors were introduced across the monorepo. This is especially important because:\n- The `UserConfig` type changed (new `scanRoots` field)\n- New components were added with new props\n- Entity hooks have new exports\n\n### 4. Lint Check\n\nRun `pnpm lint` to verify no ESLint issues. Key areas to check:\n- FSD layer imports (DiscoveryView importing from entities/mesh is valid)\n- No unused imports in refactored MeshPanel\n- TSDoc on new exported functions\n\n## Acceptance Criteria\n\n- `pnpm typecheck` passes with no errors\n- `pnpm lint` passes with no new errors\n- `pnpm test -- --run` passes all tests\n- Mode A to Mode B transition respects `prefers-reduced-motion` (via MotionConfig)\n- Config persistence: saving scanRoots via PATCH and reading via GET produces consistent results\n- No regressions in existing Mesh Panel functionality",
      "activeForm": "Verifying animations, config round-trip, and running checks",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["3.1"],
      "parallelWith": ["4.1"]
    }
  ]
}
