{
  "spec": "specs/mesh-topology-elevation/02-specification.md",
  "slug": "mesh-topology-elevation",
  "generatedAt": "2026-02-26T22:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Visual Foundation",
      "subject": "[mesh-topology-elevation] [P1] Add React Flow Background, MiniMap, and canvas configuration",
      "description": "Add React Flow built-in components to `TopologyGraph.tsx` for spatial context and design system compliance.\n\n**Files to modify:**\n- `apps/client/src/layers/features/mesh/ui/TopologyGraph.tsx`\n\n**Implementation Steps:**\n\n1. Add imports for `Background`, `MiniMap` from `@xyflow/react`.\n\n2. Update the `<ReactFlow>` component with new props:\n```tsx\n<ReactFlow\n  nodes={nodes}\n  edges={edges}\n  nodeTypes={NODE_TYPES}\n  edgeTypes={EDGE_TYPES}\n  onNodeClick={handleNodeClick}\n  fitView\n  fitViewOptions={{ duration: 400, padding: 0.15 }}\n  colorMode=\"system\"\n  onlyRenderVisibleElements\n  nodesConnectable={false}\n  proOptions={{ hideAttribution: true }}\n>\n  <Background variant=\"dots\" gap={20} size={1} color=\"var(--color-border)\" />\n  <MiniMap\n    nodeColor={(n) => n.data?.namespaceColor ?? '#94a3b8'}\n    pannable\n    zoomable\n    style={{ height: 80 }}\n  />\n  <Controls showInteractive={false} />\n  <TopologyLegend namespaces={legendEntries} />\n</ReactFlow>\n```\n\n3. Add a CSS class wrapper `topology-container` around the ReactFlow container and add these CSS variable overrides in the component or a co-located CSS file:\n```css\n.topology-container .react-flow {\n  --xy-background-pattern-dots-color-default: var(--color-border);\n  --xy-node-background-color-default: var(--color-card);\n  --xy-node-border-default: 1px solid var(--color-border);\n  --xy-node-boxshadow-hover-default: 0 0 0 2px var(--color-primary);\n  --xy-node-boxshadow-selected-default: 0 0 0 2px var(--color-primary);\n  --xy-edge-stroke-default: var(--color-border);\n  --xy-edge-stroke-width-default: 1.5;\n}\n```\n\n4. Update the outer `<div>` to include the `topology-container` class:\n```tsx\n<div className=\"topology-container absolute inset-0\">\n```\n\n**Acceptance Criteria:**\n- [ ] Background dot grid visible on canvas in both light and dark mode\n- [ ] MiniMap renders in bottom-right corner with namespace-colored nodes\n- [ ] MiniMap is pannable and zoomable\n- [ ] `fitView` animates on initial load with 400ms duration and 0.15 padding\n- [ ] `colorMode=\"system\"` correctly follows dark/light system preference\n- [ ] `onlyRenderVisibleElements` is set for performance\n- [ ] `nodesConnectable={false}` prevents edge creation via dragging\n- [ ] CSS variables use design system tokens, no hardcoded colors\n- [ ] Controls still render with `showInteractive={false}`",
      "activeForm": "Adding React Flow Background, MiniMap, and canvas configuration",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.2", "1.3"]
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Visual Foundation",
      "subject": "[mesh-topology-elevation] [P1] Add auto-refresh polling to topology query",
      "description": "Add 15-second auto-refresh polling to `useTopology()` and ensure `fitView` only triggers on initial load, not on refetches.\n\n**Files to modify:**\n- `apps/client/src/layers/entities/mesh/model/use-mesh-topology.ts`\n- `apps/client/src/layers/features/mesh/ui/TopologyGraph.tsx`\n\n**Implementation Steps:**\n\n1. In `use-mesh-topology.ts`, add `refetchInterval: 15_000` to the query options:\n```tsx\nexport function useTopology(namespace?: string, enabled = true) {\n  const transport = useTransport();\n\n  return useQuery({\n    queryKey: [...TOPOLOGY_KEY, namespace],\n    queryFn: () => transport.getMeshTopology(namespace),\n    enabled,\n    staleTime: 30_000,\n    refetchInterval: 15_000,\n  });\n}\n```\n\n2. In `TopologyGraph.tsx`, add a `useRef` to track first load and prevent `fitView` from re-triggering on refetches:\n```tsx\nimport { useMemo, useCallback, useRef } from 'react';\n\n// Inside TopologyGraph component:\nconst isFirstLoad = useRef(true);\n\n// In the useMemo that builds nodes/edges, after nodes are built:\n// The fitView prop on ReactFlow handles initial layout.\n// On refetches, nodes maintain their positions because React Flow\n// diffs the node/edge arrays and only updates changed properties.\n```\n\nNote: React Flow's `fitView` prop with `fitViewOptions` only triggers on initial mount. Subsequent data updates from polling will update node data without re-fitting the view, which is the desired behavior. No additional `isFirstLoad` logic is needed since `fitView` is a mount-time prop.\n\n**Acceptance Criteria:**\n- [ ] Topology data refetches every 15 seconds automatically\n- [ ] `fitView` only triggers on initial mount, not on polling refetches\n- [ ] Node positions remain stable during auto-refresh\n- [ ] Network tab shows GET /api/mesh/topology requests every ~15s\n- [ ] Tests: verify `useTopology` is called with `refetchInterval: 15000`",
      "activeForm": "Adding auto-refresh polling to topology query",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1", "1.3"]
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Visual Foundation",
      "subject": "[mesh-topology-elevation] [P1] Create DenyEdge component and register deny rules in topology",
      "description": "Create a new `DenyEdge` component for deny rules and update topology construction to include deny rules as edges.\n\n**New file:**\n- `apps/client/src/layers/features/mesh/ui/DenyEdge.tsx`\n\n**Files to modify:**\n- `apps/client/src/layers/features/mesh/ui/TopologyGraph.tsx`\n\n**DenyEdge Implementation (`DenyEdge.tsx`):**\n```tsx\nimport { useState, useCallback } from 'react';\nimport { BaseEdge, getBezierPath, type EdgeProps } from '@xyflow/react';\n\n/** Edge component for cross-namespace deny rules. Red dashed line with reduced opacity. */\nexport function DenyEdge(props: EdgeProps) {\n  const [isHovered, setIsHovered] = useState(false);\n  const [edgePath] = getBezierPath({\n    sourceX: props.sourceX,\n    sourceY: props.sourceY,\n    sourcePosition: props.sourcePosition,\n    targetX: props.targetX,\n    targetY: props.targetY,\n    targetPosition: props.targetPosition,\n  });\n\n  const handleMouseEnter = useCallback(() => setIsHovered(true), []);\n  const handleMouseLeave = useCallback(() => setIsHovered(false), []);\n\n  return (\n    <g onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>\n      <BaseEdge\n        id={props.id}\n        path={edgePath}\n        style={{\n          stroke: 'var(--color-destructive)',\n          strokeWidth: 1.5,\n          strokeDasharray: '4 4',\n          opacity: props.selected || isHovered ? 1 : 0.5,\n        }}\n      />\n    </g>\n  );\n}\n```\n\nKey properties:\n- Red dashed line using `var(--color-destructive)` CSS variable\n- 50% opacity by default, full on hover/select\n- No arrowhead marker (deny = no flow)\n- No animation or particle (deny is static)\n- Hover state tracked via local state\n\n**TopologyGraph changes:**\n\n1. Import the new DenyEdge and register in EDGE_TYPES:\n```tsx\nimport { DenyEdge } from './DenyEdge';\n\nconst EDGE_TYPES: EdgeTypes = {\n  'namespace-internal': NamespaceEdge,\n  'cross-namespace': CrossNamespaceEdge,\n  'cross-namespace-deny': DenyEdge,\n};\n```\n\n2. Update the access rules loop to include deny rules (currently they are silently dropped with `if (rule.action !== 'allow') continue;`):\n```tsx\n// Replace the current allow-only loop with:\nfor (const rule of accessRules ?? []) {\n  const sourceHub = `hub:${rule.sourceNamespace}`;\n  const targetHub = `hub:${rule.targetNamespace}`;\n  rawEdges.push({\n    id: `e:${sourceHub}-${targetHub}-${rule.action}`,\n    source: sourceHub,\n    target: targetHub,\n    type: rule.action === 'allow' ? 'cross-namespace' : 'cross-namespace-deny',\n    animated: rule.action === 'allow',\n    data: { label: `${rule.sourceNamespace} \\u203a ${rule.targetNamespace}` },\n  });\n}\n```\n\n**Acceptance Criteria:**\n- [ ] DenyEdge renders as a red dashed line\n- [ ] DenyEdge uses `var(--color-destructive)` CSS variable, not hardcoded color\n- [ ] DenyEdge has 50% opacity by default, full opacity on hover/select\n- [ ] DenyEdge has no arrowhead marker\n- [ ] DenyEdge has no `<animateMotion>` or animation elements\n- [ ] Deny rules from `accessRules` array now create `cross-namespace-deny` edges\n- [ ] Allow rules still create `cross-namespace` edges\n- [ ] Edge ID includes the action to avoid collisions between allow/deny for same namespace pair\n- [ ] Tests: DenyEdge renders red dashed line with correct CSS properties\n- [ ] Tests: DenyEdge at 50% opacity by default\n- [ ] Tests: TopologyGraph creates deny edge type for deny rules",
      "activeForm": "Creating DenyEdge component and registering deny rules",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1", "1.2"]
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "ELK.js Layout Migration",
      "subject": "[mesh-topology-elevation] [P2] Install elkjs, remove dagre, implement applyElkLayout",
      "description": "Replace dagre with ELK.js for all layout computation in `TopologyGraph.tsx`.\n\n**Package changes:**\n```bash\npnpm --filter=@dorkos/client add elkjs\npnpm --filter=@dorkos/client remove dagre\n# Also remove @types/dagre if present\npnpm --filter=@dorkos/client remove @types/dagre\n```\n\n**Files to modify:**\n- `apps/client/src/layers/features/mesh/ui/TopologyGraph.tsx`\n\n**Implementation Steps:**\n\n1. Remove dagre import and `applyDagreLayout` function entirely.\n\n2. Add ELK.js import and instantiation:\n```tsx\nimport ELK from 'elkjs/lib/elk.bundled.js';\n\nconst elk = new ELK();\n```\n\n3. Create the `applyElkLayout()` async function:\n```tsx\ninterface NamespaceLayoutInfo {\n  namespace: string;\n  agents: { id: string }[];\n}\n\nasync function applyElkLayout(\n  nodes: Node[],\n  edges: Edge[],\n  namespaces: NamespaceLayoutInfo[]\n): Promise<Node[]> {\n  const multiNamespace = namespaces.length > 1;\n\n  const children = multiNamespace\n    ? namespaces.map((ns) => ({\n        id: `group:${ns.namespace}`,\n        layoutOptions: {\n          'elk.padding': '[left=12, top=40, right=12, bottom=12]',\n        },\n        children: ns.agents.map((agent) => ({\n          id: agent.id,\n          width: 200,\n          height: 72,\n        })),\n      }))\n    : nodes.map((n) => ({\n        id: n.id,\n        width: n.type === 'agent' ? 200 : 120,\n        height: n.type === 'agent' ? 72 : 36,\n      }));\n\n  const elkEdges = edges.map((e) => ({\n    id: e.id,\n    sources: [e.source],\n    targets: [e.target],\n  }));\n\n  const graph = {\n    id: 'root',\n    layoutOptions: {\n      'elk.algorithm': 'layered',\n      'elk.direction': 'RIGHT',\n      'elk.spacing.nodeNode': '60',\n      'elk.spacing.edgeEdge': '20',\n      'elk.layered.spacing.nodeNodeBetweenLayers': '80',\n    },\n    children,\n    edges: elkEdges,\n  };\n\n  const layouted = await elk.layout(graph);\n\n  // Map ELK positions back to React Flow nodes\n  const positionMap = new Map<string, { x: number; y: number }>();\n\n  if (multiNamespace && layouted.children) {\n    for (const group of layouted.children) {\n      // Group node position\n      positionMap.set(group.id, { x: group.x ?? 0, y: group.y ?? 0 });\n      // Child agent positions are relative to the group\n      if (group.children) {\n        for (const child of group.children) {\n          positionMap.set(child.id, { x: child.x ?? 0, y: child.y ?? 0 });\n        }\n      }\n    }\n  } else if (layouted.children) {\n    for (const child of layouted.children) {\n      positionMap.set(child.id, { x: child.x ?? 0, y: child.y ?? 0 });\n    }\n  }\n\n  return nodes.map((node) => {\n    const pos = positionMap.get(node.id);\n    return pos ? { ...node, position: pos } : node;\n  });\n}\n```\n\n4. Replace the synchronous dagre layout call with async state management:\n```tsx\nconst [layoutedNodes, setLayoutedNodes] = useState<Node[]>([]);\nconst [isLayouting, setIsLayouting] = useState(true);\n\nuseEffect(() => {\n  if (!rawNodes.length) {\n    setLayoutedNodes([]);\n    setIsLayouting(false);\n    return;\n  }\n  setIsLayouting(true);\n  applyElkLayout(rawNodes, rawEdges, namespaceLayoutInfos)\n    .then(setLayoutedNodes)\n    .finally(() => setIsLayouting(false));\n}, [rawNodes, rawEdges, namespaceLayoutInfos]);\n```\n\n5. Show a loading skeleton while layout is computing:\n```tsx\nif (isLayouting && layoutedNodes.length === 0) {\n  return (\n    <div className=\"flex h-full items-center justify-center\">\n      <Loader2 className=\"h-5 w-5 animate-spin text-muted-foreground\" />\n    </div>\n  );\n}\n```\n\n6. Use `layoutedNodes` instead of `nodes` in the ReactFlow component.\n\n**Important:** The `useMemo` that currently builds rawNodes/rawEdges AND applies dagre layout must be split. The `useMemo` builds rawNodes/rawEdges, then a `useEffect` asynchronously applies ELK layout.\n\n**Performance note:** ELK.js uses `elkjs/lib/elk.bundled.js` (synchronous variant, ~150KB). At 3-50 node scale, layout computation is < 50ms so no web worker is needed. The component is already lazy-loaded via `React.lazy()` in MeshPanel.\n\n**Acceptance Criteria:**\n- [ ] `dagre` package fully removed from client dependencies\n- [ ] `elkjs` package added to client dependencies\n- [ ] `applyElkLayout()` produces positioned nodes with layered left-to-right layout\n- [ ] Loading skeleton shows during initial layout computation\n- [ ] Layout re-runs when topology data changes (via useEffect dependency)\n- [ ] No dagre imports remain in the codebase\n- [ ] Tests: ELK layout produces positioned nodes with x/y coordinates\n- [ ] Tests: Loading state shown while layout is computing",
      "activeForm": "Installing elkjs, removing dagre, implementing applyElkLayout",
      "size": "large",
      "priority": "high",
      "dependencies": ["1.1", "1.3"],
      "parallelWith": []
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "ELK.js Layout Migration",
      "subject": "[mesh-topology-elevation] [P2] Create NamespaceGroupNode and replace hub-spoke layout",
      "description": "Create a new `NamespaceGroupNode` component to replace `NamespaceHubNode` + spoke edges. Agents become children of group containers using React Flow's parent/child node system.\n\n**New file:**\n- `apps/client/src/layers/features/mesh/ui/NamespaceGroupNode.tsx`\n\n**Files to modify:**\n- `apps/client/src/layers/features/mesh/ui/TopologyGraph.tsx`\n\n**Files to remove:**\n- `apps/client/src/layers/features/mesh/ui/NamespaceHubNode.tsx`\n- `apps/client/src/layers/features/mesh/ui/NamespaceEdge.tsx`\n\n**NamespaceGroupNode Implementation (`NamespaceGroupNode.tsx`):**\n```tsx\nimport { memo } from 'react';\nimport type { NodeProps } from '@xyflow/react';\n\nexport interface NamespaceGroupData extends Record<string, unknown> {\n  namespace: string;\n  agentCount: number;\n  activeCount: number;\n  color: string;\n  collapsed: boolean;\n}\n\n/** Visual group container for agents within a namespace. Renders as a rounded box with namespace header. */\nfunction NamespaceGroupNodeComponent({ data }: NodeProps) {\n  const d = data as unknown as NamespaceGroupData;\n  return (\n    <div\n      className=\"rounded-xl border-2 bg-card/50\"\n      style={{\n        borderColor: `${d.color}40`,\n        backgroundColor: `${d.color}08`,\n        minWidth: 240,\n        minHeight: 100,\n      }}\n    >\n      <div\n        className=\"flex items-center gap-2 rounded-t-xl px-3 py-1.5\"\n        style={{ backgroundColor: `${d.color}15` }}\n      >\n        <span className=\"text-xs font-semibold\" style={{ color: d.color }}>\n          {d.namespace}\n        </span>\n        <span className=\"text-[10px] text-muted-foreground\">\n          {d.activeCount}/{d.agentCount} agents\n        </span>\n        {d.activeCount > 0 && (\n          <span\n            className=\"h-1.5 w-1.5 animate-pulse rounded-full\"\n            style={{ backgroundColor: d.color }}\n          />\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport const NamespaceGroupNode = memo(NamespaceGroupNodeComponent);\n```\n\n**TopologyGraph changes:**\n\n1. Remove imports: `NamespaceHubNode`, `NamespaceEdge`\n2. Add import: `NamespaceGroupNode`\n3. Update NODE_TYPES:\n```tsx\nconst NODE_TYPES: NodeTypes = {\n  agent: AgentNode,\n  'namespace-group': NamespaceGroupNode,\n};\n```\n\n4. Update EDGE_TYPES (remove `namespace-internal`):\n```tsx\nconst EDGE_TYPES: EdgeTypes = {\n  'cross-namespace': CrossNamespaceEdge,\n  'cross-namespace-deny': DenyEdge,\n};\n```\n\n5. Rewrite the node/edge construction in useMemo to use group containers instead of hub-spoke:\n```tsx\nconst multiNamespace = namespaces.length > 1;\n\nfor (let nsIdx = 0; nsIdx < namespaces.length; nsIdx++) {\n  const ns = namespaces[nsIdx];\n  const color = getNamespaceColor(nsIdx);\n  legend.push({ namespace: ns.namespace, color });\n\n  // Count active agents\n  const activeCount = ns.agents.filter(\n    (a) => (a as Record<string, unknown>).healthStatus === 'active'\n  ).length;\n\n  if (multiNamespace) {\n    // Create group container node\n    rawNodes.push({\n      id: `group:${ns.namespace}`,\n      type: 'namespace-group',\n      position: { x: 0, y: 0 },\n      data: {\n        namespace: ns.namespace,\n        agentCount: ns.agentCount,\n        activeCount,\n        color,\n        collapsed: false,\n      } satisfies NamespaceGroupData,\n    });\n  }\n\n  for (const agent of ns.agents) {\n    const agentNode: Node = {\n      id: agent.id,\n      type: 'agent',\n      position: { x: 0, y: 0 },\n      data: {\n        label: agent.name,\n        runtime: agent.runtime,\n        healthStatus:\n          ((agent as Record<string, unknown>).healthStatus as AgentNodeData['healthStatus']) ?? 'stale',\n        capabilities: agent.capabilities ?? [],\n        namespace: ns.namespace,\n        namespaceColor: color,\n      } satisfies AgentNodeData,\n    };\n\n    // If multi-namespace, nest agent inside group\n    if (multiNamespace) {\n      agentNode.parentId = `group:${ns.namespace}`;\n      agentNode.extent = 'parent';\n    }\n\n    rawNodes.push(agentNode);\n    // NO spoke edges — agents are visually inside the group\n  }\n}\n\n// Cross-namespace edges connect agents or groups directly\nfor (const rule of accessRules ?? []) {\n  // For cross-namespace edges, connect first agent of each namespace\n  // (or the group node if preferred)\n  const sourceId = multiNamespace\n    ? `group:${rule.sourceNamespace}`\n    : namespaces.find((ns) => ns.namespace === rule.sourceNamespace)?.agents[0]?.id;\n  const targetId = multiNamespace\n    ? `group:${rule.targetNamespace}`\n    : namespaces.find((ns) => ns.namespace === rule.targetNamespace)?.agents[0]?.id;\n\n  if (!sourceId || !targetId) continue;\n\n  rawEdges.push({\n    id: `e:${rule.sourceNamespace}-${rule.targetNamespace}-${rule.action}`,\n    source: sourceId,\n    target: targetId,\n    type: rule.action === 'allow' ? 'cross-namespace' : 'cross-namespace-deny',\n    animated: rule.action === 'allow',\n    data: { label: `${rule.sourceNamespace} \\u203a ${rule.targetNamespace}` },\n  });\n}\n```\n\n6. Update `applyElkLayout` to return group nodes with computed width/height from ELK:\n```tsx\n// After ELK layout, also set group node dimensions from ELK output:\nif (multiNamespace && layouted.children) {\n  for (const group of layouted.children) {\n    const groupNode = nodes.find((n) => n.id === group.id);\n    if (groupNode) {\n      groupNode.style = {\n        width: group.width ?? 240,\n        height: group.height ?? 100,\n      };\n    }\n  }\n}\n```\n\n**Acceptance Criteria:**\n- [ ] `NamespaceHubNode.tsx` and `NamespaceEdge.tsx` are deleted\n- [ ] `NamespaceGroupNode` renders a rounded-xl container with namespace header\n- [ ] Header shows namespace name, active/total agent count, and pulse dot when active\n- [ ] Agent nodes have `parentId` and `extent: 'parent'` when multi-namespace\n- [ ] No spoke edges exist — agents are visually inside groups\n- [ ] Single-namespace topologies skip the group wrapper\n- [ ] Cross-namespace edges connect between group nodes (not hubs)\n- [ ] ELK layout correctly positions groups and child agents\n- [ ] Tests: NamespaceGroupNode renders namespace name and agent count\n- [ ] Tests: NamespaceGroupNode shows pulse glow when activeCount > 0\n- [ ] Tests: No spoke edges created in multi-namespace topology",
      "activeForm": "Creating NamespaceGroupNode and replacing hub-spoke layout",
      "size": "large",
      "priority": "high",
      "dependencies": ["2.1"],
      "parallelWith": []
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Node Enhancement",
      "subject": "[mesh-topology-elevation] [P3] Implement 3-level contextual zoom LOD for AgentNode",
      "description": "Read zoom level from React Flow's internal store and render three different detail levels in `AgentNode.tsx`.\n\n**Files to modify:**\n- `apps/client/src/layers/features/mesh/ui/AgentNode.tsx`\n\n**Implementation Steps:**\n\n1. Update the `AgentNodeData` interface with new fields:\n```tsx\nexport interface AgentNodeData extends Record<string, unknown> {\n  label: string;\n  runtime: string;\n  healthStatus: 'active' | 'inactive' | 'stale';\n  capabilities: string[];\n  namespace?: string;\n  namespaceColor?: string;\n  // NEW fields from server enrichment:\n  description?: string;\n  relayAdapters?: string[];\n  relaySubject?: string | null;\n  pulseScheduleCount?: number;\n  lastSeenAt?: string | null;\n  lastSeenEvent?: string | null;\n  budget?: { maxHopsPerMessage: number; maxCallsPerHour: number };\n  behavior?: { responseMode: string };\n  // NEW fields from spec #66 identity:\n  color?: string | null;\n  emoji?: string | null;\n}\n```\n\n2. Add zoom selector and `useStore` import:\n```tsx\nimport { Handle, Position, type NodeProps, useStore, type ReactFlowState } from '@xyflow/react';\n\nconst zoomSelector = (s: ReactFlowState) => s.transform[2];\n```\n\n3. Refactor `AgentNodeComponent` to dispatch based on zoom level:\n```tsx\nfunction AgentNodeComponent({ data, selected }: NodeProps) {\n  const zoom = useStore(zoomSelector);\n  const d = data as unknown as AgentNodeData;\n\n  if (zoom < 0.6) return <CompactPill d={d} />;\n  if (zoom > 1.2) return <ExpandedCard d={d} selected={selected} />;\n  return <DefaultCard d={d} selected={selected} />;\n}\n```\n\n4. **CompactPill (zoom < 0.6, 120x28px):**\n```tsx\nfunction CompactPill({ d }: { d: AgentNodeData }) {\n  const dotColor = STATUS_COLORS[d.healthStatus] ?? STATUS_COLORS.stale;\n  const borderColor = d.color ?? d.namespaceColor;\n  return (\n    <div\n      className=\"flex h-7 items-center gap-1.5 rounded-full border bg-card px-2.5 shadow-sm\"\n      style={borderColor ? { borderLeft: `3px solid ${borderColor}` } : undefined}\n    >\n      <Handle type=\"target\" position={Position.Left} className=\"!bg-muted-foreground\" />\n      <span className={`h-2 w-2 shrink-0 rounded-full ${dotColor}`} />\n      <span className=\"max-w-[80px] truncate text-[11px] font-medium\">\n        {d.emoji ? `${d.emoji} ` : ''}{d.label}\n      </span>\n      <Handle type=\"source\" position={Position.Right} className=\"!bg-muted-foreground\" />\n    </div>\n  );\n}\n```\n\n5. **DefaultCard (zoom 0.6-1.2, 200x72px — enhanced from current):**\n```tsx\nfunction DefaultCard({ d, selected }: { d: AgentNodeData; selected?: boolean }) {\n  const dotColor = STATUS_COLORS[d.healthStatus] ?? STATUS_COLORS.stale;\n  const borderColor = d.color ?? d.namespaceColor;\n  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n\n  return (\n    <div\n      className=\"w-[200px] rounded-lg border bg-card px-3 py-2 shadow-sm transition-all duration-150 ease-in-out\"\n      style={borderColor ? { borderLeft: `3px solid ${borderColor}` } : undefined}\n    >\n      <Handle type=\"target\" position={Position.Left} className=\"!bg-muted-foreground\" />\n      <div className=\"flex items-center gap-2\">\n        <span className=\"relative\">\n          <span className={`h-2.5 w-2.5 shrink-0 rounded-full ${dotColor} block`} />\n          {d.healthStatus === 'active' && !prefersReducedMotion && (\n            <span className={`absolute inset-0 h-2.5 w-2.5 animate-ping rounded-full bg-green-500/30`} />\n          )}\n        </span>\n        <span className=\"flex-1 truncate text-sm font-medium\">\n          {d.emoji ? `${d.emoji} ` : ''}{d.label}\n        </span>\n        {/* Runtime as small icon — use first letter as badge for now */}\n        <span className=\"text-[10px] text-muted-foreground\">{RUNTIME_ICONS[d.runtime] ?? d.runtime}</span>\n      </div>\n      <div className=\"mt-1 flex flex-wrap gap-1\">\n        {d.capabilities.slice(0, 3).map((cap) => (\n          <Badge key={cap} variant=\"outline\" className=\"text-[10px]\">{cap}</Badge>\n        ))}\n        {d.capabilities.length > 3 && (\n          <Badge variant=\"secondary\" className=\"text-[10px]\">+{d.capabilities.length - 3}</Badge>\n        )}\n      </div>\n      {/* Indicator row */}\n      {(d.relayAdapters?.length || d.pulseScheduleCount) && (\n        <div className=\"mt-1.5 flex items-center gap-2 text-[10px] text-muted-foreground\">\n          {d.relayAdapters && d.relayAdapters.length > 0 && (\n            <span className=\"flex items-center gap-0.5\">\n              <Zap className=\"size-3\" />\n            </span>\n          )}\n          {d.pulseScheduleCount != null && d.pulseScheduleCount > 0 && (\n            <span className=\"flex items-center gap-0.5\">\n              <Clock className=\"size-3\" /> {d.pulseScheduleCount}\n            </span>\n          )}\n        </div>\n      )}\n      <Handle type=\"source\" position={Position.Right} className=\"!bg-muted-foreground\" />\n    </div>\n  );\n}\n```\n\n6. **ExpandedCard (zoom > 1.2, 240x120px):**\n```tsx\nfunction ExpandedCard({ d, selected }: { d: AgentNodeData; selected?: boolean }) {\n  const dotColor = STATUS_COLORS[d.healthStatus] ?? STATUS_COLORS.stale;\n  const borderColor = d.color ?? d.namespaceColor;\n  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n\n  return (\n    <div\n      className=\"w-[240px] rounded-lg border bg-card px-3 py-2 shadow-sm transition-all duration-150 ease-in-out\"\n      style={borderColor ? { borderLeft: `3px solid ${borderColor}` } : undefined}\n    >\n      <Handle type=\"target\" position={Position.Left} className=\"!bg-muted-foreground\" />\n      {/* Same header as DefaultCard */}\n      <div className=\"flex items-center gap-2\">\n        <span className=\"relative\">\n          <span className={`h-2.5 w-2.5 shrink-0 rounded-full ${dotColor} block`} />\n          {d.healthStatus === 'active' && !prefersReducedMotion && (\n            <span className=\"absolute inset-0 h-2.5 w-2.5 animate-ping rounded-full bg-green-500/30\" />\n          )}\n        </span>\n        <span className=\"flex-1 truncate text-sm font-medium\">\n          {d.emoji ? `${d.emoji} ` : ''}{d.label}\n        </span>\n        <span className=\"text-[10px] text-muted-foreground\">{RUNTIME_ICONS[d.runtime] ?? d.runtime}</span>\n      </div>\n\n      {/* Description */}\n      {d.description && (\n        <p className=\"mt-1 line-clamp-2 text-[11px] text-muted-foreground\">{d.description}</p>\n      )}\n\n      {/* Capabilities */}\n      <div className=\"mt-1 flex flex-wrap gap-1\">\n        {d.capabilities.slice(0, 5).map((cap) => (\n          <Badge key={cap} variant=\"outline\" className=\"text-[10px]\">{cap}</Badge>\n        ))}\n        {d.capabilities.length > 5 && (\n          <Badge variant=\"secondary\" className=\"text-[10px]\">+{d.capabilities.length - 5}</Badge>\n        )}\n      </div>\n\n      {/* Last seen */}\n      {d.lastSeenAt && (\n        <div className=\"mt-1 text-[10px] text-muted-foreground\">\n          Last seen: {relativeTime(d.lastSeenAt)}\n        </div>\n      )}\n\n      {/* Budget */}\n      {d.budget && (\n        <div className=\"mt-0.5 text-[10px] text-muted-foreground\">\n          {d.budget.maxCallsPerHour} calls/hr · {d.budget.maxHopsPerMessage} max hops\n        </div>\n      )}\n\n      {/* Relay adapters (named, not just icon) */}\n      {d.relayAdapters && d.relayAdapters.length > 0 && (\n        <div className=\"mt-1 flex items-center gap-1 text-[10px] text-muted-foreground\">\n          <Zap className=\"size-3\" />\n          {d.relayAdapters.join(', ')}\n        </div>\n      )}\n\n      {/* Pulse count */}\n      {d.pulseScheduleCount != null && d.pulseScheduleCount > 0 && (\n        <div className=\"mt-0.5 flex items-center gap-1 text-[10px] text-muted-foreground\">\n          <Clock className=\"size-3\" /> {d.pulseScheduleCount} schedules\n        </div>\n      )}\n\n      {/* Behavior mode badge */}\n      {d.behavior?.responseMode && d.behavior.responseMode !== 'always' && (\n        <Badge variant=\"secondary\" className=\"mt-1 text-[10px]\">{d.behavior.responseMode}</Badge>\n      )}\n\n      <Handle type=\"source\" position={Position.Right} className=\"!bg-muted-foreground\" />\n    </div>\n  );\n}\n```\n\n7. Add necessary imports at the top:\n```tsx\nimport { Zap, Clock } from 'lucide-react';\n```\n\n8. Add `RUNTIME_ICONS` constant and `relativeTime` helper:\n```tsx\nconst RUNTIME_ICONS: Record<string, string> = {\n  'claude-code': 'CC',\n  cursor: 'Cu',\n  codex: 'Cx',\n  other: '??',\n};\n\nfunction relativeTime(iso: string): string {\n  const diff = Date.now() - new Date(iso).getTime();\n  const mins = Math.floor(diff / 60_000);\n  if (mins < 1) return 'Just now';\n  if (mins < 60) return `${mins}m ago`;\n  const hours = Math.floor(mins / 60);\n  if (hours < 24) return `${hours}h ago`;\n  return `${Math.floor(hours / 24)}d ago`;\n}\n```\n\n9. Add smooth CSS transitions on the card wrapper with `transition-all duration-150 ease-in-out` (already included above).\n\n**Note on `useStore(zoomSelector)`:** The selector pattern ensures the component only re-renders when zoom changes, not on every store update. This is critical for performance.\n\n**Acceptance Criteria:**\n- [ ] Compact pill renders at zoom < 0.6 (pill shape, health dot + truncated name only)\n- [ ] Default card renders at zoom 0.6-1.2 (name, health dot with pulse ring, capabilities up to 3, indicator row)\n- [ ] Expanded card renders at zoom > 1.2 (description, budget, adapters by name, last seen, behavior mode)\n- [ ] Health pulse ring (`animate-ping`) shows only for active agents\n- [ ] Pulse ring respects `prefers-reduced-motion`\n- [ ] Relay Zap icon shows when `relayAdapters.length > 0`\n- [ ] Pulse Clock icon with count shows when `pulseScheduleCount > 0`\n- [ ] Agent color override applied to left border (falls back to namespace color)\n- [ ] Agent emoji prepended to name when present\n- [ ] Capability badges show up to 3 (default) or 5 (expanded) with `+N` overflow\n- [ ] Smooth CSS transition between zoom levels\n- [ ] Tests: Renders compact pill at zoom < 0.6 (mock useStore)\n- [ ] Tests: Renders default card at zoom 0.6-1.2\n- [ ] Tests: Renders expanded card at zoom > 1.2\n- [ ] Tests: Shows health pulse ring only for active agents\n- [ ] Tests: Hides indicators when data absent",
      "activeForm": "Implementing 3-level contextual zoom LOD for AgentNode",
      "size": "large",
      "priority": "high",
      "dependencies": ["2.2"],
      "parallelWith": ["3.2"]
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "Node Enhancement",
      "subject": "[mesh-topology-elevation] [P3] Update TopologyGraph node construction with enrichment data",
      "description": "Update the node construction in `TopologyGraph.tsx` to pass enrichment fields from the server response into `AgentNodeData`.\n\n**Files to modify:**\n- `apps/client/src/layers/features/mesh/ui/TopologyGraph.tsx`\n\n**Implementation Steps:**\n\nUpdate the agent node data construction inside the `useMemo` to include the new enrichment fields. The server will return these fields in the topology response (task 5.1), but the client code should be ready to accept them with safe defaults:\n\n```tsx\nfor (const agent of ns.agents) {\n  const enriched = agent as Record<string, unknown>;\n  const agentNode: Node = {\n    id: agent.id,\n    type: 'agent',\n    position: { x: 0, y: 0 },\n    data: {\n      label: agent.name,\n      runtime: agent.runtime,\n      healthStatus: (enriched.healthStatus as AgentNodeData['healthStatus']) ?? 'stale',\n      capabilities: agent.capabilities ?? [],\n      namespace: ns.namespace,\n      namespaceColor: color,\n      // Enrichment fields (defaults for backward compatibility)\n      description: agent.description || undefined,\n      relayAdapters: (enriched.relayAdapters as string[]) ?? [],\n      relaySubject: (enriched.relaySubject as string | null) ?? null,\n      pulseScheduleCount: (enriched.pulseScheduleCount as number) ?? 0,\n      lastSeenAt: (enriched.lastSeenAt as string | null) ?? null,\n      lastSeenEvent: (enriched.lastSeenEvent as string | null) ?? null,\n      budget: agent.budget ? { maxHopsPerMessage: agent.budget.maxHopsPerMessage, maxCallsPerHour: agent.budget.maxCallsPerHour } : undefined,\n      behavior: agent.behavior ? { responseMode: agent.behavior.responseMode } : undefined,\n      color: (enriched.color as string | null) ?? null,\n      emoji: (enriched.icon as string | null) ?? null,\n    } satisfies AgentNodeData,\n  };\n\n  if (multiNamespace) {\n    agentNode.parentId = `group:${ns.namespace}`;\n    agentNode.extent = 'parent';\n  }\n\n  rawNodes.push(agentNode);\n}\n```\n\nNote: The `icon` field from the `AgentManifest` schema maps to the `emoji` field in `AgentNodeData` (spec uses \"emoji\" in the client data model, but the schema uses \"icon\").\n\n**Acceptance Criteria:**\n- [ ] All enrichment fields are passed from topology response to AgentNodeData\n- [ ] Missing enrichment fields default safely (empty arrays, null, 0, undefined)\n- [ ] Budget and behavior objects extracted correctly\n- [ ] `icon` field from server maps to `emoji` field in AgentNodeData\n- [ ] Existing data still passes through correctly (no regressions)\n- [ ] Works with both enriched and non-enriched server responses",
      "activeForm": "Updating TopologyGraph node construction with enrichment data",
      "size": "small",
      "priority": "medium",
      "dependencies": ["2.2"],
      "parallelWith": ["3.1"]
    },
    {
      "id": "4.1",
      "phase": 4,
      "phaseName": "Interactions & Animations",
      "subject": "[mesh-topology-elevation] [P4] Add NodeToolbar quick actions to AgentNode",
      "description": "Add a floating NodeToolbar that appears when an agent node is selected, with Settings, Health, and Copy ID actions.\n\n**Files to modify:**\n- `apps/client/src/layers/features/mesh/ui/AgentNode.tsx`\n- `apps/client/src/layers/features/mesh/ui/TopologyGraph.tsx`\n\n**Implementation Steps:**\n\n1. In `AgentNode.tsx`, add NodeToolbar import and usage:\n```tsx\nimport { Handle, Position, type NodeProps, useStore, NodeToolbar, type ReactFlowState } from '@xyflow/react';\nimport { Settings, Heart, Copy } from 'lucide-react';\nimport { Tooltip, TooltipContent, TooltipTrigger, TooltipProvider } from '@/layers/shared/ui';\n```\n\n2. Add callback props to AgentNodeData:\n```tsx\nexport interface AgentNodeData extends Record<string, unknown> {\n  // ... existing fields ...\n  onOpenSettings?: (agentId: string) => void;\n  onViewHealth?: (agentId: string) => void;\n}\n```\n\n3. Add the NodeToolbar to the AgentNodeComponent (above the card render, inside the component):\n```tsx\nfunction AgentNodeComponent({ data, selected, id }: NodeProps) {\n  const zoom = useStore(zoomSelector);\n  const d = data as unknown as AgentNodeData;\n\n  const handleCopyId = useCallback(() => {\n    void navigator.clipboard.writeText(id);\n    // toast from sonner\n    toast.success('Agent ID copied');\n  }, [id]);\n\n  return (\n    <>\n      <NodeToolbar position={Position.Top} isVisible={selected}>\n        <div className=\"flex items-center gap-1 rounded-lg border bg-card px-1.5 py-1 shadow-md\">\n          <ToolbarButton\n            icon={Settings}\n            label=\"Settings\"\n            onClick={() => d.onOpenSettings?.(id)}\n          />\n          <ToolbarButton\n            icon={Heart}\n            label=\"Health\"\n            onClick={() => d.onViewHealth?.(id)}\n          />\n          <ToolbarButton\n            icon={Copy}\n            label=\"Copy ID\"\n            onClick={handleCopyId}\n          />\n        </div>\n      </NodeToolbar>\n      {/* Existing zoom LOD render */}\n      {zoom < 0.6 ? <CompactPill d={d} /> : zoom > 1.2 ? <ExpandedCard d={d} selected={selected} /> : <DefaultCard d={d} selected={selected} />}\n    </>\n  );\n}\n```\n\n4. Create the `ToolbarButton` sub-component:\n```tsx\ninterface ToolbarButtonProps {\n  icon: React.ComponentType<{ className?: string }>;\n  label: string;\n  onClick: () => void;\n}\n\nfunction ToolbarButton({ icon: Icon, label, onClick }: ToolbarButtonProps) {\n  return (\n    <Tooltip>\n      <TooltipTrigger asChild>\n        <button\n          type=\"button\"\n          onClick={onClick}\n          className=\"rounded p-1 text-muted-foreground hover:bg-muted hover:text-foreground\"\n          aria-label={label}\n        >\n          <Icon className=\"size-4\" />\n        </button>\n      </TooltipTrigger>\n      <TooltipContent side=\"top\" className=\"text-xs\">\n        {label}\n      </TooltipContent>\n    </Tooltip>\n  );\n}\n```\n\n5. In `TopologyGraph.tsx`, pass callback handlers through node data:\n```tsx\ndata: {\n  // ... existing fields ...\n  onOpenSettings: (agentId: string) => {\n    // Emit to MeshPanel (will be connected in task 4.2)\n    onOpenSettings?.(agentId);\n  },\n  onViewHealth: (agentId: string) => {\n    onSelectAgent?.(agentId);\n  },\n} satisfies AgentNodeData,\n```\n\n6. Update `TopologyGraphProps`:\n```tsx\ninterface TopologyGraphProps {\n  onSelectAgent?: (agentId: string) => void;\n  onOpenSettings?: (agentId: string) => void;\n}\n```\n\n**Note on Settings button:** The Settings button opens the Agent Settings Dialog from spec #66. If that spec is not yet implemented, the Settings button should be disabled or hidden. Check for the existence of the `AgentSettingsDialog` component. If unavailable, set `disabled` on the Settings ToolbarButton.\n\n**Acceptance Criteria:**\n- [ ] NodeToolbar appears when an agent node is selected\n- [ ] NodeToolbar positioned above the node (Position.Top)\n- [ ] NodeToolbar has 3 buttons: Settings (cog icon), Health (heart icon), Copy ID (copy icon)\n- [ ] Each button is 24x24px with Tooltip on hover\n- [ ] Copy ID copies agent ULID to clipboard and shows toast\n- [ ] Health button triggers `onSelectAgent` (opens AgentHealthDetail)\n- [ ] Settings button triggers `onOpenSettings` callback\n- [ ] NodeToolbar uses `bg-card border shadow-md rounded-lg` styling\n- [ ] NodeToolbar disappears when node is deselected\n- [ ] Tests: NodeToolbar visible when selected=true\n- [ ] Tests: Copy ID calls clipboard API",
      "activeForm": "Adding NodeToolbar quick actions to AgentNode",
      "size": "medium",
      "priority": "high",
      "dependencies": ["3.1"],
      "parallelWith": ["4.3", "4.4"]
    },
    {
      "id": "4.2",
      "phase": 4,
      "phaseName": "Interactions & Animations",
      "subject": "[mesh-topology-elevation] [P4] Integrate Agent Settings Dialog with topology",
      "description": "Wire up the Settings button in NodeToolbar to open the Agent Settings Dialog (spec #66 dependency). Add necessary state and callbacks in MeshPanel.\n\n**Files to modify:**\n- `apps/client/src/layers/features/mesh/ui/MeshPanel.tsx`\n- `apps/client/src/layers/features/mesh/ui/TopologyGraph.tsx`\n\n**Implementation Steps:**\n\n1. In `MeshPanel.tsx`, add state for the settings dialog:\n```tsx\nconst [settingsAgentId, setSettingsAgentId] = useState<string | null>(null);\n```\n\n2. Pass the `onOpenSettings` callback to `LazyTopologyGraph`:\n```tsx\n<LazyTopologyGraph\n  onSelectAgent={setSelectedAgentId}\n  onOpenSettings={setSettingsAgentId}\n/>\n```\n\n3. Conditionally render the Agent Settings Dialog (check if it exists from spec #66):\n```tsx\n// Import conditionally if spec #66 is implemented:\n// import { AgentDialog } from '@/layers/features/agent-settings';\n\n{settingsAgentId && (\n  <AgentDialog\n    agentId={settingsAgentId}\n    open={!!settingsAgentId}\n    onOpenChange={(open) => {\n      if (!open) setSettingsAgentId(null);\n    }}\n  />\n)}\n```\n\n4. If spec #66's `AgentDialog` is not yet available, create a placeholder that disables the Settings toolbar button:\n```tsx\n// In TopologyGraph, check for feature availability:\nconst hasAgentSettings = false; // Toggle when spec #66 is implemented\n\n// Pass to node data:\ndata: {\n  // ...\n  onOpenSettings: hasAgentSettings ? onOpenSettings : undefined,\n}\n```\n\nIn AgentNode, conditionally render the Settings ToolbarButton:\n```tsx\n{d.onOpenSettings && (\n  <ToolbarButton icon={Settings} label=\"Settings\" onClick={() => d.onOpenSettings?.(id)} />\n)}\n```\n\n5. On dialog save/close, invalidate the topology query to refresh node data:\n```tsx\nimport { useQueryClient } from '@tanstack/react-query';\n\nconst queryClient = useQueryClient();\n\n// After dialog save:\nonOpenChange={(open) => {\n  if (!open) {\n    setSettingsAgentId(null);\n    void queryClient.invalidateQueries({ queryKey: ['mesh', 'topology'] });\n  }\n}}\n```\n\n**Acceptance Criteria:**\n- [ ] Settings button in NodeToolbar opens Agent Settings Dialog\n- [ ] Settings button is hidden when spec #66 is not implemented\n- [ ] MeshPanel manages settingsAgentId state\n- [ ] Dialog receives the correct agentId\n- [ ] Closing the dialog invalidates topology query for data refresh\n- [ ] No runtime errors if AgentDialog component doesn't exist\n- [ ] Tests: Settings callback propagates from AgentNode through TopologyGraph to MeshPanel",
      "activeForm": "Integrating Agent Settings Dialog with topology",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["4.1"],
      "parallelWith": []
    },
    {
      "id": "4.3",
      "phase": 4,
      "phaseName": "Interactions & Animations",
      "subject": "[mesh-topology-elevation] [P4] Add fly-to selection animation and ReactFlowProvider",
      "description": "Implement smooth viewport animation when selecting an agent node, using `useReactFlow().setCenter()`.\n\n**Files to modify:**\n- `apps/client/src/layers/features/mesh/ui/TopologyGraph.tsx`\n- `apps/client/src/layers/features/mesh/ui/MeshPanel.tsx`\n\n**Implementation Steps:**\n\n`useReactFlow()` requires the component to be inside a `<ReactFlowProvider>`. The current `TopologyGraph` contains the `<ReactFlow>` component directly. We need to either:\n\n**Option A (recommended):** Split into `TopologyGraph` (outer with ReactFlowProvider) and `TopologyGraphInner` (inner with ReactFlow + useReactFlow).\n\n1. In `TopologyGraph.tsx`, create the inner component:\n```tsx\nimport { ReactFlowProvider, useReactFlow } from '@xyflow/react';\n\nfunction TopologyGraphInner({ onSelectAgent, onOpenSettings }: TopologyGraphProps) {\n  const { setCenter, getZoom } = useReactFlow();\n  const { data: topology, isLoading, isError, refetch } = useTopology();\n\n  // ... existing node/edge construction ...\n\n  const handleNodeClick = useCallback(\n    (_: React.MouseEvent, node: Node) => {\n      if (node.type !== 'agent') return;\n      onSelectAgent?.(node.id);\n\n      // Fly-to: center viewport on selected node\n      const targetZoom = Math.max(getZoom(), 1.0);\n      setCenter(\n        node.position.x + 100, // offset to center of 200px node\n        node.position.y + 36,  // offset to center of 72px node\n        { zoom: targetZoom, duration: 350 }\n      );\n    },\n    [onSelectAgent, setCenter, getZoom],\n  );\n\n  // ... existing render ...\n}\n\n/** Wraps TopologyGraphInner in ReactFlowProvider for useReactFlow() access. */\nexport function TopologyGraph(props: TopologyGraphProps) {\n  return (\n    <ReactFlowProvider>\n      <TopologyGraphInner {...props} />\n    </ReactFlowProvider>\n  );\n}\n```\n\n2. The fly-to animation:\n- Gets current zoom level via `getZoom()`\n- Sets target zoom to at least 1.0 (so the node is readable after selection)\n- Centers on the node's center point (position + half width/height)\n- Uses 350ms duration for smooth animation\n- Only fires for agent nodes, not group nodes\n\n3. The `node.position` for child nodes (inside groups) is relative to the parent. For fly-to to work correctly with grouped nodes, compute the absolute position:\n```tsx\nconst handleNodeClick = useCallback(\n  (_: React.MouseEvent, node: Node) => {\n    if (node.type !== 'agent') return;\n    onSelectAgent?.(node.id);\n\n    // Compute center position (handles both grouped and ungrouped nodes)\n    let centerX = node.position.x + 100;\n    let centerY = node.position.y + 36;\n\n    // If the node has a parent, its position is relative — add parent offset\n    if (node.parentId) {\n      const parentNode = nodes.find((n) => n.id === node.parentId);\n      if (parentNode) {\n        centerX += parentNode.position.x;\n        centerY += parentNode.position.y;\n      }\n    }\n\n    const targetZoom = Math.max(getZoom(), 1.0);\n    setCenter(centerX, centerY, { zoom: targetZoom, duration: 350 });\n  },\n  [onSelectAgent, setCenter, getZoom, nodes],\n);\n```\n\n**Acceptance Criteria:**\n- [ ] Selecting an agent node smoothly pans and zooms to center on it\n- [ ] Zoom level is maintained or increased to at least 1.0x\n- [ ] Animation duration is 350ms\n- [ ] Fly-to only triggers for agent nodes, not group/namespace nodes\n- [ ] Fly-to works correctly for nodes inside group containers (absolute position computed)\n- [ ] `ReactFlowProvider` wraps the inner component\n- [ ] No errors from `useReactFlow()` usage\n- [ ] Tests: handleNodeClick calls setCenter with correct coordinates\n- [ ] Tests: Mock useReactFlow for fly-to animation tests",
      "activeForm": "Adding fly-to selection animation and ReactFlowProvider",
      "size": "medium",
      "priority": "high",
      "dependencies": ["2.2"],
      "parallelWith": ["4.1", "4.4"]
    },
    {
      "id": "4.4",
      "phase": 4,
      "phaseName": "Interactions & Animations",
      "subject": "[mesh-topology-elevation] [P4] Add AgentHealthDetail slide animation and CrossNamespaceEdge enhancements",
      "description": "Wrap AgentHealthDetail in motion animation for slide-in/out, and enhance CrossNamespaceEdge with flow particles, theme colors, and conditional labels.\n\n**Files to modify:**\n- `apps/client/src/layers/features/mesh/ui/MeshPanel.tsx`\n- `apps/client/src/layers/features/mesh/ui/CrossNamespaceEdge.tsx`\n- `apps/client/src/layers/features/mesh/ui/AgentHealthDetail.tsx`\n\n**1. AgentHealthDetail Slide Animation (MeshPanel.tsx):**\n\nWrap the existing `AgentHealthDetail` in `AnimatePresence` + `motion.div`:\n\n```tsx\nimport { AnimatePresence, motion } from 'motion/react';\n\n// In the topology TabsContent:\n<TabsContent value=\"topology\" className=\"relative flex-1 overflow-hidden\">\n  <div className=\"absolute inset-0\">\n    <Suspense fallback={...}>\n      <LazyTopologyGraph onSelectAgent={setSelectedAgentId} onOpenSettings={setSettingsAgentId} />\n    </Suspense>\n  </div>\n  <AnimatePresence>\n    {selectedAgentId && (\n      <motion.div\n        key={selectedAgentId}\n        initial={{ x: 64, opacity: 0 }}\n        animate={{ x: 0, opacity: 1 }}\n        exit={{ x: 64, opacity: 0 }}\n        transition={{ duration: 0.2, ease: 'easeOut' }}\n        className=\"absolute right-0 top-0 bottom-0\"\n      >\n        <AgentHealthDetail\n          agentId={selectedAgentId}\n          onClose={() => setSelectedAgentId(null)}\n        />\n      </motion.div>\n    )}\n  </AnimatePresence>\n</TabsContent>\n```\n\nThe `key={selectedAgentId}` ensures re-animation when switching between agents.\n\n**2. CrossNamespaceEdge Enhancements (CrossNamespaceEdge.tsx):**\n\nReplace the entire component with:\n\n```tsx\nimport { useState, useCallback } from 'react';\nimport {\n  BaseEdge,\n  EdgeLabelRenderer,\n  getBezierPath,\n  MarkerType,\n  type EdgeProps,\n} from '@xyflow/react';\n\ninterface CrossNamespaceEdgeData extends Record<string, unknown> {\n  label: string;\n}\n\nconst prefersReducedMotion = typeof window !== 'undefined'\n  ? window.matchMedia('(prefers-reduced-motion: reduce)').matches\n  : false;\n\n/** Cross-namespace allow edge with flow particles and conditional labels. */\nexport function CrossNamespaceEdge(props: EdgeProps) {\n  const [isHovered, setIsHovered] = useState(false);\n  const [edgePath, labelX, labelY] = getBezierPath({\n    sourceX: props.sourceX,\n    sourceY: props.sourceY,\n    sourcePosition: props.sourcePosition,\n    targetX: props.targetX,\n    targetY: props.targetY,\n    targetPosition: props.targetPosition,\n  });\n\n  const label = (props.data as CrossNamespaceEdgeData | undefined)?.label;\n  const handleMouseEnter = useCallback(() => setIsHovered(true), []);\n  const handleMouseLeave = useCallback(() => setIsHovered(false), []);\n\n  return (\n    <g onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>\n      <BaseEdge\n        id={props.id}\n        path={edgePath}\n        markerEnd={MarkerType.ArrowClosed}\n        style={{\n          stroke: 'var(--color-primary)',\n          strokeWidth: 2,\n          strokeDasharray: '6 3',\n        }}\n      />\n\n      {/* Flow particle — skipped when prefers-reduced-motion */}\n      {!prefersReducedMotion && (\n        <circle r=\"3\" fill=\"var(--color-primary)\" opacity=\"0.7\">\n          <animateMotion dur=\"3s\" repeatCount=\"indefinite\" path={edgePath} />\n        </circle>\n      )}\n\n      {/* Label only visible when selected or hovered */}\n      {(props.selected || isHovered) && label && (\n        <EdgeLabelRenderer>\n          <div\n            className=\"nodrag nopan rounded border border-primary/30 bg-primary/5 px-1.5 py-0.5 text-[10px] font-medium text-primary\"\n            style={{\n              position: 'absolute',\n              transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n              pointerEvents: 'all',\n            }}\n          >\n            {label}\n          </div>\n        </EdgeLabelRenderer>\n      )}\n    </g>\n  );\n}\n```\n\nKey changes from current implementation:\n- Replace hardcoded `#3b82f6` with `var(--color-primary)` for theming\n- Add SVG `<circle>` with `<animateMotion>` for flow particles along the edge path\n- Flow particles gated on `prefers-reduced-motion`\n- Edge label only shows when `selected` or `isHovered` (not always visible)\n- Label styling uses design token classes (`border-primary/30`, `bg-primary/5`, `text-primary`) instead of hardcoded blue classes\n- Added hover state tracking\n\n**3. AgentHealthDetail \"Open Settings\" button (AgentHealthDetail.tsx):**\n\nAdd an \"Open Settings\" button at the bottom of the component:\n```tsx\n// Add prop:\ninterface AgentHealthDetailProps {\n  agentId: string;\n  onClose: () => void;\n  onOpenSettings?: (agentId: string) => void;\n}\n\n// At the bottom of the health detail panel, before closing </div>:\n{onOpenSettings && (\n  <button\n    type=\"button\"\n    onClick={() => onOpenSettings(agentId)}\n    className=\"mt-4 w-full rounded-md border px-3 py-1.5 text-xs text-muted-foreground hover:bg-muted hover:text-foreground\"\n  >\n    Open Settings\n  </button>\n)}\n```\n\n**Acceptance Criteria:**\n- [ ] AgentHealthDetail slides in from right with motion animation (x: 64->0, opacity: 0->1)\n- [ ] AgentHealthDetail slides out on close (x: 0->64, opacity: 1->0)\n- [ ] Switching between agents re-triggers the slide animation (key={selectedAgentId})\n- [ ] Animation duration is 200ms with easeOut\n- [ ] CrossNamespaceEdge uses `var(--color-primary)` instead of hardcoded `#3b82f6`\n- [ ] Flow particles (animated circle) travel along allow edges\n- [ ] Flow particles absent when `prefers-reduced-motion` is set\n- [ ] Edge label only visible on hover or selection, not always\n- [ ] Edge label uses design token classes\n- [ ] AgentHealthDetail has \"Open Settings\" button (conditional on callback)\n- [ ] Tests: CrossNamespaceEdge uses var(--color-primary)\n- [ ] Tests: Flow particle present when reduced motion not preferred\n- [ ] Tests: Flow particle absent when reduced motion preferred\n- [ ] Tests: Label only visible when selected",
      "activeForm": "Adding AgentHealthDetail slide animation and CrossNamespaceEdge enhancements",
      "size": "large",
      "priority": "high",
      "dependencies": ["1.3"],
      "parallelWith": ["4.1", "4.3"]
    },
    {
      "id": "5.1",
      "phase": 5,
      "phaseName": "Server Enrichment & Schema",
      "subject": "[mesh-topology-elevation] [P5] Extend TopologyView schema with enrichment fields",
      "description": "Add `TopologyAgentSchema` to the shared mesh schemas and update `NamespaceInfoSchema` to use it.\n\n**Files to modify:**\n- `packages/shared/src/mesh-schemas.ts`\n\n**Implementation Steps:**\n\n1. Add `AgentHealthStatusSchema` if not already present:\n```typescript\nexport const AgentHealthStatusSchema = z\n  .enum(['active', 'inactive', 'stale'])\n  .openapi('AgentHealthStatus');\n\nexport type AgentHealthStatus = z.infer<typeof AgentHealthStatusSchema>;\n```\n\n2. Create `TopologyAgentSchema` that extends `AgentManifestSchema` with enrichment fields:\n```typescript\nexport const TopologyAgentSchema = AgentManifestSchema.extend({\n  healthStatus: AgentHealthStatusSchema.default('stale'),\n  relayAdapters: z.array(z.string()).default([]),\n  relaySubject: z.string().nullable().default(null),\n  pulseScheduleCount: z.number().int().default(0),\n  lastSeenAt: z.string().nullable().default(null),\n  lastSeenEvent: z.string().nullable().default(null),\n}).openapi('TopologyAgent');\n\nexport type TopologyAgent = z.infer<typeof TopologyAgentSchema>;\n```\n\n3. Update `NamespaceInfoSchema` to use `TopologyAgentSchema`:\n```typescript\nexport const NamespaceInfoSchema = z\n  .object({\n    namespace: z.string(),\n    agentCount: z.number().int(),\n    agents: z.array(TopologyAgentSchema),\n  })\n  .openapi('NamespaceInfo');\n```\n\n**Backward compatibility:** All new fields have defaults (`[]`, `null`, `0`, `'stale'`) so existing server responses that don't include these fields will still parse correctly. Clients receiving non-enriched responses will see safe default values.\n\n**Export the new types:** Ensure `TopologyAgent` and `AgentHealthStatus` are exported from the module.\n\n**Acceptance Criteria:**\n- [ ] `TopologyAgentSchema` extends `AgentManifestSchema` with all enrichment fields\n- [ ] `NamespaceInfoSchema.agents` uses `TopologyAgentSchema`\n- [ ] All new fields have sensible defaults for backward compatibility\n- [ ] `TopologyAgent` type is exported\n- [ ] `AgentHealthStatus` type is exported\n- [ ] OpenAPI metadata present on new schemas\n- [ ] Existing code that uses `AgentManifest` still compiles\n- [ ] Tests: TopologyAgentSchema parses with all defaults when enrichment absent\n- [ ] Tests: TopologyAgentSchema accepts full enrichment payload",
      "activeForm": "Extending TopologyView schema with enrichment fields",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["5.2"]
    },
    {
      "id": "5.2",
      "phase": 5,
      "phaseName": "Server Enrichment & Schema",
      "subject": "[mesh-topology-elevation] [P5] Add server-side topology enrichment with Relay/Pulse/health joins",
      "description": "Extend the `GET /api/mesh/topology` endpoint to enrich each agent with Relay adapter info, Pulse schedule count, and health data.\n\n**Files to modify:**\n- `apps/server/src/routes/mesh.ts`\n\n**Implementation Steps:**\n\nThe current topology endpoint simply calls `meshCore.getTopology(namespace)` and returns the result. We need to enrich each agent in the response.\n\n1. Update the `createMeshRouter` factory to accept additional dependencies:\n```typescript\nimport type { PulseStore } from '../services/pulse-store';\nimport type { RelayCore } from '@dorkos/relay'; // or wherever RelayCore lives\n\ninterface MeshRouterDeps {\n  meshCore: MeshCore;\n  pulseStore?: PulseStore;\n  relayCore?: { getEndpoints(): Array<{ subject: string; cwd?: string }> };\n}\n\nexport function createMeshRouter({ meshCore, pulseStore, relayCore }: MeshRouterDeps): Router {\n```\n\n2. Update the topology endpoint to enrich agents:\n```typescript\nrouter.get('/topology', async (req, res) => {\n  const namespace = typeof req.query.namespace === 'string' ? req.query.namespace : undefined;\n  const topology = meshCore.getTopology(namespace);\n\n  // Enrich each agent with cross-subsystem data\n  for (const ns of topology.namespaces) {\n    for (let i = 0; i < ns.agents.length; i++) {\n      const agent = ns.agents[i];\n      const enriched: Record<string, unknown> = { ...agent };\n\n      // Health status — already computed at query time per ADR-0036\n      try {\n        const health = meshCore.getAgentHealth(agent.id);\n        if (health) {\n          enriched.healthStatus = health.status;\n          enriched.lastSeenAt = health.lastSeenAt;\n          enriched.lastSeenEvent = health.lastSeenEvent;\n        }\n      } catch {\n        // Health data unavailable — use defaults\n      }\n\n      // Relay adapters\n      if (relayCore) {\n        try {\n          const endpoints = relayCore.getEndpoints();\n          const agentEndpoints = endpoints.filter(\n            (ep) => ep.cwd === (agent as Record<string, unknown>).cwd\n          );\n          enriched.relayAdapters = agentEndpoints.map((ep) => {\n            // Extract adapter name from subject (e.g., \"relay.agent.code-reviewer\" -> \"code-reviewer\")\n            const parts = ep.subject.split('.');\n            return parts[parts.length - 1];\n          });\n          enriched.relaySubject = agentEndpoints[0]?.subject ?? null;\n        } catch {\n          enriched.relayAdapters = [];\n          enriched.relaySubject = null;\n        }\n      } else {\n        enriched.relayAdapters = [];\n        enriched.relaySubject = null;\n      }\n\n      // Pulse schedule count\n      if (pulseStore) {\n        try {\n          const schedules = pulseStore.listSchedules();\n          const agentCwd = (agent as Record<string, unknown>).cwd as string | undefined;\n          const count = agentCwd\n            ? schedules.filter((s) => s.cwd === agentCwd).length\n            : 0;\n          enriched.pulseScheduleCount = count;\n        } catch {\n          enriched.pulseScheduleCount = 0;\n        }\n      } else {\n        enriched.pulseScheduleCount = 0;\n      }\n\n      ns.agents[i] = enriched as typeof agent;\n    }\n  }\n\n  return res.json(topology);\n});\n```\n\n3. Update the call site in `index.ts` (or wherever `createMeshRouter` is called) to pass the new dependencies:\n```typescript\nconst meshRouter = createMeshRouter({\n  meshCore,\n  pulseStore: pulseStoreInstance,\n  relayCore: relayCoreInstance,\n});\n```\n\n**Error handling:** Each enrichment step is wrapped in try/catch so that if Relay or Pulse subsystems are unavailable, the topology endpoint still returns successfully with default values. This is important because Relay and Pulse are independently feature-flagged.\n\n**Performance:** The enrichment runs inline with the request. At scale (50+ agents), this could be optimized with a batch query, but for the typical 3-20 agent range, individual lookups are fine.\n\n**Acceptance Criteria:**\n- [ ] Topology response includes `healthStatus`, `lastSeenAt`, `lastSeenEvent` per agent\n- [ ] Topology response includes `relayAdapters` array per agent\n- [ ] Topology response includes `relaySubject` per agent\n- [ ] Topology response includes `pulseScheduleCount` per agent\n- [ ] All enrichment fields have safe defaults when subsystems are unavailable\n- [ ] Enrichment failures don't break the topology endpoint\n- [ ] Relay/Pulse dependencies are optional (not required for mesh-only deployments)\n- [ ] Tests: Relay adapter names included in topology response\n- [ ] Tests: Pulse schedule count included per agent\n- [ ] Tests: Health status computed correctly\n- [ ] Tests: Empty defaults for agents without Relay/Pulse data",
      "activeForm": "Adding server-side topology enrichment with Relay, Pulse, and health joins",
      "size": "large",
      "priority": "high",
      "dependencies": ["5.1"],
      "parallelWith": []
    },
    {
      "id": "5.3",
      "phase": 5,
      "phaseName": "Server Enrichment & Schema",
      "subject": "[mesh-topology-elevation] [P5] Update TopologyLegend with new visual elements",
      "description": "Add legend entries for deny edges, flow particles, health statuses, Relay/Pulse indicators, and a zoom hint.\n\n**Files to modify:**\n- `apps/client/src/layers/features/mesh/ui/TopologyLegend.tsx`\n\n**Implementation Steps:**\n\nReplace the current legend with an expanded version that documents all visual elements:\n\n```tsx\nimport { Panel } from '@xyflow/react';\nimport { Zap, Clock } from 'lucide-react';\n\ninterface NamespaceEntry {\n  namespace: string;\n  color: string;\n}\n\ninterface TopologyLegendProps {\n  namespaces: NamespaceEntry[];\n}\n\n/** Graph legend showing edge types, health states, indicators, and namespace colors. */\nexport function TopologyLegend({ namespaces }: TopologyLegendProps) {\n  return (\n    <Panel position=\"bottom-left\">\n      <div className=\"flex flex-col gap-1.5 rounded-md border bg-card/90 px-3 py-2 text-[11px] text-muted-foreground shadow-sm backdrop-blur-sm\">\n        {/* Edge types */}\n        <div className=\"flex items-center gap-2\">\n          <svg width=\"24\" height=\"6\" className=\"shrink-0\">\n            <line x1=\"0\" y1=\"3\" x2=\"24\" y2=\"3\" stroke=\"var(--color-primary)\" strokeWidth=\"1.5\" strokeDasharray=\"4 2\" />\n            <circle cx=\"12\" cy=\"3\" r=\"2\" fill=\"var(--color-primary)\" opacity=\"0.7\" />\n          </svg>\n          <span>Allow rule (data flow)</span>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <svg width=\"24\" height=\"2\" className=\"shrink-0\">\n            <line x1=\"0\" y1=\"1\" x2=\"24\" y2=\"1\" stroke=\"var(--color-destructive)\" strokeWidth=\"1.5\" strokeDasharray=\"4 4\" opacity=\"0.5\" />\n          </svg>\n          <span>Deny rule</span>\n        </div>\n\n        {/* Health statuses */}\n        <div className=\"flex items-center gap-2\">\n          <span className=\"relative inline-flex\">\n            <span className=\"h-2.5 w-2.5 rounded-full bg-green-500\" />\n            <span className=\"absolute inset-0 h-2.5 w-2.5 animate-ping rounded-full bg-green-500/30\" />\n          </span>\n          <span>Active agent</span>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <span className=\"h-2.5 w-2.5 rounded-full bg-amber-500\" />\n          <span>Inactive agent</span>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <span className=\"h-2.5 w-2.5 rounded-full bg-zinc-400\" />\n          <span>Stale agent</span>\n        </div>\n\n        {/* Indicators */}\n        <div className=\"flex items-center gap-2\">\n          <Zap className=\"size-3 shrink-0\" />\n          <span>Relay adapters</span>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <Clock className=\"size-3 shrink-0\" />\n          <span>Pulse schedules</span>\n        </div>\n\n        {/* Namespace colors */}\n        {namespaces.length > 1 &&\n          namespaces.map((ns) => (\n            <div key={ns.namespace} className=\"flex items-center gap-2\">\n              <span\n                className=\"inline-block h-2.5 w-2.5 rounded-full\"\n                style={{ backgroundColor: ns.color }}\n              />\n              <span>{ns.namespace}</span>\n            </div>\n          ))}\n\n        {/* Zoom hint */}\n        <div className=\"mt-1 border-t pt-1 text-[10px] italic\">\n          Zoom in for more detail\n        </div>\n      </div>\n    </Panel>\n  );\n}\n```\n\n**Changes from current:**\n- \"Same namespace\" line entry removed (no more spoke edges)\n- \"Cross-namespace\" entry updated with moving dot indicator and renamed to \"Allow rule (data flow)\"\n- New \"Deny rule\" entry with red dashed line\n- New health status entries: Active (green + pulse ring), Inactive (amber), Stale (gray)\n- New Relay indicator entry (Zap icon)\n- New Pulse indicator entry (Clock icon)\n- New \"Zoom in for more detail\" hint text\n- Legend uses `var(--color-primary)` and `var(--color-destructive)` CSS variables\n\n**Acceptance Criteria:**\n- [ ] Legend shows allow rule with dot indicator using `var(--color-primary)`\n- [ ] Legend shows deny rule with red dashed line using `var(--color-destructive)`\n- [ ] Legend shows three health statuses (active with pulse ring, inactive, stale)\n- [ ] Legend shows Relay Zap icon and Pulse Clock icon\n- [ ] Legend shows namespace colors when multiple namespaces\n- [ ] Legend shows \"Zoom in for more detail\" hint\n- [ ] No hardcoded color values (uses CSS variables and Tailwind classes)\n- [ ] Tests: Legend renders all expected entries",
      "activeForm": "Updating TopologyLegend with new visual elements",
      "size": "small",
      "priority": "medium",
      "dependencies": ["1.3"],
      "parallelWith": ["5.1", "5.2"]
    },
    {
      "id": "6.1",
      "phase": 6,
      "phaseName": "Accessibility & Performance",
      "subject": "[mesh-topology-elevation] [P6] Ensure all animations respect prefers-reduced-motion",
      "description": "Audit all animation-bearing components and ensure they respect the user's `prefers-reduced-motion` system setting.\n\n**Files to audit and modify:**\n- `apps/client/src/layers/features/mesh/ui/AgentNode.tsx` — health pulse ring (`animate-ping`)\n- `apps/client/src/layers/features/mesh/ui/CrossNamespaceEdge.tsx` — flow particles (`<animateMotion>`)\n- `apps/client/src/layers/features/mesh/ui/NamespaceGroupNode.tsx` — active pulse dot (`animate-pulse`)\n- `apps/client/src/layers/features/mesh/ui/MeshPanel.tsx` — AgentHealthDetail slide animation (motion)\n\n**Implementation Steps:**\n\n1. Create a shared reduced-motion detection hook or utility in the mesh feature lib:\n```tsx\n// apps/client/src/layers/features/mesh/lib/use-reduced-motion.ts\nimport { useState, useEffect } from 'react';\n\n/** Returns true when the user prefers reduced motion. */\nexport function usePrefersReducedMotion(): boolean {\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(() =>\n    typeof window !== 'undefined'\n      ? window.matchMedia('(prefers-reduced-motion: reduce)').matches\n      : false\n  );\n\n  useEffect(() => {\n    const mql = window.matchMedia('(prefers-reduced-motion: reduce)');\n    const handler = (e: MediaQueryListEvent) => setPrefersReducedMotion(e.matches);\n    mql.addEventListener('change', handler);\n    return () => mql.removeEventListener('change', handler);\n  }, []);\n\n  return prefersReducedMotion;\n}\n```\n\nAlternatively, since the app already wraps in `<MotionConfig reducedMotion=\"user\">` (per CLAUDE.md), `motion/react` animations already respect the setting. For non-motion animations:\n\n2. **AgentNode.tsx** — Gate `animate-ping` class on reduced motion:\n```tsx\nconst prefersReducedMotion = usePrefersReducedMotion();\n// In DefaultCard and ExpandedCard:\n{d.healthStatus === 'active' && !prefersReducedMotion && (\n  <span className=\"absolute inset-0 h-2.5 w-2.5 animate-ping rounded-full bg-green-500/30\" />\n)}\n```\n\n3. **CrossNamespaceEdge.tsx** — Already gated (from task 4.4), but verify the check:\n```tsx\nconst prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n{!prefersReducedMotion && (\n  <circle r=\"3\" fill=\"var(--color-primary)\" opacity=\"0.7\">\n    <animateMotion dur=\"3s\" repeatCount=\"indefinite\" path={edgePath} />\n  </circle>\n)}\n```\n\n4. **NamespaceGroupNode.tsx** — Gate `animate-pulse` on the active dot:\n```tsx\n{d.activeCount > 0 && (\n  <span\n    className={cn(\n      'h-1.5 w-1.5 rounded-full',\n      prefersReducedMotion ? '' : 'animate-pulse'\n    )}\n    style={{ backgroundColor: d.color }}\n  />\n)}\n```\n\n5. **MeshPanel.tsx** — The `motion.div` for AgentHealthDetail slide animation is automatically handled by `<MotionConfig reducedMotion=\"user\">` in App.tsx. Verify no additional gating needed.\n\n6. **TopologyLegend.tsx** — Gate the `animate-ping` in the legend active agent entry:\n```tsx\n{!prefersReducedMotion && (\n  <span className=\"absolute inset-0 h-2.5 w-2.5 animate-ping rounded-full bg-green-500/30\" />\n)}\n```\n\n**Acceptance Criteria:**\n- [ ] Health pulse ring (`animate-ping`) hidden when `prefers-reduced-motion` is set\n- [ ] Flow particles (`<animateMotion>`) hidden when `prefers-reduced-motion` is set\n- [ ] Namespace group pulse dot (`animate-pulse`) static when `prefers-reduced-motion` is set\n- [ ] Motion-based animations (slide-in) respect `<MotionConfig reducedMotion=\"user\">`\n- [ ] Legend active agent entry respects `prefers-reduced-motion`\n- [ ] `usePrefersReducedMotion` hook reacts to runtime changes (system preference toggle)\n- [ ] Tests: Mock window.matchMedia for reduced motion testing\n- [ ] Tests: Verify animate-ping absent when reduced motion preferred\n- [ ] Tests: Verify animateMotion absent when reduced motion preferred",
      "activeForm": "Ensuring all animations respect prefers-reduced-motion",
      "size": "medium",
      "priority": "high",
      "dependencies": ["3.1", "4.4", "5.3"],
      "parallelWith": []
    }
  ]
}
